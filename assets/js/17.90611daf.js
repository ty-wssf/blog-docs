(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{446:function(r,n,e){"use strict";e.r(n);var o=e(30),t=Object(o.a)({},(function(){var r=this,n=r.$createElement,e=r._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[e("h1",{attrs:{id:"dubbo-源码分析-集群容错之directory"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dubbo-源码分析-集群容错之directory"}},[r._v("#")]),r._v(" Dubbo 源码分析 - 集群容错之Directory")]),r._v(" "),e("h2",{attrs:{id:"_1-简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-简介"}},[r._v("#")]),r._v(" 1. 简介")]),r._v(" "),e("p",[r._v("前面文章分析了服务的导出与引用过程，从本篇文章开始，我将开始分析 Dubbo 集群容错方面的源码。这部分源码包含四个部分，分别是服务目录 Directory、服务路由 Router、集群 Cluster 和负载均衡 LoadBalance。这几个部分的源码逻辑比较独立，我会分四篇文章进行分析。本篇文章作为集群容错的开篇文章，将和大家一起分析服务目录相关的源码。在进行深入分析之前，我们先来了解一下服务目录是什么。服务目录中存储了一些和服务提供者有关的信息，通过服务目录，服务消费者可获取到服务提供者的信息，比如 ip、端口、服务协议等。通过这些信息，服务消费者就可通过 Netty 等客户端进行远程调用。在一个服务集群中，服务提供者数量并不是一成不变的，如果集群中新增了一台机器，相应地在服务目录中就要新增一条服务提供者记录。或者，如果服务提供者的配置修改了，服务目录中的记录也要做相应的更新。如果这样说，服务目录和注册中心的功能不就雷同了吗。确实如此，这里这么说是为了方便大家理解。实际上服务目录在获取注册中心的服务配置信息后，会为每条配置信息生成一个 Invoker 对象，并把这个 Invoker 对象存储起来，这个 Invoker 才是服务目录最终持有的对象。Invoker 有什么用呢？看名字就知道了，这是一个具有远程调用功能的对象。讲到这大家应该知道了什么是服务目录了，它可以看做是 Invoker 集合，且这个集合中的元素会随注册中心的变化而进行动态调整。")]),r._v(" "),e("p",[r._v("好了，关于服务目录这里就先介绍这些，大家先有个大致印象即可。接下来我们通过继承体系图来了解一下服务目录的家族成员都有哪些。")]),r._v(" "),e("h2",{attrs:{id:"_2-继承体系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-继承体系"}},[r._v("#")]),r._v(" 2. 继承体系")]),r._v(" "),e("p",[r._v("服务目录目前内置的实现有两个，分别为 StaticDirectory 和 RegistryDirectory，它们均是 AbstractDirectory 的子类。AbstractDirectory 实现了 Directory 接口，这个接口包含了一个重要的方法定义，即 list(Invocation)，用于列举 Invoker。下面我们来看一下他们的继承体系图。")]),r._v(" "),e("p",[e("img",{attrs:{src:"https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15421157549297.jpg",alt:"img"}})]),r._v(" "),e("p",[r._v("如上，Directory 继承自 Node 接口，Node 这个接口继承者比较多，像 Registry、Monitor、Invoker 等继承了这个接口。这个接口包含了一个获取配置信息的方法 getUrl，实现该接口的类可以向外提供配置信息。另外，大家注意看 RegistryDirectory 实现了 NotifyListener 接口，当注册中心节点信息发生变化后，RegistryDirectory 可以通过此接口方法得到变更信息，并根据变更信息动态调整内部 Invoker 列表。")]),r._v(" "),e("p",[r._v("现在大家对服务目录的继承体系应该比较清楚了，下面我们深入到源码中，探索服务目录是如何实现的。")]),r._v(" "),e("h2",{attrs:{id:"_3-源码分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-源码分析"}},[r._v("#")]),r._v(" 3. 源码分析")]),r._v(" "),e("p",[r._v("本章我将分析 AbstractDirectory 和它两个子类的源码。这里之所以要分析 AbstractDirectory，而不是直接分析子类是有一定原因的。AbstractDirectory 封装了 Invoker 列举流程，具体的列举逻辑则由子类实现，这是典型的模板模式。所以，接下来我们先来看一下 AbstractDirectory 的源码。")]),r._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[r._v('public List<Invoker<T>> list(Invocation invocation) throws RpcException {\n    if (destroyed) {\n        throw new RpcException("Directory already destroyed...");\n    }\n    \n    // 调用 doList 方法列举 Invoker，这里的 doList 是模板方法，由子类实现\n    List<Invoker<T>> invokers = doList(invocation);\n    \n    // 获取路由器\n    List<Router> localRouters = this.routers;\n    if (localRouters != null && !localRouters.isEmpty()) {\n        for (Router router : localRouters) {\n            try {\n                // 获取 runtime 参数，并根据参数决定是否进行路由\n                if (router.getUrl() == null || router.getUrl().getParameter(Constants.RUNTIME_KEY, false)) {\n                    // 进行服务路由\n                    invokers = router.route(invokers, getConsumerUrl(), invocation);\n                }\n            } catch (Throwable t) {\n                logger.error("Failed to execute router: ...");\n            }\n        }\n    }\n    return invokers;\n}\n\n// 模板方法，由子类实现\nprotected abstract List<Invoker<T>> doList(Invocation invocation) throws RpcException;\n')])])]),e("p",[r._v("上面就是 AbstractDirectory 的 list 方法源码，这个方法封装了 Invoker 的列举过程。如下：")]),r._v(" "),e("ol",[e("li",[r._v("调用 doList 获取 Invoker 列表")]),r._v(" "),e("li",[r._v("根据 Router 的 getUrl 返回值为空与否，以及 runtime 参数决定是否进行服务路由")])]),r._v(" "),e("p",[r._v("以上步骤中，doList 是模板方法，需由子类实现。Router 的 runtime 参数这里简单说明一下，这个参数决定了是否在每次调用服务时都执行路由规则。如果 runtime 为 true，那么每次调用服务前，都需要进行服务路由。这个对性能造成影响，慎重配置。关于该参数更详细的说明，请参考"),e("a",{attrs:{href:"http://dubbo.apache.org/zh-cn/docs/user/demos/routing-rule.html",target:"_blank",rel:"noopener noreferrer"}},[r._v("官方文档"),e("OutboundLink")],1),r._v("。")]),r._v(" "),e("p",[r._v("介绍完 AbstractDirectory，接下来我们开始分析子类的源码。")]),r._v(" "),e("h3",{attrs:{id:"_3-1-staticdirectory"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-staticdirectory"}},[r._v("#")]),r._v(" 3.1 StaticDirectory")]),r._v(" "),e("p",[r._v("StaticDirectory 即静态服务目录，顾名思义，它内部存放的 Invoker 是不会变动的。所以，理论上它和不可变 List 的功能很相似。下面我们来看一下这个类的实现。")]),r._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[r._v("public class StaticDirectory<T> extends AbstractDirectory<T> {\n\n    // Invoker 列表\n    private final List<Invoker<T>> invokers;\n    \n    // 省略构造方法\n\n    @Override\n    public Class<T> getInterface() {\n        // 获取接口类\n        return invokers.get(0).getInterface();\n    }\n    \n    // 检测服务目录是否可用\n    @Override\n    public boolean isAvailable() {\n        if (isDestroyed()) {\n            return false;\n        }\n        for (Invoker<T> invoker : invokers) {\n            if (invoker.isAvailable()) {\n                // 只要有一个 Invoker 是可用的，就任务当前目录是可用的\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public void destroy() {\n        if (isDestroyed()) {\n            return;\n        }\n        // 调用父类销毁逻辑\n        super.destroy();\n        // 遍历 Invoker 列表，并执行相应的销毁逻辑\n        for (Invoker<T> invoker : invokers) {\n            invoker.destroy();\n        }\n        invokers.clear();\n    }\n\n    @Override\n    protected List<Invoker<T>> doList(Invocation invocation) throws RpcException {\n        // 列举 Inovker，也就是直接返回 invokers 成员变量\n        return invokers;\n    }\n}\n")])])]),e("p",[r._v("以上就是 StaticDirectory 的代码逻辑，很简单，大家都能看懂，我就不多说了。下面来看看 RegistryDirectory，这个类的逻辑比较复杂。")]),r._v(" "),e("h3",{attrs:{id:"_3-2-registrydirectory"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-registrydirectory"}},[r._v("#")]),r._v(" 3.2 RegistryDirectory")]),r._v(" "),e("p",[r._v("RegistryDirectory 是一种动态服务目录，它实现了 NotifyListener 接口。当注册中心服务配置发生变化后，RegistryDirectory 可收到与当前服务相关的变化。收到变更通知后，RegistryDirectory 可根据配置变更信息刷新 Invoker 列表。RegistryDirectory 中有几个比较重要的逻辑，第一是 Invoker 的列举逻辑，第二是接受服务配置变更的逻辑，第三是 Invoker 的刷新逻辑。接下来，我将按顺序对这三块逻辑。")]),r._v(" "),e("h4",{attrs:{id:"_3-2-1-列举-invoker"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-1-列举-invoker"}},[r._v("#")]),r._v(" 3.2.1 列举 Invoker")]),r._v(" "),e("p",[r._v("Invoker 列举逻辑封装在 doList 方法中，这是个模板方法，前面已经介绍过了。那这里就不过多啰嗦了，我们直入主题吧。")]),r._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[r._v('public List<Invoker<T>> doList(Invocation invocation) {\n    if (forbidden) {\n        // 服务提供者关闭或禁用了服务，此时抛出 No provider 异常\n        throw new RpcException(RpcException.FORBIDDEN_EXCEPTION,\n            "No provider available from registry ...");\n    }\n    List<Invoker<T>> invokers = null;\n    // 获取 Invoker 本地缓存\n    Map<String, List<Invoker<T>>> localMethodInvokerMap = this.methodInvokerMap;\n    if (localMethodInvokerMap != null && localMethodInvokerMap.size() > 0) {\n        // 获取方法名和参数列表\n        String methodName = RpcUtils.getMethodName(invocation);\n        Object[] args = RpcUtils.getArguments(invocation);\n        // 检测参数列表的第一个参数是否为 String 或 enum 类型\n        if (args != null && args.length > 0 && args[0] != null\n                && (args[0] instanceof String || args[0].getClass().isEnum())) {\n            // 通过 方法名 + 第一个参数名称 查询 Invoker 列表，具体的使用场景暂时没想到\n            invokers = localMethodInvokerMap.get(methodName + "." + args[0]);\n        }\n        if (invokers == null) {\n            // 通过方法名获取 Invoker 列表\n            invokers = localMethodInvokerMap.get(methodName);\n        }\n        if (invokers == null) {\n            // 通过星号 * 获取 Invoker 列表\n            invokers = localMethodInvokerMap.get(Constants.ANY_VALUE);\n        }\n        if (invokers == null) {\n            Iterator<List<Invoker<T>>> iterator = localMethodInvokerMap.values().iterator();\n            if (iterator.hasNext()) {\n                // 通过迭代器获取 Invoker 列表\n                invokers = iterator.next();\n            }\n        }\n    }\n\n\t// 返回 Invoker 列表\n    return invokers == null ? new ArrayList<Invoker<T>>(0) : invokers;\n}\n')])])]),e("p",[r._v("以上代码进行多次尝试，以期从 localMethodInvokerMap 中获取到 Invoker 列表。一般情况下，普通的调用可通过方法名获取到对应的 Invoker 列表，泛化调用可通过 ***** 获取到 Invoker 列表。按现有的逻辑，不管什么情况下，***** 到 Invoker 列表的映射关系 <*****, invokers> 总是存在的，也就意味着 localMethodInvokerMap.get(Constants.ANY_VALUE) 总是有值返回。除非这个值是 null，才会通过通过迭代器获取 Invoker 列表。至于什么情况下为空，我暂时未完全搞清楚，我猜测是被路由规则（用户可基于 Router 接口实现自定义路由器）处理后，可能会得到一个 null。目前仅是猜测，未做验证。")]),r._v(" "),e("p",[r._v("本节的逻辑主要是从 localMethodInvokerMap 中获取 Invoker，localMethodInvokerMap 源自 RegistryDirectory 类的成员变量 methodInvokerMap。doList 方法可以看做是对 methodInvokerMap 变量的读操作，至于对 methodInvokerMap 变量的写操作，这个将在后续进行分析。")]),r._v(" "),e("h4",{attrs:{id:"_3-2-2-接收服务变更通知"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-2-接收服务变更通知"}},[r._v("#")]),r._v(" 3.2.2 接收服务变更通知")]),r._v(" "),e("p",[r._v("RegistryDirectory 是一个动态服务目录，它需要接受注册中心配置进行动态调整。因此 RegistryDirectory 实现了 NotifyListener 接口，通过这个接口获取注册中心变更通知。下面我们来看一下具体的逻辑。")]),r._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[r._v('public synchronized void notify(List<URL> urls) {\n    // 定义三个集合，分别用于存放服务提供者 url，路由 url，配置器 url\n    List<URL> invokerUrls = new ArrayList<URL>();\n    List<URL> routerUrls = new ArrayList<URL>();\n    List<URL> configuratorUrls = new ArrayList<URL>();\n    for (URL url : urls) {\n        String protocol = url.getProtocol();\n        // 获取 category 参数\n        String category = url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);\n        // 根据 category 参数将 url 分别放到不同的列表中\n        if (Constants.ROUTERS_CATEGORY.equals(category)\n                || Constants.ROUTE_PROTOCOL.equals(protocol)) {\n            // 添加路由器 url\n            routerUrls.add(url);\n        } else if (Constants.CONFIGURATORS_CATEGORY.equals(category)\n                || Constants.OVERRIDE_PROTOCOL.equals(protocol)) {\n            // 添加配置器 url\n            configuratorUrls.add(url);\n        } else if (Constants.PROVIDERS_CATEGORY.equals(category)) {\n            // 添加服务提供者 url\n            invokerUrls.add(url);\n        } else {\n            // 忽略不支持的 category\n            logger.warn("Unsupported category ...");\n        }\n    }\n    if (configuratorUrls != null && !configuratorUrls.isEmpty()) {\n        // 将 url 转成 Configurator\n        this.configurators = toConfigurators(configuratorUrls);\n    }\n    if (routerUrls != null && !routerUrls.isEmpty()) {\n        // 将 url 转成 Router\n        List<Router> routers = toRouters(routerUrls);\n        if (routers != null) {\n            setRouters(routers);\n        }\n    }\n    List<Configurator> localConfigurators = this.configurators;\n    this.overrideDirectoryUrl = directoryUrl;\n    if (localConfigurators != null && !localConfigurators.isEmpty()) {\n        for (Configurator configurator : localConfigurators) {\n            // 配置 overrideDirectoryUrl\n            this.overrideDirectoryUrl = configurator.configure(overrideDirectoryUrl);\n        }\n    }\n\n    // 刷新 Invoker 列表\n    refreshInvoker(invokerUrls);\n}\n')])])]),e("p",[r._v("如上，notify 方法首先是根据 url 的 category 参数对 url 进行分门别类存储，然后通过 toRouters 和 toConfigurators 将 url 列表转成 Router 和 Configurator 列表。最后调用 refreshInvoker 方法刷新 Invoker 列表。这里的 toRouters 和 toConfigurators 方法逻辑不复杂，大家自行分析。接下来，我们把重点放在 refreshInvoker 方法上。")]),r._v(" "),e("h4",{attrs:{id:"_3-2-3-刷新-invoker-列表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-3-刷新-invoker-列表"}},[r._v("#")]),r._v(" 3.2.3 刷新 Invoker 列表")]),r._v(" "),e("p",[r._v("接着上一节继续分析，refreshInvoker 方法是保证 RegistryDirectory 随注册中心变化而变化的关键所在。这一块逻辑比较多，接下来一一进行分析。")]),r._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[r._v('private void refreshInvoker(List<URL> invokerUrls) {\n    // invokerUrls 仅有一个元素，且 url 协议头为 empty，此时表示禁用所有服务\n    if (invokerUrls != null && invokerUrls.size() == 1 && invokerUrls.get(0) != null\n            && Constants.EMPTY_PROTOCOL.equals(invokerUrls.get(0).getProtocol())) {\n        // 设置 forbidden 为 true\n        this.forbidden = true;\n        this.methodInvokerMap = null;\n        // 销毁所有 Invoker\n        destroyAllInvokers();\n    } else {\n        this.forbidden = false;\n        Map<String, Invoker<T>> oldUrlInvokerMap = this.urlInvokerMap;\n        if (invokerUrls.isEmpty() && this.cachedInvokerUrls != null) {\n            // 添加缓存 url 到 invokerUrls 中\n            invokerUrls.addAll(this.cachedInvokerUrls);\n        } else {\n            this.cachedInvokerUrls = new HashSet<URL>();\n            // 缓存 invokerUrls\n            this.cachedInvokerUrls.addAll(invokerUrls);\n        }\n        if (invokerUrls.isEmpty()) {\n            return;\n        }\n        // 将 url 转成 Invoker\n        Map<String, Invoker<T>> newUrlInvokerMap = toInvokers(invokerUrls);\n        // 将 newUrlInvokerMap 转成方法名到 Invoker 列表的映射\n        Map<String, List<Invoker<T>>> newMethodInvokerMap = toMethodInvokers(newUrlInvokerMap);\n        // 转换出错，直接打印异常，并返回\n        if (newUrlInvokerMap == null || newUrlInvokerMap.size() == 0) {\n            logger.error(new IllegalStateException("urls to invokers error ..."));\n            return;\n        }\n        // 合并多个组的 Invoker\n        this.methodInvokerMap = multiGroup ? toMergeMethodInvokerMap(newMethodInvokerMap) : newMethodInvokerMap;\n        // 保存为本地缓存\n        this.urlInvokerMap = newUrlInvokerMap;\n        try {\n            // 销毁无用 Invoker\n            destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap);\n        } catch (Exception e) {\n            logger.warn("destroyUnusedInvokers error. ", e);\n        }\n    }\n}\n')])])]),e("p",[r._v("上面方法的代码不是很多，但是逻辑却不少。首先时根据入参 invokerUrls 的数量和协议头判断是否禁用所有的服务，如果禁用，则将 forbidden 设为 true，并销毁所有的 Invoker。若不禁用，则将 url 转成 Invoker，得到 <url, Invoker> 的映射关系。然后进一步进行转换，得到 <methodName, Invoker 列表>。之后进行多组 Invoker 合并操作，并将合并结果赋值给 methodInvokerMap。methodInvokerMap 变量在 doList 方法中会被用到，doList 会对该变量进行读操作，在这里是写操作。当新的 Invoker 列表生成后，还要一个重要的工作要做，就是销毁无用的 Invoker，避免服务消费者调用已下线的服务的服务。")]),r._v(" "),e("p",[r._v("接下里，我将对上面涉及到的调用进行分析。按照顺序，这里先来分析 url 到 Invoker 的转换过程。")]),r._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[r._v('private Map<String, Invoker<T>> toInvokers(List<URL> urls) {\n    Map<String, Invoker<T>> newUrlInvokerMap = new HashMap<String, Invoker<T>>();\n    if (urls == null || urls.isEmpty()) {\n        return newUrlInvokerMap;\n    }\n    Set<String> keys = new HashSet<String>();\n    // 获取服务消费端配置的协议\n    String queryProtocols = this.queryMap.get(Constants.PROTOCOL_KEY);\n    for (URL providerUrl : urls) {\n        if (queryProtocols != null && queryProtocols.length() > 0) {\n            boolean accept = false;\n            String[] acceptProtocols = queryProtocols.split(",");\n            // 检测服务提供者协议是否被服务消费者所支持\n            for (String acceptProtocol : acceptProtocols) {\n                if (providerUrl.getProtocol().equals(acceptProtocol)) {\n                    accept = true;\n                    break;\n                }\n            }\n            if (!accept) {\n                // 若服务消费者协议头不被消费者所支持，则忽略当前 providerUrl\n                continue;\n            }\n        }\n        // 忽略 empty 协议\n        if (Constants.EMPTY_PROTOCOL.equals(providerUrl.getProtocol())) {\n            continue;\n        }\n        // 通过 SPI 检测服务端协议是否被消费端支持\n        if (!ExtensionLoader.getExtensionLoader(Protocol.class).hasExtension(providerUrl.getProtocol())) {\n            logger.error(new IllegalStateException("Unsupported protocol..."));\n            continue;\n        }\n        \n        // 合并 url\n        URL url = mergeUrl(providerUrl);\n\n        String key = url.toFullString();\n        if (keys.contains(key)) {\n            // 忽略重复 url\n            continue;\n        }\n        keys.add(key);\n        // 本地 Invoker 缓存列表\n        Map<String, Invoker<T>> localUrlInvokerMap = this.urlInvokerMap;\n        Invoker<T> invoker = localUrlInvokerMap == null ? null : localUrlInvokerMap.get(key);\n        // 缓存未命中\n        if (invoker == null) {\n            try {\n                boolean enabled = true;\n                if (url.hasParameter(Constants.DISABLED_KEY)) {\n                    // 获取 disable 配置，并修改 enable 变量\n                    enabled = !url.getParameter(Constants.DISABLED_KEY, false);\n                } else {\n                    enabled = url.getParameter(Constants.ENABLED_KEY, true);\n                }\n                if (enabled) {\n                    // 调用 refer 获取 Invoker\n                    invoker = new InvokerDelegate<T>(protocol.refer(serviceType, url), url, providerUrl);\n                }\n            } catch (Throwable t) {\n                logger.error("Failed to refer invoker for interface...");\n            }\n            if (invoker != null) {\n                // 缓存 Invoker 实例\n                newUrlInvokerMap.put(key, invoker);\n            }\n        } else {\n            // 缓存命中，将 invoker 存储到 newUrlInvokerMap 中\n            newUrlInvokerMap.put(key, invoker);\n        }\n    }\n    keys.clear();\n    return newUrlInvokerMap;\n}\n')])])]),e("p",[r._v("toInvokers 方法一开始会对服务提供者 url 进行检测，若服务消费端的配置不支持服务端的协议，或服务端 url 协议头为 empty 时，toInvokers 均会忽略服务提供方 url。必要的检测做完后，紧接着是合并 url，然后访问缓存，尝试获取与 url 对应的 invoker。如果缓存命中，直接将 Invoker 存入 newUrlInvokerMap 中即可。如果未命中，则需要新建 Invoker。Invoker 是通过 Protocol 的 refer 方法创建的，这个我在"),e("a",{attrs:{href:"http://www.tianxiaobo.com/2018/11/12/Dubbo-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%9C%8D%E5%8A%A1%E5%BC%95%E7%94%A8/",target:"_blank",rel:"noopener noreferrer"}},[r._v("上一篇"),e("OutboundLink")],1),r._v("文章中已经分析过了，这里就不赘述了。")]),r._v(" "),e("p",[r._v("toInvokers 方法返回的是 <url, Invoker> 映射关系表，接下来还要对这个结果进行进一步处理，得到方法名到 Invoker 列表的映射关系。这个过程由 toMethodInvokers 方法完成，如下：")]),r._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[r._v("private Map<String, List<Invoker<T>>> toMethodInvokers(Map<String, Invoker<T>> invokersMap) {\n    // 方法名 -> Invoker 列表\n    Map<String, List<Invoker<T>>> newMethodInvokerMap = new HashMap<String, List<Invoker<T>>>();\n    List<Invoker<T>> invokersList = new ArrayList<Invoker<T>>();\n    if (invokersMap != null && invokersMap.size() > 0) {\n        for (Invoker<T> invoker : invokersMap.values()) {\n            // 获取 methods 参数\n            String parameter = invoker.getUrl().getParameter(Constants.METHODS_KEY);\n            if (parameter != null && parameter.length() > 0) {\n                // 切分 methods 参数值，得到方法名数组\n                String[] methods = Constants.COMMA_SPLIT_PATTERN.split(parameter);\n                if (methods != null && methods.length > 0) {\n                    for (String method : methods) {\n                        // 方法名不为 *\n                        if (method != null && method.length() > 0\n                                && !Constants.ANY_VALUE.equals(method)) {\n                            // 根据方法名获取 Invoker 列表\n                            List<Invoker<T>> methodInvokers = newMethodInvokerMap.get(method);\n                            if (methodInvokers == null) {\n                                methodInvokers = new ArrayList<Invoker<T>>();\n                                newMethodInvokerMap.put(method, methodInvokers);\n                            }\n                            // 存储 Invoker 到列表中\n                            methodInvokers.add(invoker);\n                        }\n                    }\n                }\n            }\n            invokersList.add(invoker);\n        }\n    }\n    \n    // 进行服务级别路由，参考：https://github.com/apache/incubator-dubbo/pull/749\n    List<Invoker<T>> newInvokersList = route(invokersList, null);\n    // 存储 <*, newInvokersList> 映射关系\n    newMethodInvokerMap.put(Constants.ANY_VALUE, newInvokersList);\n    if (serviceMethods != null && serviceMethods.length > 0) {\n        for (String method : serviceMethods) {\n            List<Invoker<T>> methodInvokers = newMethodInvokerMap.get(method);\n            if (methodInvokers == null || methodInvokers.isEmpty()) {\n                methodInvokers = newInvokersList;\n            }\n            // 进行方法级别路由\n            newMethodInvokerMap.put(method, route(methodInvokers, method));\n        }\n    }\n    // 排序，转成不可变列表\n    for (String method : new HashSet<String>(newMethodInvokerMap.keySet())) {\n        List<Invoker<T>> methodInvokers = newMethodInvokerMap.get(method);\n        Collections.sort(methodInvokers, InvokerComparator.getComparator());\n        newMethodInvokerMap.put(method, Collections.unmodifiableList(methodInvokers));\n    }\n    return Collections.unmodifiableMap(newMethodInvokerMap);\n}\n")])])]),e("p",[r._v("上面方法主要做了三件事情， 第一是对入参进行遍历，然后获取 methods 参数，并切分成数组。随后以方法名为键，Invoker 列表为值，将映射关系存储到 newMethodInvokerMap 中。第二是分别基于类和方法对 Invoker 列表进行路由操作。第三是对 Invoker 列表进行排序，并转成不可变列表。关于 toMethodInvokers 方法就先分析到这，我们继续向下分析，这次要分析的多组服务的合并逻辑。")]),r._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[r._v('private Map<String, List<Invoker<T>>> toMergeMethodInvokerMap(Map<String, List<Invoker<T>>> methodMap) {\n    Map<String, List<Invoker<T>>> result = new HashMap<String, List<Invoker<T>>>();\n    // 遍历入参\n    for (Map.Entry<String, List<Invoker<T>>> entry : methodMap.entrySet()) {\n        String method = entry.getKey();\n        List<Invoker<T>> invokers = entry.getValue();\n        // group -> Invoker 列表\n        Map<String, List<Invoker<T>>> groupMap = new HashMap<String, List<Invoker<T>>>();\n        // 遍历 Invoker 列表\n        for (Invoker<T> invoker : invokers) {\n            // 获取分组配置\n            String group = invoker.getUrl().getParameter(Constants.GROUP_KEY, "");\n            List<Invoker<T>> groupInvokers = groupMap.get(group);\n            if (groupInvokers == null) {\n                groupInvokers = new ArrayList<Invoker<T>>();\n                // 缓存 <group, List<Invoker>> 到 groupMap 中\n                groupMap.put(group, groupInvokers);\n            }\n            // 存储 invoker 到 groupInvokers\n            groupInvokers.add(invoker);\n        }\n        if (groupMap.size() == 1) {\n            // 如果 groupMap 中仅包含一组键值对，此时直接取出该键值对的值即可\n            result.put(method, groupMap.values().iterator().next());\n        \n        // groupMap 中包含多组键值对，比如：\n        // {\n        //     "dubbo": [invoker1, invoker2, invoker3, ...],\n        //     "hello": [invoker4, invoker5, invoker6, ...]\n        // }\n        } else if (groupMap.size() > 1) {\n            List<Invoker<T>> groupInvokers = new ArrayList<Invoker<T>>();\n            for (List<Invoker<T>> groupList : groupMap.values()) {\n                // 通过集群类合并每个分组对应的 Invoker 列表\n                groupInvokers.add(cluster.join(new StaticDirectory<T>(groupList)));\n            }\n            // 缓存结果\n            result.put(method, groupInvokers);\n        } else {\n            result.put(method, invokers);\n        }\n    }\n    return result;\n}\n')])])]),e("p",[r._v("上面方法首先是生成 group 到 Invoker 类比的映射关系表，若关系表中的映射关系数量大于1，表示有多组服务。此时通过集群类合并每组 Invoker，并将合并结果存储到 groupInvokers 中。之后将方法名与 groupInvokers 存到到 result 中，并返回，整个逻辑结束。")]),r._v(" "),e("p",[r._v("接下来我们再来看一下 Invoker 列表刷新逻辑的最后一个动作 – 删除无用 Invoker。如下：")]),r._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[r._v('private void destroyUnusedInvokers(Map<String, Invoker<T>> oldUrlInvokerMap, Map<String, Invoker<T>> newUrlInvokerMap) {\n    if (newUrlInvokerMap == null || newUrlInvokerMap.size() == 0) {\n        destroyAllInvokers();\n        return;\n    }\n   \n    List<String> deleted = null;\n    if (oldUrlInvokerMap != null) {\n        // 获取新生成的 Invoker 列表\n        Collection<Invoker<T>> newInvokers = newUrlInvokerMap.values();\n        // 遍历老的 <url, Invoker> 映射表\n        for (Map.Entry<String, Invoker<T>> entry : oldUrlInvokerMap.entrySet()) {\n            // 检测 newInvokers 中是否包含老的 Invoker\n            if (!newInvokers.contains(entry.getValue())) {\n                if (deleted == null) {\n                    deleted = new ArrayList<String>();\n                }\n                // 若不包含，则将老的 Invoker 对应的 url 存入 deleted 列表中\n                deleted.add(entry.getKey());\n            }\n        }\n    }\n\n    if (deleted != null) {\n        // 遍历 deleted 集合，并到老的 <url, Invoker> 映射关系表查出 Invoker，销毁之\n        for (String url : deleted) {\n            if (url != null) {\n                // 从 oldUrlInvokerMap 中移除 url 对应的 Invoker\n                Invoker<T> invoker = oldUrlInvokerMap.remove(url);\n                if (invoker != null) {\n                    try {\n                        // 销毁 Invoker\n                        invoker.destroy();\n                    } catch (Exception e) {\n                        logger.warn("destroy invoker...");\n                    }\n                }\n            }\n        }\n    }\n}\n')])])]),e("p",[r._v("destroyUnusedInvokers 方法的主要逻辑是通过 newUrlInvokerMap 找出待删除 Invoker 对应的 url，并将 url 存入到 deleted 列表中。然后再遍历 deleted 列表，并从 oldUrlInvokerMap 中移除相应的 Invoker，销毁之。整个逻辑大致如此，不是很难理解。")]),r._v(" "),e("p",[r._v("到此关于 Invoker 列表的刷新逻辑就分析了，这里对整个过程进行简单总结。如下：")]),r._v(" "),e("ol",[e("li",[r._v("检测入参是否仅包含一个 url，且 url 协议头为 empty")]),r._v(" "),e("li",[r._v("若第一步检测结果为 true，表示禁用所有服务，此时销毁所有的 Invoker")]),r._v(" "),e("li",[r._v("若第一步检测结果为 false，此时将入参转为 Invoker 列表")]),r._v(" "),e("li",[r._v("对将上一步逻辑生成的结果进行进一步处理，得到方法名到 Invoker 的映射关系表")]),r._v(" "),e("li",[r._v("合并多组 Invoker")]),r._v(" "),e("li",[r._v("销毁无用 Invoker")])]),r._v(" "),e("p",[r._v("Invoker 的刷新逻辑还是比较复杂的，大家在看的过程中多写点 demo 进行调试。好了，本节就到这。")])])}),[],!1,null,null,null);n.default=t.exports}}]);