(window.webpackJsonp=window.webpackJsonp||[]).push([[102],{519:function(e,n,a){"use strict";a.r(n);var t=a(30),r=Object(t.a)({},(function(){var e=this,n=e.$createElement,a=e._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"spring-ioc-容器源码分析-填充属性到-bean-原始对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spring-ioc-容器源码分析-填充属性到-bean-原始对象"}},[e._v("#")]),e._v(" Spring IOC 容器源码分析 - 填充属性到 bean 原始对象")]),e._v(" "),a("h2",{attrs:{id:"_1-简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-简介"}},[e._v("#")]),e._v(" 1. 简介")]),e._v(" "),a("p",[e._v("本篇文章，我们来一起了解一下 Spring 是如何将配置文件中的属性值填充到 bean 对象中的。我在前面几篇文章中介绍过 Spring 创建 bean 的流程，即 Spring 先通过反射创建一个原始的 bean 对象，然后再向这个原始的 bean 对象中填充属性。对于填充属性这个过程，简单点来说，JavaBean 的每个属性通常都有 getter/setter 方法，我们可以直接调用 setter 方法将属性值设置进去。当然，这样做还是太简单了，填充属性的过程中还有许多事情要做。比如在 Spring 配置中，所有属性值都是以字符串的形式进行配置的，我们在将这些属性值赋值给对象的成员变量时，要根据变量类型进行相应的类型转换。对于一些集合类的配置，比如、和，还要将这些配置转换成相应的集合对象才能进行后续的操作。除此之外，如果用户配置了自动注入（autowire = byName/byType），Spring 还要去为自动注入的属性寻找合适的注入项。由此可以见，属性填充的整个过程还是很复杂的，并非是简单调用 setter 方法设置属性值即可。")]),e._v(" "),a("p",[e._v("关于属性填充的一些知识，本章先介绍这里。接下来，我们深入到源码中，从源码中了解属性填充的整个过程。")]),e._v(" "),a("h2",{attrs:{id:"_2-源码分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-源码分析"}},[e._v("#")]),e._v(" 2. 源码分析")]),e._v(" "),a("h3",{attrs:{id:"_2-1-populatebean-源码一览"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-populatebean-源码一览"}},[e._v("#")]),e._v(" 2.1 populateBean 源码一览")]),e._v(" "),a("p",[e._v("本节，我们先来看一下填充属性的方法，即 populateBean。该方法并不复杂，但它所调用的一些方法比较复杂。不过好在我们这里只需要知道这些方法都有什么用就行了，暂时不用纠结细节。好了，下面看源码吧。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('protected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) {\n    // 获取属性列表\n    PropertyValues pvs = mbd.getPropertyValues();\n\n    if (bw == null) {\n        if (!pvs.isEmpty()) {\n            throw new BeanCreationException(\n                    mbd.getResourceDescription(), beanName, "Cannot apply property values to null instance");\n        }\n        else {\n            return;\n        }\n    }\n\n    boolean continueWithPropertyPopulation = true;\n    /*\n     * 在属性被填充前，给 InstantiationAwareBeanPostProcessor 类型的后置处理器一个修改 \n     * bean 状态的机会。关于这段后置引用，官方的解释是：让用户可以自定义属性注入。比如用户实现一\n     * 个 InstantiationAwareBeanPostProcessor 类型的后置处理器，并通过 \n     * postProcessAfterInstantiation 方法向 bean 的成员变量注入自定义的信息。当然，如果无\n     * 特殊需求，直接使用配置中的信息注入即可。另外，Spring 并不建议大家直接实现 \n     * InstantiationAwareBeanPostProcessor 接口，如果想实现这种类型的后置处理器，更建议\n     * 通过继承 InstantiationAwareBeanPostProcessorAdapter 抽象类实现自定义后置处理器。\n     */\n    if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n        for (BeanPostProcessor bp : getBeanPostProcessors()) {\n            if (bp instanceof InstantiationAwareBeanPostProcessor) {\n                InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\n                if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {\n                    continueWithPropertyPopulation = false;\n                    break;\n                }\n            }\n        }\n    }\n\n    /* \n     * 如果上面设置 continueWithPropertyPopulation = false，表明用户可能已经自己填充了\n     * bean 的属性，不需要 Spring 帮忙填充了。此时直接返回即可\n     */\n    if (!continueWithPropertyPopulation) {\n        return;\n    }\n\n    // 根据名称或类型注入依赖\n    if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||\n            mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {\n        MutablePropertyValues newPvs = new MutablePropertyValues(pvs);\n\n        // 通过属性名称注入依赖\n        if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) {\n            autowireByName(beanName, mbd, bw, newPvs);\n        }\n\n        // 通过属性类型注入依赖\n        if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {\n            autowireByType(beanName, mbd, bw, newPvs);\n        }\n\n        pvs = newPvs;\n    }\n\n    boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();\n    boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);\n\n    /*\n     * 这里又是一种后置处理，用于在 Spring 填充属性到 bean 对象前，对属性的值进行相应的处理，\n     * 比如可以修改某些属性的值。这时注入到 bean 中的值就不是配置文件中的内容了，\n     * 而是经过后置处理器修改后的内容\n     */ \n    if (hasInstAwareBpps || needsDepCheck) {\n        PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);\n        if (hasInstAwareBpps) {\n            for (BeanPostProcessor bp : getBeanPostProcessors()) {\n                if (bp instanceof InstantiationAwareBeanPostProcessor) {\n                    InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\n                    // 对属性进行后置处理\n                    pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);\n                    if (pvs == null) {\n                        return;\n                    }\n                }\n            }\n        }\n        if (needsDepCheck) {\n            checkDependencies(beanName, mbd, filteredPds, pvs);\n        }\n    }\n\n    // 应用属性值到 bean 对象中\n    applyPropertyValues(beanName, mbd, bw, pvs);\n}\n')])])]),a("p",[e._v("上面的源码注释的比较详细了，下面我们来总结一下这个方法的执行流程。如下：")]),e._v(" "),a("ol",[a("li",[e._v("获取属性列表 pvs")]),e._v(" "),a("li",[e._v("在属性被填充到 bean 前，应用后置处理自定义属性填充")]),e._v(" "),a("li",[e._v("根据名称或类型解析相关依赖")]),e._v(" "),a("li",[e._v("再次应用后置处理，用于动态修改属性列表 pvs 的内容")]),e._v(" "),a("li",[e._v("将属性应用到 bean 对象中")])]),e._v(" "),a("p",[e._v("注意第3步，也就是根据名称或类型解析相关依赖（autowire）。该逻辑只会解析依赖，并不会将解析出的依赖立即注入到 bean 对象中。所有的属性值是在 applyPropertyValues 方法中统一被注入到 bean 对象中的。")]),e._v(" "),a("p",[e._v("在下面的章节中，我将会对 populateBean 方法中比较重要的几个方法调用进行分析，也就是第3步和第5步中的三个方法。好了，本节先到这里。")]),e._v(" "),a("h3",{attrs:{id:"_2-2-autowirebyname-方法分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-autowirebyname-方法分析"}},[e._v("#")]),e._v(" 2.2 autowireByName 方法分析")]),e._v(" "),a("p",[e._v("本节来分析一下 autowireByName 方法的代码，其实这个方法根据方法名，大家应该知道它有什么用了。所以我也就不啰嗦了，咱们直奔主题，直接分析源码：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('protected void autowireByName(\n        String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) {\n\n    /*\n     * 获取非简单类型属性的名称，且该属性未被配置在配置文件中。这里从反面解释一下什么是"非简单类型"\n     * 属性，我们先来看看 Spring 认为的"简单类型"属性有哪些，如下：\n     *   1. CharSequence 接口的实现类，比如 String\n     *   2. Enum\n     *   3. Date\n     *   4. URI/URL\n     *   5. Number 的继承类，比如 Integer/Long\n     *   6. byte/short/int... 等基本类型\n     *   7. Locale\n     *   8. 以上所有类型的数组形式，比如 String[]、Date[]、int[] 等等\n     * \n     * 除了要求非简单类型的属性外，还要求属性未在配置文件中配置过，也就是 pvs.contains(pd.getName()) = false。\n     */\n    String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);\n    for (String propertyName : propertyNames) {\n        // 检测是否存在与 propertyName 相关的 bean 或 BeanDefinition。若存在，则调用 BeanFactory.getBean 方法获取 bean 实例\n        if (containsBean(propertyName)) {\n            // 从容器中获取相应的 bean 实例\n            Object bean = getBean(propertyName);\n            // 将解析出的 bean 存入到属性值列表（pvs）中\n            pvs.add(propertyName, bean);\n            registerDependentBean(propertyName, beanName);\n            if (logger.isDebugEnabled()) {\n                logger.debug("Added autowiring by name from bean name \'" + beanName +\n                        "\' via property \'" + propertyName + "\' to bean named \'" + propertyName + "\'");\n            }\n        }\n        else {\n            if (logger.isTraceEnabled()) {\n                logger.trace("Not autowiring property \'" + propertyName + "\' of bean \'" + beanName +\n                        "\' by name: no matching bean found");\n            }\n        }\n    }\n}\n')])])]),a("p",[e._v("autowireByName 方法的逻辑比较简单，该方法首先获取非简单类型属性的名称，然后再根据名称到容器中获取相应的 bean 实例，最后再将获取到的 bean 添加到属性列表中即可。既然这个方法比较简单，那我也就不多说了，继续下面的分析。")]),e._v(" "),a("h3",{attrs:{id:"_2-3-autowirebytype-方法分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-autowirebytype-方法分析"}},[e._v("#")]),e._v(" 2.3 autowireByType 方法分析")]),e._v(" "),a("p",[e._v("本节我们来分析一下 autowireByName 的孪生兄弟 autowireByType，相较于 autowireByName，autowireByType 则要复杂一些，复杂之处在于解析依赖的过程。不过也没关系，如果我们不过于纠结细节，我们完全可以把一些复杂的地方当做一个黑盒，我们只需要要知道这个黑盒有什么用即可。这样可以在很大程度上降低源码分析的难度。好了，其他的就不多说了，咱们来分析源码吧。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('protected void autowireByType(\n        String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) {\n\n    TypeConverter converter = getCustomTypeConverter();\n    if (converter == null) {\n        converter = bw;\n    }\n\n    Set<String> autowiredBeanNames = new LinkedHashSet<String>(4);\n    // 获取非简单类型的属性\n    String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);\n    for (String propertyName : propertyNames) {\n        try {\n            PropertyDescriptor pd = bw.getPropertyDescriptor(propertyName);\n            // 如果属性类型为 Object，则忽略，不做解析\n            if (Object.class != pd.getPropertyType()) {\n                /*\n                 * 获取 setter 方法（write method）的参数信息，比如参数在参数列表中的\n                 * 位置，参数类型，以及该参数所归属的方法等信息\n                 */\n                MethodParameter methodParam = BeanUtils.getWriteMethodParameter(pd);\n\n                // Do not allow eager init for type matching in case of a prioritized post-processor.\n                boolean eager = !PriorityOrdered.class.isAssignableFrom(bw.getWrappedClass());\n                // 创建依赖描述对象\n                DependencyDescriptor desc = new AutowireByTypeDependencyDescriptor(methodParam, eager);\n                /*\n                 * 下面的方法用于解析依赖。过程比较复杂，先把这里看成一个黑盒，我们只要知道这\n                 * 个方法可以帮我们解析出合适的依赖即可。\n                 */\n                Object autowiredArgument = resolveDependency(desc, beanName, autowiredBeanNames, converter);\n                if (autowiredArgument != null) {\n                    // 将解析出的 bean 存入到属性值列表（pvs）中\n                    pvs.add(propertyName, autowiredArgument);\n                }\n                for (String autowiredBeanName : autowiredBeanNames) {\n                    registerDependentBean(autowiredBeanName, beanName);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug("Autowiring by type from bean name \'" + beanName + "\' via property \'" +\n                                propertyName + "\' to bean named \'" + autowiredBeanName + "\'");\n                    }\n                }\n                autowiredBeanNames.clear();\n            }\n        }\n        catch (BeansException ex) {\n            throw new UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, propertyName, ex);\n        }\n    }\n}\n')])])]),a("p",[e._v("如上所示，autowireByType 的代码本身并不复杂。和 autowireByName 一样，autowireByType 首先也是获取非简单类型属性的名称。然后再根据属性名获取属性描述符，并由属性描述符获取方法参数对象 MethodParameter，随后再根据 MethodParameter 对象获取依赖描述符对象，整个过程为 "),a("code",[e._v("beanName → PropertyDescriptor → MethodParameter → DependencyDescriptor")]),e._v("。在获取到依赖描述符对象后，再根据依赖描述符解析出合适的依赖。最后将解析出的结果存入属性列表 pvs 中即可。")]),e._v(" "),a("p",[e._v("关于 autowireByType 方法中出现的几种描述符对象，大家自己去看一下他们的实现吧，我就不分析了。接下来，我们来分析一下解析依赖的方法 resolveDependency。如下：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('public Object resolveDependency(DependencyDescriptor descriptor, String requestingBeanName,\n        Set<String> autowiredBeanNames, TypeConverter typeConverter) throws BeansException {\n\n    descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());\n    if (javaUtilOptionalClass == descriptor.getDependencyType()) {\n        return new OptionalDependencyFactory().createOptionalDependency(descriptor, requestingBeanName);\n    }\n    else if (ObjectFactory.class == descriptor.getDependencyType() ||\n            ObjectProvider.class == descriptor.getDependencyType()) {\n        return new DependencyObjectProvider(descriptor, requestingBeanName);\n    }\n    else if (javaxInjectProviderClass == descriptor.getDependencyType()) {\n        return new Jsr330ProviderFactory().createDependencyProvider(descriptor, requestingBeanName);\n    }\n    else {\n        Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(\n                descriptor, requestingBeanName);\n        if (result == null) {\n            // 解析依赖\n            result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);\n        }\n        return result;\n    }\n}\n\npublic Object doResolveDependency(DependencyDescriptor descriptor, String beanName,\n        Set<String> autowiredBeanNames, TypeConverter typeConverter) throws BeansException {\n\n    InjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);\n    try {\n        // 该方法最终调用了 beanFactory.getBean(String, Class)，从容器中获取依赖\n        Object shortcut = descriptor.resolveShortcut(this);\n        // 如果容器中存在所需依赖，这里进行断路操作，提前结束依赖解析逻辑\n        if (shortcut != null) {\n            return shortcut;\n        }\n\n        Class<?> type = descriptor.getDependencyType();\n        // 处理 @value 注解\n        Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);\n        if (value != null) {\n            if (value instanceof String) {\n                String strVal = resolveEmbeddedValue((String) value);\n                BeanDefinition bd = (beanName != null && containsBean(beanName) ? getMergedBeanDefinition(beanName) : null);\n                value = evaluateBeanDefinitionString(strVal, bd);\n            }\n            TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());\n            return (descriptor.getField() != null ?\n                    converter.convertIfNecessary(value, type, descriptor.getField()) :\n                    converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));\n        }\n\n        // 解析数组、list、map 等类型的依赖\n        Object multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);\n        if (multipleBeans != null) {\n            return multipleBeans;\n        }\n\n        /*\n         * 按类型查找候选列表，如果某个类型已经被实例化，则返回相应的实例。\n         * 比如下面的配置：\n         *\n         *   <bean name="mongoDao" class="xyz.coolblog.autowire.MongoDao" primary="true"/>\n         *   <bean name="service" class="xyz.coolblog.autowire.Service" autowire="byType"/>\n         *   <bean name="mysqlDao" class="xyz.coolblog.autowire.MySqlDao"/>\n         *\n         * MongoDao 和 MySqlDao 均实现自 Dao 接口，Service 对象（不是接口）中有一个 Dao \n         * 类型的属性。现在根据类型自动注入 Dao 的实现类。这里有两个候选 bean，一个是 \n         * mongoDao，另一个是 mysqlDao，其中 mongoDao 在 service 之前实例化，\n         * mysqlDao 在 service 之后实例化。此时 findAutowireCandidates 方法会返回如下的结果：\n         *\n         *   matchingBeans = [ <mongoDao, Object@MongoDao>, <mysqlDao, Class@MySqlDao> ]\n         *\n         * 注意 mysqlDao 还未实例化，所以返回的是 MySqlDao.class。\n         * \n         * findAutowireCandidates 这个方法逻辑比较复杂，我简单说一下它的工作流程吧，如下：\n         *   1. 从 BeanFactory 中获取某种类型 bean 的名称，比如上面的配置中 \n         *      mongoDao 和 mysqlDao 均实现了 Dao 接口，所以他们是同一种类型的 bean。\n         *   2. 遍历上一步得到的名称列表，并判断 bean 名称对应的 bean 是否是合适的候选项，\n         *      若合适则添加到候选列表中，并在最后返回候选列表\n         *      \n         * findAutowireCandidates 比较复杂，我并未完全搞懂，就不深入分析了。见谅\n         */\n        Map<String, Object> matchingBeans = findAutowireCandidates(beanName, type, descriptor);\n        if (matchingBeans.isEmpty()) {\n            if (isRequired(descriptor)) {\n                // 抛出 NoSuchBeanDefinitionException 异常\n                raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);\n            }\n            return null;\n        }\n\n        String autowiredBeanName;\n        Object instanceCandidate;\n\n        if (matchingBeans.size() > 1) {\n            /*\n             * matchingBeans.size() > 1，则表明存在多个可注入的候选项，这里判断使用哪一个\n             * 候选项。比如下面的配置：\n             *\n             *   <bean name="mongoDao" class="xyz.coolblog.autowire.MongoDao" primary="true"/>\n             *   <bean name="mysqlDao" class="xyz.coolblog.autowire.MySqlDao"/>\n             *\n             * mongoDao 的配置中存在 primary 属性，所以 mongoDao 会被选为最终的候选项。如\n             * 果两个 bean 配置都没有 primary 属性，则需要根据优先级选择候选项。优先级这一块\n             * 的逻辑没细看，不多说了。\n             */\n            autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);\n            if (autowiredBeanName == null) {\n                if (isRequired(descriptor) || !indicatesMultipleBeans(type)) {\n                    // 抛出 NoUniqueBeanDefinitionException 异常\n                    return descriptor.resolveNotUnique(type, matchingBeans);\n                }\n                else {\n                    return null;\n                }\n            }\n            // 根据解析出的 autowiredBeanName，获取相应的候选项\n            instanceCandidate = matchingBeans.get(autowiredBeanName);\n        }\n        else { // 只有一个候选项，直接取出来即可\n            Map.Entry<String, Object> entry = matchingBeans.entrySet().iterator().next();\n            autowiredBeanName = entry.getKey();\n            instanceCandidate = entry.getValue();\n        }\n\n        if (autowiredBeanNames != null) {\n            autowiredBeanNames.add(autowiredBeanName);\n        }\n\n        // 返回候选项实例，如果实例是 Class 类型，则调用 beanFactory.getBean(String, Class) 获取相应的 bean。否则直接返回即可\n        return (instanceCandidate instanceof Class ?\n                descriptor.resolveCandidate(autowiredBeanName, type, this) : instanceCandidate);\n    }\n    finally {\n        ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);\n    }\n}\n')])])]),a("p",[e._v("由上面的代码可以看出，doResolveDependency 这个方法还是挺复杂的。这里我就不继续分析 doResolveDependency 所调用的方法了，对于这些方法，我也是似懂非懂。好了，本节的最后我们来总结一下 doResolveDependency 的执行流程吧，如下：")]),e._v(" "),a("ol",[a("li",[e._v("首先将 beanName 和 requiredType 作为参数，并尝试从 BeanFactory 中获取与此对于的 bean。若获取成功，就可以提前结束 doResolveDependency 的逻辑。")]),e._v(" "),a("li",[e._v("处理 @value 注解")]),e._v(" "),a("li",[e._v("解析数组、List、Map 等类型的依赖，如果解析结果不为空，则返回结果")]),e._v(" "),a("li",[e._v("根据类型查找合适的候选项")]),e._v(" "),a("li",[e._v("如果候选项的数量为0，则抛出异常。为1，直接从候选列表中取出即可。若候选项数量 > 1，则在多个候选项中确定最优候选项，若无法确定则抛出异常")]),e._v(" "),a("li",[e._v("若候选项是 Class 类型，表明候选项还没实例化，此时通过 BeanFactory.getBean 方法对其进行实例化。若候选项是非 Class 类型，则表明已经完成了实例化，此时直接返回即可。")])]),e._v(" "),a("p",[e._v("好了，本节的内容先到这里。如果有分析错的地方，欢迎大家指出来。")]),e._v(" "),a("h3",{attrs:{id:"_2-4-applypropertyvalues-方法分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-applypropertyvalues-方法分析"}},[e._v("#")]),e._v(" 2.4 applyPropertyValues 方法分析")]),e._v(" "),a("p",[e._v("经过了上面的流程，现在终于可以将属性值注入到 bean 对象中了。当然，这里还不能立即将属性值注入到对象中，因为在 Spring 配置文件中属性值都是以 String 类型进行配置的，所以 Spring 框架需要对 String 类型进行转换。除此之外，对于 ref 属性，这里还需要根据 ref 属性值解析依赖。还有一些其他操作，这里就不多说了，更多的信息我们一起在源码探寻。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('protected void applyPropertyValues(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs) {\n    if (pvs == null || pvs.isEmpty()) {\n        return;\n    }\n\n    if (System.getSecurityManager() != null && bw instanceof BeanWrapperImpl) {\n        ((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());\n    }\n\n    MutablePropertyValues mpvs = null;\n    List<PropertyValue> original;\n\n    if (pvs instanceof MutablePropertyValues) {\n        mpvs = (MutablePropertyValues) pvs;\n        // 如果属性列表 pvs 被转换过，则直接返回即可\n        if (mpvs.isConverted()) {\n            try {\n                bw.setPropertyValues(mpvs);\n                return;\n            }\n            catch (BeansException ex) {\n                throw new BeanCreationException(\n                        mbd.getResourceDescription(), beanName, "Error setting property values", ex);\n            }\n        }\n        original = mpvs.getPropertyValueList();\n    }\n    else {\n        original = Arrays.asList(pvs.getPropertyValues());\n    }\n\n    TypeConverter converter = getCustomTypeConverter();\n    if (converter == null) {\n        converter = bw;\n    }\n    BeanDefinitionValueResolver valueResolver = new BeanDefinitionValueResolver(this, beanName, mbd, converter);\n\n    List<PropertyValue> deepCopy = new ArrayList<PropertyValue>(original.size());\n    boolean resolveNecessary = false;\n    // 遍历属性列表\n    for (PropertyValue pv : original) {\n        // 如果属性值被转换过，则就不需要再次转换\n        if (pv.isConverted()) {\n            deepCopy.add(pv);\n        }\n        else {\n            String propertyName = pv.getName();\n            Object originalValue = pv.getValue();\n            /*\n             * 解析属性值。举例说明，先看下面的配置：\n             * \n             *   <bean id="macbook" class="MacBookPro">\n             *       <property name="manufacturer" value="Apple"/>\n             *       <property name="width" value="280"/>\n             *       <property name="cpu" ref="cpu"/>\n             *       <property name="interface">\n             *           <list>\n             *               <value>USB</value>\n             *               <value>HDMI</value>\n             *               <value>Thunderbolt</value>\n             *           </list>\n             *       </property>\n             *   </bean>\n             *\n             * 上面是一款电脑的配置信息，每个 property 配置经过下面的方法解析后，返回如下结果：\n             *   propertyName = "manufacturer", resolvedValue = "Apple"\n             *   propertyName = "width", resolvedValue = "280"\n             *   propertyName = "cpu", resolvedValue = "CPU@1234"  注：resolvedValue 是一个对象\n             *   propertyName = "interface", resolvedValue = ["USB", "HDMI", "Thunderbolt"]\n             *\n             * 如上所示，resolveValueIfNecessary 会将 ref 解析为具体的对象，将 <list> \n             * 标签转换为 List 对象等。对于 int 类型的配置，这里并未做转换，所以 \n             * width = "280"，还是字符串。除了解析上面几种类型，该方法还会解析 <set/>、\n             * <map/>、<array/> 等集合配置\n             */\n            Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);\n            Object convertedValue = resolvedValue;\n\n            /*\n             * convertible 表示属性值是否可转换，由两个条件合成而来。第一个条件不难理解，解释\n             * 一下第二个条件。第二个条件用于检测 propertyName 是否是 nested 或者 indexed，\n             * 直接举例说明吧：\n             * \n             *   public class Room {\n             *       private Door door = new Door();\n             *   }\n             *\n             * room 对象里面包含了 door 对象，如果我们想向 door 对象中注入属性值，则可以这样配置：\n             *\n             *   <bean id="room" class="xyz.coolblog.Room">\n             *      <property name="door.width" value="123"/>\n             *   </bean>\n             * \n             * isNestedOrIndexedProperty 会根据 propertyName 中是否包含 . 或 [  返回 \n             * true 和 false。包含则返回 true，否则返回 false。关于 nested 类型的属性，我\n             * 没在实践中用过，所以不知道上面举的例子是不是合理。若不合理，欢迎指正，也请多多指教。\n             * 关于 nested 类型的属性，大家还可以参考 Spring 的官方文档：\n             *     https://docs.spring.io/spring/docs/4.3.17.RELEASE/spring-framework-reference/htmlsingle/#beans-beans-conventions\n             */\n            boolean convertible = bw.isWritableProperty(propertyName) &&\n                    !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);\n            // 对于一般的属性，convertible 通常为 true\n            if (convertible) {\n                // 对属性值的类型进行转换，比如将 String 类型的属性值 "123" 转为 Integer 类型的 123\n                convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);\n            }\n\n            /*\n             * 如果 originalValue 是通过 autowireByType 或 autowireByName 解析而来，\n             * 那么此处条件成立，即 (resolvedValue == originalValue) = true\n             */\n            if (resolvedValue == originalValue) {\n                if (convertible) {\n                    // 将 convertedValue 设置到 pv 中，后续再次创建同一个 bean 时，就无需再次进行转换了\n                    pv.setConvertedValue(convertedValue);\n                }\n                deepCopy.add(pv);\n            }\n            /*\n             * 如果原始值 originalValue 是 TypedStringValue，且转换后的值 \n             * convertedValue 不是 Collection 或数组类型，则将转换后的值存入到 pv 中。\n             */\n            else if (convertible && originalValue instanceof TypedStringValue &&\n                    !((TypedStringValue) originalValue).isDynamic() &&\n                    !(convertedValue instanceof Collection || ObjectUtils.isArray(convertedValue))) {\n                pv.setConvertedValue(convertedValue);\n                deepCopy.add(pv);\n            }\n            else {\n                resolveNecessary = true;\n                deepCopy.add(new PropertyValue(pv, convertedValue));\n            }\n        }\n    }\n    if (mpvs != null && !resolveNecessary) {\n        mpvs.setConverted();\n    }\n\n    try {\n        // 将所有的属性值设置到 bean 实例中\n        bw.setPropertyValues(new MutablePropertyValues(deepCopy));\n    }\n    catch (BeansException ex) {\n        throw new BeanCreationException(\n                mbd.getResourceDescription(), beanName, "Error setting property values", ex);\n    }\n}\n')])])]),a("p",[e._v("以上就是 applyPropertyValues 方法的源码，配合着我写的注释，应该可以理解这个方法的流程。这个方法也调用了很多其他的方法，如果大家跟下去的话，会发现这些方法的调用栈也是很深的，比较复杂。这里说一下 bw.setPropertyValues 这个方法，如果大家跟到这个方法的调用栈的最底部，会发现这个方法是通过调用对象的 setter 方法进行属性设置的。这里贴一下简化后的代码：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public class BeanWrapperImpl extends AbstractNestablePropertyAccessor implements BeanWrapper {\n\n    // 省略部分代码\n\n    private class BeanPropertyHandler extends PropertyHandler {\n        @Override\n        public void setValue(final Object object, Object valueToApply) throws Exception {\n            // 获取 writeMethod，也就是 setter 方法\n            final Method writeMethod = this.pd.getWriteMethod();\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) && !writeMethod.isAccessible()) {\n                writeMethod.setAccessible(true);\n            }\n            final Object value = valueToApply;\n            // 调用 setter 方法，getWrappedInstance() 返回的是 bean 对象\n            writeMethod.invoke(getWrappedInstance(), value);\n        }\n    }\n}\n")])])]),a("p",[e._v("好了，本节的最后来总结一下 applyPropertyValues 方法的执行流程吧，如下：")]),e._v(" "),a("ol",[a("li",[e._v("检测属性值列表是否已转换过的，若转换过，则直接填充属性，无需再次转换")]),e._v(" "),a("li",[e._v("遍历属性值列表 pvs，解析原始值 originalValue，得到解析值 resolvedValue")]),e._v(" "),a("li",[e._v("对解析后的属性值 resolvedValue 进行类型转换")]),e._v(" "),a("li",[e._v("将类型转换后的属性值设置到 PropertyValue 对象中，并将 PropertyValue 对象存入 deepCopy 集合中")]),e._v(" "),a("li",[e._v("将 deepCopy 中的属性信息注入到 bean 对象中")])])])}),[],!1,null,null,null);n.default=r.exports}}]);