(window.webpackJsonp=window.webpackJsonp||[]).push([[165],{580:function(e,r,a){"use strict";a.r(r);var t=a(30),s=Object(t.a)({},(function(){var e=this,r=e.$createElement,a=e._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"java-spi机制详解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java-spi机制详解"}},[e._v("#")]),e._v(" Java SPI机制详解")]),e._v(" "),a("h2",{attrs:{id:"什么是spi"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是spi"}},[e._v("#")]),e._v(" 什么是SPI？")]),e._v(" "),a("p",[e._v("SPI 全称为 (Service Provider Interface) ，是JDK内置的一种服务提供发现机制。SPI是一种动态替换发现的机制， 比如有个接口，想运行时动态的给它添加实现，你只需要添加一个实现。我们经常遇到的就是java.sql.Driver接口，其他不同厂商可以针对同一接口做出不同的实现，mysql和postgresql都有不同的实现提供给用户，而Java的SPI机制可以为某个接口寻找服务实现。")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/14/1635dec2151e31e4~tplv-t2oaga2asx-watermark.awebp",alt:"img"}})]),e._v(" "),a("p",[e._v("类图中，接口对应定义的抽象SPI接口；实现方实现SPI接口；调用方依赖SPI接口。")]),e._v(" "),a("p",[e._v("SPI接口的定义在调用方，在概念上更依赖调用方；组织上位于调用方所在的包中；实现位于独立的包中。")]),e._v(" "),a("p",[e._v("当接口属于实现方的情况，实现方提供了接口和实现，这个用法很常见，属于API调用。我们可以引用接口来达到调用某实现类的功能。")]),e._v(" "),a("h2",{attrs:{id:"java-spi-应用实例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java-spi-应用实例"}},[e._v("#")]),e._v(" Java SPI 应用实例")]),e._v(" "),a("p",[e._v("当服务的提供者提供了一种接口的实现之后，需要在classpath下的META-INF/services/目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。当其他的程序需要这个服务的时候，就可以通过查找这个jar包（一般都是以jar包做依赖）的META-INF/services/中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。JDK中查找服务实现的工具类是：java.util.ServiceLoader。")]),e._v(" "),a("h3",{attrs:{id:"spi接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spi接口"}},[e._v("#")]),e._v(" SPI接口")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public interface ObjectSerializer {\n\n    byte[] serialize(Object obj) throws ObjectSerializerException;\n\n    <T> T deSerialize(byte[] param, Class<T> clazz) throws ObjectSerializerException;\n\n    String getSchemeName();\n}\n\n")])])]),a("p",[e._v("定义了一个对象序列化接口，内有三个方法：序列化方法、反序列化方法和序列化名称。")]),e._v(" "),a("h3",{attrs:{id:"spi具体实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spi具体实现"}},[e._v("#")]),e._v(" SPI具体实现")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('public class KryoSerializer implements ObjectSerializer {\n\n    @Override\n    public byte[] serialize(Object obj) throws ObjectSerializerException {\n        byte[] bytes;\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n        try {\n            //获取kryo对象\n            Kryo kryo = new Kryo();\n            Output output = new Output(outputStream);\n            kryo.writeObject(output, obj);\n            bytes = output.toBytes();\n            output.flush();\n        } catch (Exception ex) {\n            throw new ObjectSerializerException("kryo serialize error" + ex.getMessage());\n        } finally {\n            try {\n                outputStream.flush();\n                outputStream.close();\n            } catch (IOException e) {\n\n            }\n        }\n        return bytes;\n    }\n\n    @Override\n    public <T> T deSerialize(byte[] param, Class<T> clazz) throws ObjectSerializerException {\n        T object;\n        try (ByteArrayInputStream inputStream = new ByteArrayInputStream(param)) {\n            Kryo kryo = new Kryo();\n            Input input = new Input(inputStream);\n            object = kryo.readObject(input, clazz);\n            input.close();\n        } catch (Exception e) {\n            throw new ObjectSerializerException("kryo deSerialize error" + e.getMessage());\n        }\n        return object;\n    }\n\n    @Override\n    public String getSchemeName() {\n        return "kryoSerializer";\n    }\n\n}\n\n')])])]),a("p",[e._v("使用Kryo的序列化方式。Kryo 是一个快速高效的Java对象图形序列化框架，它原生支持java，且在java的序列化上甚至优于google著名的序列化框架protobuf。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('public class JavaSerializer implements ObjectSerializer {\n    @Override\n    public byte[] serialize(Object obj) throws ObjectSerializerException {\n        ByteArrayOutputStream arrayOutputStream;\n        try {\n            arrayOutputStream = new ByteArrayOutputStream();\n            ObjectOutput objectOutput = new ObjectOutputStream(arrayOutputStream);\n            objectOutput.writeObject(obj);\n            objectOutput.flush();\n            objectOutput.close();\n        } catch (IOException e) {\n            throw new ObjectSerializerException("JAVA serialize error " + e.getMessage());\n        }\n        return arrayOutputStream.toByteArray();\n    }\n\n    @Override\n    public <T> T deSerialize(byte[] param, Class<T> clazz) throws ObjectSerializerException {\n        ByteArrayInputStream arrayInputStream = new ByteArrayInputStream(param);\n        try {\n            ObjectInput input = new ObjectInputStream(arrayInputStream);\n            return (T) input.readObject();\n        } catch (IOException | ClassNotFoundException e) {\n            throw new ObjectSerializerException("JAVA deSerialize error " + e.getMessage());\n        }\n    }\n\n    @Override\n    public String getSchemeName() {\n        return "javaSerializer";\n    }\n\n}\n\n')])])]),a("p",[e._v("Java原生的序列化方式。")]),e._v(" "),a("h3",{attrs:{id:"增加meta-inf目录文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#增加meta-inf目录文件"}},[e._v("#")]),e._v(" 增加META-INF目录文件")]),e._v(" "),a("p",[e._v("Resource下面创建META-INF/services 目录里创建一个以服务接口命名的文件")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/14/1635dec21502ba4d~tplv-t2oaga2asx-watermark.awebp",alt:"img"}})]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("com.blueskykong.javaspi.serializer.KryoSerializer\ncom.blueskykong.javaspi.serializer.JavaSerializer\n\n")])])]),a("h3",{attrs:{id:"service类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#service类"}},[e._v("#")]),e._v(" Service类")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("@Service\npublic class SerializerService {\n\n\n    public ObjectSerializer getObjectSerializer() {\n        ServiceLoader<ObjectSerializer> serializers = ServiceLoader.load(ObjectSerializer.class);\n\n        final Optional<ObjectSerializer> serializer = StreamSupport.stream(serializers.spliterator(), false)\n                .findFirst();\n\n        return serializer.orElse(new JavaSerializer());\n    }\n}\n\n")])])]),a("p",[e._v("获取定义的序列化方式，且只取第一个（我们在配置中写了两个），如果找不到则返回Java原生序列化方式。")]),e._v(" "),a("h3",{attrs:{id:"测试类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#测试类"}},[e._v("#")]),e._v(" 测试类")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('    @Autowired\n    private SerializerService serializerService;\n\n    @Test\n    public void serializerTest() throws ObjectSerializerException {\n        ObjectSerializer objectSerializer = serializerService.getObjectSerializer();\n        System.out.println(objectSerializer.getSchemeName());\n        byte[] arrays = objectSerializer.serialize(Arrays.asList("1", "2", "3"));\n        ArrayList list = objectSerializer.deSerialize(arrays, ArrayList.class);\n        Assert.assertArrayEquals(Arrays.asList("1", "2", "3").toArray(), list.toArray());\n    }\n\n')])])]),a("p",[e._v("测试用例通过，且输出"),a("code",[e._v("kryoSerializer")]),e._v("。")]),e._v(" "),a("h2",{attrs:{id:"spi的用途"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spi的用途"}},[e._v("#")]),e._v(" SPI的用途")]),e._v(" "),a("p",[e._v("数据库DriverManager、Spring、ConfigurableBeanFactory等都用到了SPI机制，这里以数据库DriverManager为例，看一下其实现的内幕。")]),e._v(" "),a("p",[e._v('DriverManager是jdbc里管理和注册不同数据库driver的工具类。针对一个数据库，可能会存在着不同的数据库驱动实现。我们在使用特定的驱动实现时，不希望修改现有的代码，而希望通过一个简单的配置就可以达到效果。 在使用mysql驱动的时候，会有一个疑问，DriverManager是怎么获得某确定驱动类的？我们在运用Class.forName("com.mysql.jdbc.Driver")加载mysql驱动后，就会执行其中的静态代码把driver注册到DriverManager中，以便后续的使用。')]),e._v(" "),a("p",[e._v("在JDBC4.0之前，连接数据库的时候，通常会用"),a("code",[e._v('Class.forName("com.mysql.jdbc.Driver")')]),e._v("这句先加载数据库相关的驱动，然后再进行获取连接等的操作。而JDBC4.0之后不需要"),a("code",[e._v("Class.forName")]),e._v("来加载驱动，直接获取连接即可，这里使用了Java的SPI扩展机制来实现。")]),e._v(" "),a("p",[e._v("在java中定义了接口java.sql.Driver，并没有具体的实现，具体的实现都是由不同厂商来提供的。")]),e._v(" "),a("h3",{attrs:{id:"mysql"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mysql"}},[e._v("#")]),e._v(" mysql")]),e._v(" "),a("p",[e._v("在mysql-connector-java-5.1.45.jar中，META-INF/services目录下会有一个名字为java.sql.Driver的文件：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("com.mysql.jdbc.Driver\ncom.mysql.fabric.jdbc.FabricMySQLDriver\n\n")])])]),a("h3",{attrs:{id:"pg"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pg"}},[e._v("#")]),e._v(" pg")]),e._v(" "),a("p",[e._v("而在postgresql-42.2.2.jar中，META-INF/services目录下会有一个名字为java.sql.Driver的文件：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("org.postgresql.Driver\n\n")])])]),a("h3",{attrs:{id:"用法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#用法"}},[e._v("#")]),e._v(" 用法")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('String url = "jdbc:mysql://localhost:3306/test";\nConnection conn = DriverManager.getConnection(url,username,password);\n\n')])])]),a("p",[e._v("上面展示的是mysql的用法，pg用法也是类似。不需要使用"),a("code",[e._v('Class.forName("com.mysql.jdbc.Driver")')]),e._v("来加载驱动。")]),e._v(" "),a("h3",{attrs:{id:"mysql-drivermanager实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mysql-drivermanager实现"}},[e._v("#")]),e._v(" Mysql DriverManager实现")]),e._v(" "),a("p",[e._v("上面代码没有了加载驱动的代码，我们怎么去确定使用哪个数据库连接的驱动呢？这里就涉及到使用Java的SPI扩展机制来查找相关驱动的东西了，关于驱动的查找其实都在DriverManager中，DriverManager是Java中的实现，用来获取数据库连接，在DriverManager中有一个静态代码块如下：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('static {\n\tloadInitialDrivers();\n\tprintln("JDBC DriverManager initialized");\n}\n\n')])])]),a("p",[e._v("可以看到其内部的静态代码块中有一个"),a("code",[e._v("loadInitialDrivers")]),e._v("方法，"),a("code",[e._v("loadInitialDrivers")]),e._v("用法用到了上文提到的spi工具类"),a("code",[e._v("ServiceLoader")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("    public Void run() {\n\n        ServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class);\n        Iterator<Driver> driversIterator = loadedDrivers.iterator();\n\n        /* Load these drivers, so that they can be instantiated.\n         * It may be the case that the driver class may not be there\n         * i.e. there may be a packaged driver with the service class\n         * as implementation of java.sql.Driver but the actual class\n         * may be missing. In that case a java.util.ServiceConfigurationError\n         * will be thrown at runtime by the VM trying to locate\n         * and load the service.\n         *\n         * Adding a try catch block to catch those runtime errors\n         * if driver not available in classpath but it's\n         * packaged as service and that service is there in classpath.\n         */\n        try{\n            while(driversIterator.hasNext()) {\n                driversIterator.next();\n            }\n        } catch(Throwable t) {\n        // Do nothing\n        }\n        return null;\n    }\n\n")])])]),a("p",[e._v("遍历使用SPI获取到的具体实现，实例化各个实现类。在遍历的时候，首先调用"),a("code",[e._v("driversIterator.hasNext()")]),e._v("方法，这里会搜索classpath下以及jar包中所有的META-INF/services目录下的java.sql.Driver文件，并找到文件中的实现类的名字，此时并没有实例化具体的实现类。")]),e._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),a("p",[e._v("SPI机制在实际开发中使用得场景也有很多。特别是统一标准的不同厂商实现，当有关组织或者公司定义标准之后，具体厂商或者框架开发者实现，之后提供给开发者使用。")]),e._v(" "),a("p",[e._v("著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。作者：aoho\n链接：https://juejin.cn/post/6844903605695152142\n来源：掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。")])])}),[],!1,null,null,null);r.default=s.exports}}]);