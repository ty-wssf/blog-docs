(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{443:function(t,n,e){"use strict";e.r(n);var a=e(30),r=Object(a.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"dubbo-源码分析-集群容错之-router"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dubbo-源码分析-集群容错之-router"}},[t._v("#")]),t._v(" Dubbo 源码分析 - 集群容错之 Router")]),t._v(" "),e("h2",{attrs:{id:"_1-简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-简介"}},[t._v("#")]),t._v(" 1. 简介")]),t._v(" "),e("p",[t._v("上一篇文章分析了集群容错的第一部分 – 服务目录 Directory。服务目录在刷新 Invoker 列表的过程中，会通过 Router 进行服务路由。上一篇文章关于服务路由相关逻辑没有细致分析，一笔带过了，本篇文章将对此进行详细的分析。首先，先来介绍一下服务目录是什么。服务路由包含一条路由规则，路由规则决定了服务消费者的调用目标，即规定了服务消费者可调用哪些服务提供者。Dubbo 目前提供了三种服务路由实现，分别为条件路由 ConditionRouter、脚本路由 ScriptRouter 和标签路由 TagRouter。其中条件路由是我们最常使用的，标签路由暂未在我所分析的 2.6.4 版本中提供，该实现会在 2.7.0 版本中提供。本篇文章将分析条件路由相关源码，脚本路由和标签路由这里就不分析了。下面进入正题。")]),t._v(" "),e("h2",{attrs:{id:"_2-源码分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-源码分析"}},[t._v("#")]),t._v(" 2. 源码分析")]),t._v(" "),e("p",[t._v("条件路由规则有两个条件组成，分别用于对服务消费者和提供者进行匹配。比如有这样一条规则：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("host = 10.20.153.10 => host = 10.20.153.11\n")])])]),e("p",[t._v("该条规则表示 IP 为 10.20.153.10 的服务消费者"),e("strong",[t._v("只可")]),t._v("调用 IP 为 10.20.153.11 机器上的服务，不可调用其他机器上的服务。条件路由规则的格式如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("[服务消费者匹配条件] => [服务提供者匹配条件]\n")])])]),e("p",[t._v("如果服务消费者匹配条件为空，表示不对服务消费者进行限制。如果服务提供者匹配条件为空，表示对某些服务消费者禁用服务。Dubbo 官方文档对条件路由进行了比较详细的介绍，大家可以参考下，这里就不过多说明了。")]),t._v(" "),e("p",[t._v("条件路由实现类 ConditionRouter 需要对用户配置的路由规则进行解析，得到一系列的条件。然后再根据这些条件对服务进行路由。本章将分两节进行说明，2.1节介绍表达式解析过程。2.2 节介绍服务路由的过程。接下来，我们先从表达式解析过程看起。")]),t._v(" "),e("h3",{attrs:{id:"_2-1-表达式解析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-表达式解析"}},[t._v("#")]),t._v(" 2.1 表达式解析")]),t._v(" "),e("p",[t._v("条件路由规则是一条字符串，对于 Dubbo 来说，它并不能直接理解字符串的意思，需要将其解析成内部格式才行。条件表达式的解析过程始于 ConditionRouter 的构造方法，下面一起看一下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('public ConditionRouter(URL url) {\n    this.url = url;\n    // 获取 priority 和 force 配置\n    this.priority = url.getParameter(Constants.PRIORITY_KEY, 0);\n    this.force = url.getParameter(Constants.FORCE_KEY, false);\n    try {\n        // 获取路由规则\n        String rule = url.getParameterAndDecoded(Constants.RULE_KEY);\n        if (rule == null || rule.trim().length() == 0) {\n            throw new IllegalArgumentException("Illegal route rule!");\n        }\n        rule = rule.replace("consumer.", "").replace("provider.", "");\n        // 定位 => 分隔符\n        int i = rule.indexOf("=>");\n        // 分别获取服务消费者和提供者匹配规则\n        String whenRule = i < 0 ? null : rule.substring(0, i).trim();\n        String thenRule = i < 0 ? rule.trim() : rule.substring(i + 2).trim();\n        // 解析服务消费者匹配规则\n        Map<String, MatchPair> when = \n            StringUtils.isBlank(whenRule) || "true".equals(whenRule) \n                ? new HashMap<String, MatchPair>() : parseRule(whenRule);\n        // 解析服务提供者匹配规则\n        Map<String, MatchPair> then = \n            StringUtils.isBlank(thenRule) || "false".equals(thenRule) \n                ? null : parseRule(thenRule);\n        this.whenCondition = when;\n        this.thenCondition = then;\n    } catch (ParseException e) {\n        throw new IllegalStateException(e.getMessage(), e);\n    }\n}\n')])])]),e("p",[t._v("如上，ConditionRouter 构造方法先是对路由规则做预处理，然后调用 parseRule 方法分别对服务提供者和消费者规则进行解析，最后将解析结果赋值给 whenCondition 和 thenCondition 成员变量。ConditionRouter 构造方法不是很复杂，这里就不多说了。下面我们把重点放在 parseRule 方法上，在详细介绍这个方法之前，我们先来看一个内部类。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("private static final class MatchPair {\n    final Set<String> matches = new HashSet<String>();\n    final Set<String> mismatches = new HashSet<String>();\n}\n")])])]),e("p",[t._v("MatchPair 内部包含了两个 Set 型的成员变量，分别用于存放匹配和不匹配的条件。这个类两个成员变量会在 parseRule 方法中被用到，下面来看一下。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('private static Map<String, MatchPair> parseRule(String rule)\n        throws ParseException {\n    // 定义条件映射集合\n    Map<String, MatchPair> condition = new HashMap<String, MatchPair>();\n    if (StringUtils.isBlank(rule)) {\n        return condition;\n    }\n    MatchPair pair = null;\n    Set<String> values = null;\n    // 通过正则表达式匹配路由规则，ROUTE_PATTERN = ([&!=,]*)\\s*([^&!=,\\s]+)\n    // 这个表达式看起来不是很好理解，第一个括号内的表达式用于匹配"&", "!", "=" 和 "," 等符号。\n    // 第二括号内的用于匹配英文字母，数字等字符。举个例子说明一下：\n    //    host = 2.2.2.2 & host != 1.1.1.1 & method = hello\n    // 匹配结果如下：\n    //     括号一      括号二\n    // 1.  null       host\n    // 2.   =         2.2.2.2\n    // 3.   &         host\n    // 4.   !=        1.1.1.1 \n    // 5.   &         method\n    // 6.   =         hello\n    final Matcher matcher = ROUTE_PATTERN.matcher(rule);\n    while (matcher.find()) {\n       \t// 获取括号一内的匹配结果\n        String separator = matcher.group(1);\n        // 获取括号二内的匹配结果\n        String content = matcher.group(2);\n        // 分隔符为空，表示匹配的是表达式的开始部分\n        if (separator == null || separator.length() == 0) {\n            // 创建 MatchPair 对象\n            pair = new MatchPair();\n            // 存储 <匹配项, MatchPair> 键值对，比如 <host, MatchPair>\n            condition.put(content, pair); \n        } \n        \n        // 如果分隔符为 &，表明接下来也是一个条件\n        else if ("&".equals(separator)) {\n            // 尝试从 condition 获取 MatchPair\n            if (condition.get(content) == null) {\n                // 未获取到 MatchPair，重新创建一个，并放入 condition 中\n                pair = new MatchPair();\n                condition.put(content, pair);\n            } else {\n                pair = condition.get(content);\n            }\n        } \n        \n        // 分隔符为 =\n        else if ("=".equals(separator)) {\n            if (pair == null)\n                throw new ParseException("Illegal route rule ...");\n\n            values = pair.matches;\n            // 将 content 存入到 MatchPair 的 matches 集合中\n            values.add(content);\n        } \n        \n        //  分隔符为 != \n        else if ("!=".equals(separator)) {\n            if (pair == null)\n                throw new ParseException("Illegal route rule ...");\n\n            values = pair.mismatches;\n            // 将 content 存入到 MatchPair 的 mismatches 集合中\n            values.add(content);\n        }\n        \n        // 分隔符为 ,\n        else if (",".equals(separator)) {\n            if (values == null || values.isEmpty())\n                throw new ParseException("Illegal route rule ...");\n            // 将 content 存入到上一步获取到的 values 中，可能是 matches，也可能是 mismatches\n            values.add(content);\n        } else {\n            throw new ParseException("Illegal route rule ...");\n        }\n    }\n    return condition;\n}\n')])])]),e("p",[t._v("以上就是路由规则的解析逻辑，该逻辑由正则表达式 + 一个 while 循环 + 数个条件分支组成。下面使用一个示例对解析逻辑进行演绎。示例为 "),e("code",[t._v("host = 2.2.2.2 & host != 1.1.1.1 & method = hello")]),t._v("。正则解析结果如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("    括号一      括号二\n1.  null       host\n2.   =         2.2.2.2\n3.   &         host\n4.   !=        1.1.1.1\n5.   &         method\n6.   =         hello\n")])])]),e("p",[t._v("现在线程进入 while 循环：")]),t._v(" "),e("p",[t._v("第一次循环：分隔符 separator = null，content = “host”。此时创建 MatchPair 对象，并存入到 condition 中，condition = {“host”: MatchPair@123}")]),t._v(" "),e("p",[t._v("第二次循环：分隔符 separator = “=”，content = “2.2.2.2”，pair = MatchPair@123。此时将 2.2.2.2 放入到 MatchPair@123 对象的 matches 集合中。")]),t._v(" "),e("p",[t._v("第三次循环：分隔符 separator = “&”，content = “host”。host 已存在于 condition 中，因此 pair = MatchPair@123。")]),t._v(" "),e("p",[t._v("第四次循环：分隔符 separator = “!=”，content = “1.1.1.1”，pair = MatchPair@123。此时将 1.1.1.1 放入到 MatchPair@123 对象的 mismatches 集合中。")]),t._v(" "),e("p",[t._v("第五次循环：分隔符 separator = “&”，content = “method”。condition.get(“method”) = null，因此新建一个 MatchPair 对象，并放入到 condition 中。此时 condition = {“host”: MatchPair@123, “method”: MatchPair@ 456}")]),t._v(" "),e("p",[t._v("第六次循环：分隔符 separator = “=”，content = “2.2.2.2”，pair = MatchPair@456。此时将 hello 放入到 MatchPair@456 对象的 matches 集合中。")]),t._v(" "),e("p",[t._v("循环结束，此时 condition 的内容如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('{\n    "host": {\n        "matches": ["2.2.2.2"],\n        "mismatches": ["1.1.1.1"]\n    },\n    "method": {\n        "matches": ["hello"],\n        "mismatches": []\n    }\n}\n')])])]),e("p",[t._v("路由规则的解析过程稍微有点复杂，大家可通过 ConditionRouter 的测试类对该逻辑进行测试。并且找一个表达式，对照上面的代码走一遍，加深理解。关于路由规则的解析过程就先到这，我们继续往下看。")]),t._v(" "),e("h3",{attrs:{id:"_2-2-服务路由"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-服务路由"}},[t._v("#")]),t._v(" 2.2 服务路由")]),t._v(" "),e("p",[t._v("服务路由的入口方法是 ConditionRouter 的 router 方法，该方法定义在 Router 接口中。实现代码如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('public <T> List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation)\n        throws RpcException {\n    if (invokers == null || invokers.isEmpty()) {\n        return invokers;\n    }\n    try {\n        // 先对服务消费者条件进行匹配，如果匹配失败，表明当前消费者 url 不符合匹配规则，\n        // 无需进行后续匹配，直接返回 Invoker 列表即可。比如下面的规则：\n        //     host = 10.20.153.10 => host = 10.0.0.10\n        // 这条路由规则希望 IP 为 10.20.153.10 的服务消费者调用 IP 为 10.0.0.10 机器上的服务。\n        // 当消费者 ip 为 10.20.153.11 时，matchWhen 返回 false，表明当前这条路由规则不适用于\n        // 当前的服务消费者，此时无需再进行后续匹配，直接返回即可。\n        if (!matchWhen(url, invocation)) {\n            return invokers;\n        }\n        List<Invoker<T>> result = new ArrayList<Invoker<T>>();\n        // 服务提供者匹配条件未配置，表明对指定的服务消费者禁用服务，也就是服务消费者在黑名单中\n        if (thenCondition == null) {\n            logger.warn("The current consumer in the service blacklist...");\n            return result;\n        }\n        // 这里可以简单的把 Invoker 理解为服务提供者，现在使用服务提供者匹配规则对 \n        // Invoker 列表进行匹配\n        for (Invoker<T> invoker : invokers) {\n            // 匹配成功，表明当前 Invoker 符合服务提供者匹配规则。\n            // 此时将 Invoker 添加到 result 列表中\n            if (matchThen(invoker.getUrl(), url)) {\n                result.add(invoker);\n            }\n        }\n        \n        // 返回匹配结果，如果 result 为空列表，且 force = true，表示强制返回空列表，\n        // 否则路由结果为空的路由规则将自动失效\n        if (!result.isEmpty()) {\n            return result;\n        } else if (force) {\n            logger.warn("The route result is empty and force execute ...");\n            return result;\n        }\n    } catch (Throwable t) {\n        logger.error("Failed to execute condition router rule: ...");\n    }\n    \n    // 原样返回，此时 force = false，表示该条路由规则失效\n    return invokers;\n}\n')])])]),e("p",[t._v("router 方法先是调用 matchWhen 对服务消费者进行匹配，如果匹配失败，直接返回 Invoker 列表。如果匹配成功，再对服务提供者进行匹配，匹配逻辑封装在了 matchThen 方法中。下面来看一下这两个方法的逻辑：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("boolean matchWhen(URL url, Invocation invocation) {\n    // 服务消费者条件为 null 或空，均返回 true，比如：\n    //     => host != 172.22.3.91\n    // 表示所有的服务消费者都不得调用 IP 为 172.22.3.91 的机器上的服务\n    return whenCondition == null || whenCondition.isEmpty() \n        || matchCondition(whenCondition, url, null, invocation);  // 进行条件匹配\n}\n\nprivate boolean matchThen(URL url, URL param) {\n    // 服务提供者条件为 null 或空，表示禁用服务\n    return !(thenCondition == null || thenCondition.isEmpty()) \n        && matchCondition(thenCondition, url, param, null);  // 进行条件匹配\n}\n")])])]),e("p",[t._v("这两个方法长的有点像，不过逻辑上还是有差别的，大家注意看。这两个方法均调用了 matchCondition 方法，不过它们所传入的参数是不同的，这个需要特别注意。不然后面的逻辑不好弄懂。下面我们对这几个参数进行溯源。matchWhen 方法向 matchCondition 方法传入的参数为 [whenCondition, url, null, invocation]，第一个参数 whenCondition 为服务消费者匹配条件，这个前面分析过。第二个参数 url 源自 route 方法的参数列表，该参数由外部类调用 route 方法时传入。有代码为证，如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("private List<Invoker<T>> route(List<Invoker<T>> invokers, String method) {\n    Invocation invocation = new RpcInvocation(method, new Class<?>[0], new Object[0]);\n    List<Router> routers = getRouters();\n    if (routers != null) {\n        for (Router router : routers) {\n            if (router.getUrl() != null) {\n                // 注意第二个参数\n                invokers = router.route(invokers, getConsumerUrl(), invocation);\n            }\n        }\n    }\n    return invokers;\n}\n")])])]),e("p",[t._v("上面这段代码来自 RegistryDirectory，第二个参数表示的是服务消费者 url。matchCondition 的 invocation 参数也是从这里传入的。")]),t._v(" "),e("p",[t._v("接下来再来看看 matchThen 向 matchCondition 方法传入的参数 [thenCondition, url, param, null]。第一个参数不用解释了。第二个和第三个参数来自 matchThen 方法的参数列表，这两个参数分别为服务提供者 url 和服务消费者 url。搞清楚这些参数来源后，接下俩就可以分析 matchCondition 了。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("private boolean matchCondition(Map<String, MatchPair> condition, URL url, URL param, Invocation invocation) {\n    // 将服务提供者或消费者 url 转成 Map\n    Map<String, String> sample = url.toMap();\n    boolean result = false;\n    // 遍历 condition 列表\n    for (Map.Entry<String, MatchPair> matchPair : condition.entrySet()) {\n        // 获取匹配项名称，比如 host、method 等\n        String key = matchPair.getKey();\n        String sampleValue;\n        // 如果 invocation 不为空，且 key 为 mehtod(s)，表示进行方法匹配\n        if (invocation != null && (Constants.METHOD_KEY.equals(key) || Constants.METHODS_KEY.equals(key))) {\n            // 从 invocation 获取调用方法名称\n            sampleValue = invocation.getMethodName();\n        } else {\n            // 从服务提供者或消费者 url 中获取指定字段值，比如 host、application 等\n            sampleValue = sample.get(key);\n            if (sampleValue == null) {\n                // 尝试通过 default.xxx 获取相应的值\n                sampleValue = sample.get(Constants.DEFAULT_KEY_PREFIX + key);\n            }\n        }\n        \n        // --------------------✨ 分割线 ✨-------------------- //\n        \n        if (sampleValue != null) {\n            // 调用 MatchPair 的 isMatch 方法进行匹配\n            if (!matchPair.getValue().isMatch(sampleValue, param)) {\n                // 只要有一个规则匹配失败，立即返回 false 结束方法逻辑\n                return false;\n            } else {\n                result = true;\n            }\n        } else {\n            // sampleValue 为空，表明服务提供者或消费者 url 中不包含相关字段。此时如果 \n            // MatchPair 的 matches 不为空，表示匹配失败，返回 false。比如我们有这样\n            // 一条匹配条件 loadbalance = random，假设 url 中并不包含 loadbalance 参数，\n            // 此时 sampleValue = null。既然路由规则里限制了 loadbalance = random，\n            // 但 sampleValue = null，明显不符合规则，因此返回 false\n            if (!matchPair.getValue().matches.isEmpty()) {\n                return false;\n            } else {\n                result = true;\n            }\n        }\n    }\n    return result;\n}\n")])])]),e("p",[t._v("如上，matchCondition 方法看起来有点复杂，这里简单缕缕。分割线以上的代码实际上主要是用于获取 sampleValue 的值，分割线以下才是进行条件匹配。条件匹配调用的逻辑封装在 isMatch 中，代码如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("private boolean isMatch(String value, URL param) {\n    // 情况一：matches 非空，mismatches 为空\n    if (!matches.isEmpty() && mismatches.isEmpty()) {\n        // 遍历 matches 集合，检测入参 value 是否能被 matches 集合元素匹配到。\n        // 举个例子，如果 value = 10.20.153.11，matches = [10.20.153.*],\n        // 此时 isMatchGlobPattern 方法返回 true\n        for (String match : matches) {\n            if (UrlUtils.isMatchGlobPattern(match, value, param)) {\n                return true;\n            }\n        }\n        \n        // 如果所有匹配项都无法匹配到入参，则返回 false\n        return false;\n    }\n\n    // 情况二：matches 为空，mismatches 非空\n    if (!mismatches.isEmpty() && matches.isEmpty()) {\n        for (String mismatch : mismatches) {\n            // 只要入参被 mismatches 集合中的任意一个元素匹配到，就返回 false\n            if (UrlUtils.isMatchGlobPattern(mismatch, value, param)) {\n                return false;\n            }\n        }\n        // mismatches 集合中所有元素都无法匹配到入参，此时返回 true\n        return true;\n    }\n\n    // 情况三：matches 非空，mismatches 非空\n    if (!matches.isEmpty() && !mismatches.isEmpty()) {\n        // matches 和 mismatches 均为非空，此时优先使用 mismatches 集合元素对入参进行匹配。\n        // 只要 mismatches 集合中任意一个元素与入参匹配成功，就立即返回 false，结束方法逻辑\n        for (String mismatch : mismatches) {\n            if (UrlUtils.isMatchGlobPattern(mismatch, value, param)) {\n                return false;\n            }\n        }\n        // mismatches 集合元素无法匹配到入参，此时使用 matches 继续匹配\n        for (String match : matches) {\n            // 只要 matches 集合中任意一个元素与入参匹配成功，就立即返回 true\n            if (UrlUtils.isMatchGlobPattern(match, value, param)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    // 情况四：matches 和 mismatches 均为空，此时返回 false\n    return false;\n}\n")])])]),e("p",[t._v("isMatch 方法逻辑比较清晰，由三个条件分支组成，用于处理四种情况。这里对四种情况下的匹配逻辑进行简单的总结，如下：")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"left"}}),t._v(" "),e("th",{staticStyle:{"text-align":"left"}},[t._v("条件")]),t._v(" "),e("th",{staticStyle:{"text-align":"left"}},[t._v("动作")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("情况一")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("matches 非空，mismatches 为空")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("遍历 matches 集合元素，并与入参进行匹配。只要有一个元素成功匹配入参，即可返回 true。若全部失配，则返回 false。")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("情况二")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("matches 为空，mismatches 非空")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("遍历 mismatches 集合元素，并与入参进行匹配。只要有一个元素成功匹配入参，立即 false。若全部失配，则返回 true。")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("情况三")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("matches 非空，mismatches 非空")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("优先使用 mismatches 集合元素对入参进行匹配，只要任一元素与入参匹配成功，就立即返回 false，结束方法逻辑。否则再使用 matches 中的集合元素进行匹配，只要有任意一个元素匹配成功，即可返回 true。若全部失配，则返回 false")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("情况四")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("matches 为空，mismatches 为空")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("直接返回 false")])])])]),t._v(" "),e("p",[t._v("isMatch 方法逻辑不是很难理解，大家自己再看看。下面继续分析 isMatchGlobPattern 方法。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('public static boolean isMatchGlobPattern(String pattern, String value, URL param) {\n    if (param != null && pattern.startsWith("$")) {\n        // 引用服务消费者参数，param 参数为服务消费者 url\n        pattern = param.getRawParameter(pattern.substring(1));\n    }\n    // 调用重载方法继续比较\n    return isMatchGlobPattern(pattern, value);\n}\n\npublic static boolean isMatchGlobPattern(String pattern, String value) {\n    // 对 * 通配符提供支持\n    if ("*".equals(pattern))\n        // 匹配规则为通配符 *，直接返回 true 即可\n        return true;\n    if ((pattern == null || pattern.length() == 0)\n            && (value == null || value.length() == 0))\n        // pattern 和 value 均为空，此时可认为两者相等，返回 true\n        return true;\n    if ((pattern == null || pattern.length() == 0)\n            || (value == null || value.length() == 0))\n        // pattern 和 value 其中有一个为空，两者不相等，返回 false\n        return false;\n\n    // 查找 * 通配符位置\n    int i = pattern.lastIndexOf(\'*\');\n    if (i == -1) {\n        // 匹配规则中不包含通配符，此时直接比较 value 和 pattern 是否相等即可，并返回比较结果\n        return value.equals(pattern);\n    }\n    // 通配符 "*" 在匹配规则尾部，比如 10.0.21.*\n    else if (i == pattern.length() - 1) {\n        // 检测 value 是否以不含通配符的匹配规则开头，并返回结果。比如:\n        // pattern = 10.0.21.*，value = 10.0.21.12，此时返回 true\n        return value.startsWith(pattern.substring(0, i));\n    }\n    // 通配符 "*" 在匹配规则头部\n    else if (i == 0) {\n        // 检测 value 是否以不含通配符的匹配规则结尾，并返回结果\n        return value.endsWith(pattern.substring(i + 1));\n    }\n    // 通配符 "*" 在匹配规则中间位置\n    else {\n        // 通过通配符将 pattern 分成两半，得到 prefix 和 suffix\n        String prefix = pattern.substring(0, i);\n        String suffix = pattern.substring(i + 1);\n        // 检测 value 是否以 prefix 变量开头，且以 suffix 变量结尾，并返回结果\n        return value.startsWith(prefix) && value.endsWith(suffix);\n    }\n}\n')])])]),e("p",[t._v("以上就是 isMatchGlobPattern 两个重载方法的全部逻辑，这两个方法分别对普通的匹配，以及”引用消费者参数“和通配符匹配做了支持。这两个方法的逻辑并不是很复杂，而且我也在代码上进行了比较详细的注释，大家自己看看吧，就不多说了。")])])}),[],!1,null,null,null);n.default=r.exports}}]);