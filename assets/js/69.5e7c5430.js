(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{498:function(e,n,a){"use strict";a.r(n);var t=a(30),i=Object(t.a)({},(function(){var e=this,n=e.$createElement,a=e._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"spring-ioc-容器源码分析-余下的初始化工作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spring-ioc-容器源码分析-余下的初始化工作"}},[e._v("#")]),e._v(" Spring IOC 容器源码分析 - 余下的初始化工作")]),e._v(" "),a("h2",{attrs:{id:"_1-简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-简介"}},[e._v("#")]),e._v(" 1. 简介")]),e._v(" "),a("p",[e._v("本篇文章是“Spring IOC 容器源码分析”系列文章的最后一篇文章，本篇文章所分析的对象是 initializeBean 方法，该方法用于对已完成属性填充的 bean 做最后的初始化工作。相较于之前几篇文章所分析的源码，initializeBean 的源码相对比较简单，大家可以愉快的阅读。好了，其他的不多说了，我们直入主题吧。")]),e._v(" "),a("h2",{attrs:{id:"_2-源码分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-源码分析"}},[e._v("#")]),e._v(" 2. 源码分析")]),e._v(" "),a("p",[e._v("本章我们来分析一下 initializeBean 方法的源码。在完成分析后，还是像往常一样，把方法的执行流程列出来。好了，看源码吧：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) {\n    if (System.getSecurityManager() != null) {\n        AccessController.doPrivileged(new PrivilegedAction<Object>() {\n            @Override\n            public Object run() {\n                invokeAwareMethods(beanName, bean);\n                return null;\n            }\n        }, getAccessControlContext());\n    }\n    else {\n        // 若 bean 实现了 BeanNameAware、BeanFactoryAware、BeanClassLoaderAware 等接口，则向 bean 中注入相关对象\n        invokeAwareMethods(beanName, bean);\n    }\n\n    Object wrappedBean = bean;\n    if (mbd == null || !mbd.isSynthetic()) {\n        // 执行 bean 初始化前置操作\n        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\n    }\n\n    try {\n        /*\n         * 调用初始化方法：\n         * 1. 若 bean 实现了 InitializingBean 接口，则调用 afterPropertiesSet 方法\n         * 2. 若用户配置了 bean 的 init-method 属性，则调用用户在配置中指定的方法\n         */\n        invokeInitMethods(beanName, wrappedBean, mbd);\n    }\n    catch (Throwable ex) {\n        throw new BeanCreationException(\n                (mbd != null ? mbd.getResourceDescription() : null),\n                beanName, "Invocation of init method failed", ex);\n    }\n    if (mbd == null || !mbd.isSynthetic()) {\n        // 执行 bean 初始化后置操作，AOP 会在此处向目标对象中织入切面逻辑\n        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\n    }\n    return wrappedBean;\n}\n')])])]),a("p",[e._v("以上就是 initializeBean 方法的逻辑，很简单是不是。该方法做了如下几件事情：")]),e._v(" "),a("ol",[a("li",[e._v("检测 bean 是否实现了 *Aware 类型接口，若实现，则向 bean 中注入相应的对象")]),e._v(" "),a("li",[e._v("执行 bean 初始化前置操作")]),e._v(" "),a("li",[e._v("执行初始化操作")]),e._v(" "),a("li",[e._v("执行 bean 初始化后置操作")])]),e._v(" "),a("p",[e._v("在上面的流程中，我们又发现了后置处理器的踪影。如果大家阅读过 Spring 的源码，会发现后置处理器在 Spring 源码中多次出现过。后置处理器是 Spring 拓展点之一，通过实现后置处理器 BeanPostProcessor 接口，我们就可以插手 bean 的初始化过程。比如大家所熟悉的 AOP 就是在后置处理 postProcessAfterInitialization 方法中向目标对象中织如切面逻辑的。关于“前置处理”和“后置处理”相关的源码，这里就不分析了，大家有兴趣自己去看一下。接下来分析一下 invokeAwareMethods 和 invokeInitMethods 方法，如下：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("private void invokeAwareMethods(final String beanName, final Object bean) {\n    if (bean instanceof Aware) {\n        if (bean instanceof BeanNameAware) {\n            // 注入 beanName 字符串\n            ((BeanNameAware) bean).setBeanName(beanName);\n        }\n        if (bean instanceof BeanClassLoaderAware) {\n            // 注入 ClassLoader 对象\n            ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());\n        }\n        if (bean instanceof BeanFactoryAware) {\n            // 注入 BeanFactory 对象\n            ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);\n        }\n    }\n}\n")])])]),a("p",[e._v("invokeAwareMethods 方法的逻辑很简单，一句话总结：根据 bean 所实现的 Aware 的类型，向 bean 中注入不同类型的对象。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('protected void invokeInitMethods(String beanName, final Object bean, RootBeanDefinition mbd)\n        throws Throwable {\n\n    // 检测 bean 是否是 InitializingBean 类型的\n    boolean isInitializingBean = (bean instanceof InitializingBean);\n    if (isInitializingBean && (mbd == null || !mbd.isExternallyManagedInitMethod("afterPropertiesSet"))) {\n        if (logger.isDebugEnabled()) {\n            logger.debug("Invoking afterPropertiesSet() on bean with name \'" + beanName + "\'");\n        }\n        if (System.getSecurityManager() != null) {\n            try {\n                AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n                    @Override\n                    public Object run() throws Exception {\n                        ((InitializingBean) bean).afterPropertiesSet();\n                        return null;\n                    }\n                }, getAccessControlContext());\n            }\n            catch (PrivilegedActionException pae) {\n                throw pae.getException();\n            }\n        }\n        else {\n            // 如果 bean 实现了 InitializingBean，则调用 afterPropertiesSet 方法执行初始化逻辑\n            ((InitializingBean) bean).afterPropertiesSet();\n        }\n    }\n\n    if (mbd != null) {\n        String initMethodName = mbd.getInitMethodName();\n        if (initMethodName != null && !(isInitializingBean && "afterPropertiesSet".equals(initMethodName)) &&\n                !mbd.isExternallyManagedInitMethod(initMethodName)) {\n            // 调用用户自定义的初始化方法\n            invokeCustomInitMethod(beanName, bean, mbd);\n        }\n    }\n}\n')])])]),a("p",[e._v("invokeInitMethods 方法用于执行初始化方法，也不复杂，就不多说了。")])])}),[],!1,null,null,null);n.default=i.exports}}]);