(window.webpackJsonp=window.webpackJsonp||[]).push([[86],{515:function(v,_,t){"use strict";t.r(_);var i=t(30),l=Object(i.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"加密与数字证书"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#加密与数字证书"}},[v._v("#")]),v._v(" 加密与数字证书")]),v._v(" "),t("p",[v._v("非对称加密、对称加密、公钥、私钥、数字证书、数字签名、信息摘要等等，其实这些都是通讯安全中的概念，既然如此我们不妨从通讯开始入手。")]),v._v(" "),t("h2",{attrs:{id:"情景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#情景"}},[v._v("#")]),v._v(" 情景")]),v._v(" "),t("p",[v._v("礼和弥是一对异国恋人，尽管相距很远，但是却不影响彼此之间的爱慕之情，她们喜欢通过网络来交流。")]),v._v(" "),t("h2",{attrs:{id:"对称加密"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对称加密"}},[v._v("#")]),v._v(" 对称加密")]),v._v(" "),t("p",[v._v("一天礼要给弥发送一份非常私密的内容。礼不希望通讯过程中被人截取而泄密秘密。这个时候，自然想到的方法就是对通讯内容进行加密，当然除了加密外，还需要让礼能够解密。")]),v._v(" "),t("p",[v._v("礼认为可以 我可以生成 一个秘钥 ，然后用这个秘钥对内容进行加密，然后我把我生成的秘钥和加密的算法告诉弥，然后她在用我告诉她的秘钥和加密算法进行解密。")]),v._v(" "),t("p",[v._v("上面的加密解密过程就属于对称加密，对称加密，需要一个秘钥和一个对称加密算法。 常见的对称加密算法有:")]),v._v(" "),t("ul",[t("li",[v._v("DES")]),v._v(" "),t("li",[v._v("3DES")]),v._v(" "),t("li",[v._v("AES")])]),v._v(" "),t("p",[v._v("礼把自己的想法告诉了弥，弥听完后，提出了一个问题——“你怎么把秘钥给我”。礼想了会儿，的确，不可能通过网络发给她，万一被人把你的秘钥被人偷看了怎么办。干脆下次见面的时候告诉她？不行，下次见面不知道是什么时候了，难道这中间都不跟他通讯吗！想到这里礼就很烦，我就想安全通讯而已，怎么这么麻烦。")]),v._v(" "),t("h2",{attrs:{id:"非对称加密"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#非对称加密"}},[v._v("#")]),v._v(" 非对称加密")]),v._v(" "),t("p",[v._v("又过了一段时间，礼兴奋的跟弥说，我找到解决办法了，我们可以使用非对称加密算法来加密我们的内容。\n什么是非对称加密算法？弥问道。")]),v._v(" "),t("p",[v._v("非对称加密算法 不同于 对称加密，它有一对秘钥，一个称为 "),t("strong",[v._v("公钥（publicKey）")]),v._v(" ，另一个称为 "),t("strong",[v._v("私钥（privateKey）")]),v._v("，"),t("em",[v._v("并且只知道公钥是无法推算出私钥。")]),v._v("\n另外，这种算法还有一个特别神奇的功能，那就是 "),t("strong",[v._v("通过公钥加密的内容，只有私钥才可以解开，而通过私钥加密的内容，只有公钥才可以解开。")])]),v._v(" "),t("p",[v._v("非对称加密，需要一对秘钥和一个非对称加密算法。 常见的非对称加密算法有:")]),v._v(" "),t("ul",[t("li",[v._v("RSA")]),v._v(" "),t("li",[v._v("DSA")])]),v._v(" "),t("p",[v._v("礼说，我们可以利用这个特性来加密我们的通讯内容。那怎么利用能，弥问道。")]),v._v(" "),t("p",[v._v("假如我要和你通讯")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("首先，你要生成一对秘钥，然后把公钥发给我。等等，公钥被看到也没有关系吗，弥问道。没关系，没关系，你听我说完就知道了。")])]),v._v(" "),t("li",[t("p",[v._v("然后，我拿到公钥后，对内容进行加密，然后传给你，利用"),t("strong",[v._v("通过公钥加密的内容，只有私钥才可以解开的特性")]),v._v("，就算公钥没偷看，也解不开。只有持有私钥的你才能解开。")])]),v._v(" "),t("li",[t("p",[v._v("最后，你收到公钥后就可以通过私钥来解开我发送的内容了。")])])]),v._v(" "),t("p",[v._v("反过来，你要和我通讯也一样")]),v._v(" "),t("ul",[t("li",[v._v("首先，我生成一对秘钥，然后把公钥发给你。")]),v._v(" "),t("li",[v._v("你收到后，加密要发送的内容，然后发给我")]),v._v(" "),t("li",[v._v("我收到加密后的内容后，在通过我的私钥解密。")])]),v._v(" "),t("p",[v._v("嗯，的确这样一来，我们每个人只有生成一对秘钥，就可以安全通讯了。")]),v._v(" "),t("h2",{attrs:{id:"安全与速度-二者都要兼得"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#安全与速度-二者都要兼得"}},[v._v("#")]),v._v(" 安全与速度，二者都要兼得")]),v._v(" "),t("p",[v._v("两人，使用上面的方法进行通讯一段时间后，发现了一个问题。那就是非对称算法，加密解密速度太慢，完全赶不上对称加密算法。")]),v._v(" "),t("p",[v._v("怎么办了，弥想到了一个好办法。 假设 礼和弥 要进行通讯")]),v._v(" "),t("ul",[t("li",[v._v("首先，礼生成一对秘钥，然后把公钥发给弥")]),v._v(" "),t("li",[v._v("弥收到公钥后，生成一个对称加密算法的秘钥，然后将对称加密算法和对称加密算法的秘钥当做内容用公钥加密后，在发回给弥。（其实这跟上面的步骤一样，只是这里的内容不是普通的内容，而是对称加密算法和对称加密算法的秘钥）")]),v._v(" "),t("li",[v._v("礼收到加密内容后，用私钥解开内容，这样他就安全的得到了对称加密的算法和秘钥。这样一来两个人就相当于商量好了加密方式和秘钥。(参考对称加密那一章所遇到的问题)")]),v._v(" "),t("li",[v._v("最后，两人就可以通过 加密解密更加快速的 对称加密算法 来加密自己的通讯内容。")])]),v._v(" "),t("h2",{attrs:{id:"信息摘要、数字签名"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#信息摘要、数字签名"}},[v._v("#")]),v._v(" 信息摘要、数字签名")]),v._v(" "),t("p",[v._v("虽说 对称加密算法 比 非对称加密算法 要快很多，但是遇到要加密的信息很多时，速度也会很慢。而且并不是所有的信息都需要加密，一些不怕被人看到的信息，我只需要防止他被人更改就行了。\n那如何防止在通讯过程中信息不被别人修改呢，那就是使用 信息摘要和数字签名。")]),v._v(" "),t("h3",{attrs:{id:"信息摘要"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#信息摘要"}},[v._v("#")]),v._v(" 信息摘要")]),v._v(" "),t("p",[v._v("什么是信息摘要 就像一片文章的摘要一样，信息摘要就是一段信息的摘要。它有以下特征")]),v._v(" "),t("ul",[t("li",[v._v("无论输入的消息有多长，计算出来的消息摘要的长度总是固定的")]),v._v(" "),t("li",[v._v("用相同的摘要算法对相同的消息求两次摘要，其结果必然相同")]),v._v(" "),t("li",[v._v("一般地，只要输入的消息不同，对其进行摘要以后产生的摘要消息也几乎不可能相同")]),v._v(" "),t("li",[v._v("消息摘要是单向的，只能进行正向的信息摘要，而无法从摘要中恢复出任何的原信息")])]),v._v(" "),t("p",[v._v("以上这些神奇的特性是通过摘要算法来实现的，常用的摘要算法有：")]),v._v(" "),t("ul",[t("li",[v._v("MD5")]),v._v(" "),t("li",[v._v("SHA-1")]),v._v(" "),t("li",[v._v("SHA-256")]),v._v(" "),t("li",[v._v("SHA-512")])]),v._v(" "),t("p",[v._v("这样一来，我们就可以将非常长的消息，用较短的摘要表示了，并且如果有人修改了我的消息，那么对应的摘要就会变。我们在发信息的时候，摘要也跟着一起发出去，如果信息被改了，那么接收者一算，发现，信息的摘要和原本的摘要不一致，就知道信息被篡改了。")]),v._v(" "),t("h3",{attrs:{id:"数字签名"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数字签名"}},[v._v("#")]),v._v(" 数字签名")]),v._v(" "),t("p",[v._v("其实上面的考虑并周到，如果黑客连摘要一起改了怎么办？所以必须让黑客无法更改信息摘要，做法也很简单，就是对信息摘要进行签名。\n所谓的 签名(动词) 其实就是使用  "),t("strong",[v._v("私钥对信息摘要进行加密的过程")]),v._v("\n所谓的 签名(名词) 其实就是  "),t("strong",[v._v("私钥对信息摘要进行加密后的密文")]),v._v(" 数字签名一般指的是 "),t("strong",[v._v("私钥对信息摘要进行加密后的密文")])]),v._v(" "),t("p",[v._v("这样一来 我的摘要是加密的 ，如果黑客修改数字签名，那我解密后的签名，就不是原来的签名了，除非碰巧解密后的签名正好是 被修改的消息的签名，但这种几率太低太低，几乎不可能。")]),v._v(" "),t("h2",{attrs:{id:"中间人攻击"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#中间人攻击"}},[v._v("#")]),v._v(" 中间人攻击")]),v._v(" "),t("p",[v._v("真的可以高枕无忧了吗？\n还是礼和弥发信息这个场景")]),v._v(" "),t("ul",[t("li",[v._v("弥首先生成了一对秘钥，然后把公钥发给礼。")]),v._v(" "),t("li",[v._v("这时候，黑客出现了，他也生成了一对秘钥。然后他劫持了 弥给礼 发的消息，并偷偷把 弥的公钥换成自己的公钥，然后还把原来的公钥给存了起来，最后再发给礼。")]),v._v(" "),t("li",[v._v("礼收到公钥后，还以为是这是弥的公钥，于是生成一个对称加密算法的秘钥，然后将对称加密算法和对称加密算法的秘钥当做内容用公钥加密后，在发回给弥。")]),v._v(" "),t("li",[v._v("这时，黑客再次劫持，用自己的私钥解开了加密内容。这样黑客就有了 对称加密算法和对称加密算法的秘钥了。这还不算完，他把这内容再用之前取出的弥的公钥加密，然后在发给弥。")]),v._v(" "),t("li",[v._v("弥收到后，还以为是礼发来的，兴高采烈的用私钥解开，取出里面的 对称加密算法和秘钥。后期两人就用此对称加密算法来加密通讯内容。")]),v._v(" "),t("li",[v._v("遗憾的是，这对称加密的秘钥不光两人有，黑客也有，两人的通讯内容还是被看的一清二楚。")])]),v._v(" "),t("p",[v._v("中间人攻击的恐怖之处在于，整个攻击过程，通讯双方无法察觉到任何异议，但通讯内容却暴露在黑客的眼中。")]),v._v(" "),t("h2",{attrs:{id:"数字证书-、ca"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数字证书-、ca"}},[v._v("#")]),v._v(" 数字证书 、CA")]),v._v(" "),t("p",[v._v("上面的问题出在公钥被黑客偷偷换了。  或者说是信息在传输过程中被修改了。 解决办法也很简单，那就是不使用公钥而是使用数字证书(以下简称证书)。")]),v._v(" "),t("p",[v._v('证书是什么东西，简单理解就是一个被权威机构认证的公钥。就像我们的毕业证会被学校盖个章一样，权威机构也会为公钥"盖个章"。 '),t("strong",[v._v("这样的权威机构，我们称作CA(Certificate Authority)数字证书认证中心。")]),v._v(" 只是这个盖章的过程，可能和你想的不一样。")]),v._v(" "),t("ul",[t("li",[v._v("首先申请证书的人，会把申请资料提供给CA，这些资料包括，公钥、公司名称、网址等。")]),v._v(" "),t("li",[v._v("CA审核后，会将审核通过的资料生成信息摘要，然后 CA会用自己的私钥对信息摘要进行签名，这样证书就无法被篡改了。(CA也有一对秘钥，其中公钥是公开的，但是私钥会进行特别的保护，严禁泄漏和盗用)")])]),v._v(" "),t("p",[v._v("数字证书的内容包含以下部分")]),v._v(" "),t("ul",[t("li",[v._v("版本号—标识证书的版本（V1 V2 V3)")]),v._v(" "),t("li",[v._v("序列号—证书的唯一标识符。")]),v._v(" "),t("li",[v._v("签名 —签名算法和内容")]),v._v(" "),t("li",[v._v("颁发者—证书颁发者相关信息")]),v._v(" "),t("li",[v._v("主体 —证书拥有者相关信息包含公钥、证书过期时间等")]),v._v(" "),t("li",[v._v("颁发者唯一标识符—证书颁发者的唯一标识符 V2 V3")]),v._v(" "),t("li",[v._v("主体唯 一标识符—证书拥有者的唯一标识符 V2 V3")]),v._v(" "),t("li",[v._v("扩展 —可选的标准和专用的扩展 V2 V3")])]),v._v(" "),t("p",[v._v("由于证书中的签名可以防止黑客篡改，所以，数字证书可以用来代替公钥。")]),v._v(" "),t("p",[v._v("因此礼和弥的安全通讯的过程变成以下这个样子了")]),v._v(" "),t("ol",[t("li",[v._v("首先，礼生成一对秘钥，然后把公钥等相关信息发给CA")]),v._v(" "),t("li",[v._v("CA确认无误后，为其颁发证书。")]),v._v(" "),t("li",[v._v("礼将证书发给弥")]),v._v(" "),t("li",[v._v("弥收到证书后，确认证书的信息，然后用 "),t("em",[v._v("“CA的公钥”")]),v._v(" 解开证书中的签名，然后对证书内容做摘要，最后比较两个摘要是否一致，如果一致就说明证书没有被窜改。")]),v._v(" "),t("li",[v._v("如果证书没有被篡改，取出里面的公钥，生成一个对称加密算法的秘钥，将对称加密算法的和秘钥用公钥加密，然后发给礼。")]),v._v(" "),t("li",[v._v("之后就可以安全通讯了(其实这也是HTTPS协议的加密过程)")])]),v._v(" "),t("p",[v._v("(这里提一个小问题，第四步中的CA的公钥是怎么来的)")]),v._v(" "),t("h2",{attrs:{id:"根证书"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#根证书"}},[v._v("#")]),v._v(" 根证书")]),v._v(" "),t("p",[v._v("CA的公钥是怎么来的？\nCA发给我吗？那发送的过程还是会出现篡改的情况啊。\n除非CA的公钥也是一个证书！！！")]),v._v(" "),t("p",[v._v("其实CA的公钥的确是一个证书。\n那这个证书又是谁签发的呢？")]),v._v(" "),t("p",[v._v("答案是 CA的CA，也可以成为根CA，就同根DNS服务器一样，全世界的根CA也就那么几个，负责所有CA的证书的签发。")]),v._v(" "),t("p",[v._v("说以上一章的第四步可以细分为")]),v._v(" "),t("ol",[t("li",[v._v("弥收到礼的证书")]),v._v(" "),t("li",[v._v("弥用根CA的公钥解开CA证书的签名，然后校验CA证书的真实性")]),v._v(" "),t("li",[v._v("校验通过后，在用CA证书的公钥解开礼的证书的签名，然后校验证书的真实性")]),v._v(" "),t("li",[v._v("校验通过之后，就可以认为礼的证书是真实可信的。")])]),v._v(" "),t("p",[v._v('有些人可能有要问了，根CA的公钥是怎么来的？\n感觉陷入了一个死循环了。\n其实并不会，因为根CA的"公钥"，其实也是一个证书，但是这个证书有些特殊，他的签发单位是它自己。')]),v._v(" "),t("p",[v._v("这种类型的证书也叫 "),t("strong",[v._v("自签名证书")])]),v._v(" "),t("p",[v._v("另外根CA的证书，会内置在我们的操作系统和浏览器中。也就是说根CA的证书，天生就有，不需要去下载安装。")]),v._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),t("ul",[t("li",[v._v("对称加密：这种加密算法只需要一个 秘钥，且相较于非对称加密 ，加密和解密速度较快")]),v._v(" "),t("li",[v._v("非对称加密：这种加密算法需要一对 秘钥，其中一个叫公钥，另一个叫私钥。相较于对称加密来说 ，加密和解密速度较慢")]),v._v(" "),t("li",[v._v("公钥：非对称加密中可以被公开的秘钥，用于对信息加密，可被封装成证书。")]),v._v(" "),t("li",[v._v("私钥：非对称加密中要保管好的秘钥，用于对公钥加密的信息解密，还可用于签名")]),v._v(" "),t("li",[v._v("信息摘要：通过信息摘要算法，将原信息摘要为一个固定长度的摘要")]),v._v(" "),t("li",[v._v("数字签名：信息摘要被私钥加密后的密文")]),v._v(" "),t("li",[v._v("数字证书：可以简单理解为 被CA承认且无法篡改的公钥")]),v._v(" "),t("li",[v._v("CA：签发证书的权威机构")]),v._v(" "),t("li",[v._v("根CA：CA的CA，可以签发CA的证书")]),v._v(" "),t("li",[v._v("根证书：根CA的自签名证书")]),v._v(" "),t("li",[v._v("中间人攻击：一句话说不清楚，你还是去看中间人攻击那一章吧！")])]),v._v(" "),t("p",[v._v("作者：我妻礼弥\n链接：https://juejin.cn/post/6844903618798157838\n来源：掘金")])])}),[],!1,null,null,null);_.default=l.exports}}]);