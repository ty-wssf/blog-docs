(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{490:function(n,e,t){"use strict";t.r(e);var _=t(30),r=Object(_.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"spring-boot-如何解决项目启动时初始化资源"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-boot-如何解决项目启动时初始化资源"}},[n._v("#")]),n._v(" Spring Boot 如何解决项目启动时初始化资源")]),n._v(" "),t("p",[n._v("在我们实际工作中，总会遇到这样需求，在项目启动的时候需要做一些初始化的操作，比如初始化线程池，提前加载好加密证书等。今天就给大家介绍一个 Spring Boot 神器，专门帮助大家解决项目启动初始化资源操作。")]),n._v(" "),t("p",[n._v("这个神器就是 "),t("code",[n._v("CommandLineRunner")]),n._v("，"),t("code",[n._v("CommandLineRunner")]),n._v(" 接口的 "),t("code",[n._v("Component")]),n._v(" 会在所有 "),t("code",[n._v("Spring Beans")]),n._v("都初始化之后，"),t("code",[n._v("SpringApplication.run()")]),n._v("之前执行，非常适合在应用程序启动之初进行一些数据初始化的工作。")]),n._v(" "),t("p",[n._v("接下来我们就运用案例测试它如何使用，在测试之前在启动类加两行打印提示，方便我们识别 "),t("code",[n._v("CommandLineRunner")]),n._v(" 的执行时机。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('@SpringBootApplication\npublic class CommandLineRunnerApplication {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println("The service to start.");\n\t\tSpringApplication.run(CommandLineRunnerApplication.class, args);\n\t\tSystem.out.println("The service has started.");\n\t}\n}\n')])])]),t("p",[n._v("接下来我们直接创建一个类继承 "),t("code",[n._v("CommandLineRunner")]),n._v(" ，并实现它的 "),t("code",[n._v("run()")]),n._v(" 方法。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('@Component\npublic class Runner implements CommandLineRunner {\n    @Override\n    public void run(String... args) throws Exception {\n        System.out.println("The Runner start to initialize ...");\n    }\n}\n')])])]),t("p",[n._v("我们在 "),t("code",[n._v("run()")]),n._v(" 方法中打印了一些参数来看出它的执行时机。完成之后启动项目进行测试：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("...\nThe service to start.\n\n  .   ____          _            __ _ _\n /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  '  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::        (v2.0.0.RELEASE)\n...\n2018-04-21 22:21:34.706  INFO 27016 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''\n2018-04-21 22:21:34.710  INFO 27016 --- [           main] com.neo.CommandLineRunnerApplication     : Started CommandLineRunnerApplication in 3.796 seconds (JVM running for 5.128)\nThe Runner start to initialize ...\nThe service has started.\n")])])]),t("p",[n._v("根据控制台的打印信息我们可以看出 "),t("code",[n._v("CommandLineRunner")]),n._v(" 中的方法会在 Spring Boot 容器加载之后执行，执行完成后项目启动完成。")]),n._v(" "),t("p",[n._v("如果我们在启动容器的时候需要初始化很多资源，并且初始化资源相互之间有序，那如何保证不同的 "),t("code",[n._v("CommandLineRunner")]),n._v(" 的执行顺序呢？Spring Boot 也给出了解决方案。那就是使用 "),t("code",[n._v("@Order")]),n._v(" 注解。")]),n._v(" "),t("p",[n._v("我们创建两个 "),t("code",[n._v("CommandLineRunner")]),n._v(" 的实现类来进行测试：")]),n._v(" "),t("p",[n._v("第一个实现类：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('@Component\n@Order(1)\npublic class OrderRunner1 implements CommandLineRunner {\n    @Override\n    public void run(String... args) throws Exception {\n        System.out.println("The OrderRunner1 start to initialize ...");\n    }\n}\n')])])]),t("p",[n._v("第二个实现类：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('@Component\n@Order(2)\npublic class OrderRunner2 implements CommandLineRunner {\n    @Override\n    public void run(String... args) throws Exception {\n        System.out.println("The OrderRunner2 start to initialize ...");\n    }\n}\n')])])]),t("p",[n._v("添加完成之后重新启动，观察执行顺序：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("...\nThe service to start.\n\n  .   ____          _            __ _ _\n /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  '  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::        (v2.0.0.RELEASE)\n...\n2018-04-21 22:21:34.706  INFO 27016 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''\n2018-04-21 22:21:34.710  INFO 27016 --- [           main] com.neo.CommandLineRunnerApplication     : Started CommandLineRunnerApplication in 3.796 seconds (JVM running for 5.128)\nThe OrderRunner1 start to initialize ...\nThe OrderRunner2 start to initialize ...\nThe Runner start to initialize ...\nThe service has started.\n")])])]),t("p",[n._v("通过控制台的输出我们发现，添加 "),t("code",[n._v("@Order")]),n._v(" 注解的实现类最先执行，并且"),t("code",[n._v("@Order()")]),n._v("里面的值越小启动越早。")]),n._v(" "),t("p",[n._v("在实践中，使用"),t("code",[n._v("ApplicationRunner")]),n._v("也可以达到相同的目的，两着差别不大。看来使用 Spring Boot 解决初始化资源的问题非常简单。")])])}),[],!1,null,null,null);e.default=r.exports}}]);