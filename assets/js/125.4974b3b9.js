(window.webpackJsonp=window.webpackJsonp||[]).push([[125],{551:function(e,n,u){"use strict";u.r(n);var o=u(30),r=Object(o.a)({},(function(){var e=this,n=e.$createElement,u=e._self._c||n;return u("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[u("h1",{attrs:{id:"并发容器之blockingqueue"}},[u("a",{staticClass:"header-anchor",attrs:{href:"#并发容器之blockingqueue"}},[e._v("#")]),e._v(" 并发容器之BlockingQueue")]),e._v(" "),u("h2",{attrs:{id:"_1-blockingqueue-简介"}},[u("a",{staticClass:"header-anchor",attrs:{href:"#_1-blockingqueue-简介"}},[e._v("#")]),e._v(" 1. BlockingQueue 简介")]),e._v(" "),u("p",[e._v("在实际编程中，会经常使用到 JDK 中 Collection 集合框架中的各种容器类如实现 List,Map,Queue 接口的容器类，但是这些容器类基本上不是线程安全的，除了使用 Collections 可以将其转换为线程安全的容器，Doug Lea 大师为我们都准备了对应的线程安全的容器，如实现 List 接口的 CopyOnWriteArrayList（"),u("a",{attrs:{href:"https://juejin.im/post/6844903602436374541",target:"_blank",rel:"noopener noreferrer"}},[e._v("关于 CopyOnWriteArrayList 可以看这篇文章"),u("OutboundLink")],1),e._v("），实现 Map 接口的 ConcurrentHashMap（"),u("a",{attrs:{href:"https://juejin.im/post/6844903602423595015",target:"_blank",rel:"noopener noreferrer"}},[e._v("关于 ConcurrentHashMap 可以看这篇文章"),u("OutboundLink")],1),e._v("），实现 Queue 接口的 ConcurrentLinkedQueue（"),u("a",{attrs:{href:"https://juejin.im/post/6844903602427805704",target:"_blank",rel:"noopener noreferrer"}},[e._v("关于 ConcurrentLinkedQueue 可以看这篇文章"),u("OutboundLink")],1),e._v("）。")]),e._v(" "),u("p",[e._v('最常用的"'),u("strong",[e._v("生产者-消费者")]),e._v('"问题中，队列通常被视作线程间操作的数据容器，这样，可以对各个模块的业务功能进行解耦，生产者将“生产”出来的数据放置在数据容器中，而消费者仅仅只需要在“数据容器”中进行获取数据即可，这样生产者线程和消费者线程就能够进行解耦，只专注于自己的业务功能即可。阻塞队列（BlockingQueue）被广泛使用在“生产者-消费者”问题中，其原因是 BlockingQueue 提供了可阻塞的插入和移除的方法。'),u("strong",[e._v("当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。")])]),e._v(" "),u("h2",{attrs:{id:"_2-基本操作"}},[u("a",{staticClass:"header-anchor",attrs:{href:"#_2-基本操作"}},[e._v("#")]),e._v(" 2. 基本操作")]),e._v(" "),u("p",[e._v("BlockingQueue 基本操作总结如下（此图来源于 JAVA API 文档）：")]),e._v(" "),u("p",[e._v('![BlockingQueue基本操作.png](data:image/svg+xml;utf8,<?xml version="1.0"?>'),u("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",version:"1.1",width:"1240",height:"132"}}),e._v(")BlockingQueue基本操作.png")]),e._v(" "),u("p",[e._v("BlockingQueue 继承于 Queue 接口，因此，对数据元素的基本操作有：")]),e._v(" "),u("blockquote",[u("p",[e._v("插入元素")])]),e._v(" "),u("ol",[u("li",[e._v("add(E e) ：往队列插入数据，当队列满时，插入元素时会抛出 IllegalStateException 异常；")]),e._v(" "),u("li",[e._v("offer(E e)：当往队列插入数据时，插入成功返回"),u("code",[e._v("true")]),e._v("，否则则返回"),u("code",[e._v("false")]),e._v("。当队列满时不会抛出异常；")])]),e._v(" "),u("blockquote",[u("p",[e._v("删除元素")])]),e._v(" "),u("ol",[u("li",[e._v("remove(Object o)：从队列中删除数据，成功则返回"),u("code",[e._v("true")]),e._v("，否则为"),u("code",[e._v("false")])]),e._v(" "),u("li",[e._v("poll：删除数据，当队列为空时，返回 null；")])]),e._v(" "),u("blockquote",[u("p",[e._v("查看元素")])]),e._v(" "),u("ol",[u("li",[e._v("element：获取队头元素，如果队列为空时则抛出 NoSuchElementException 异常；")]),e._v(" "),u("li",[e._v("peek：获取队头元素，如果队列为空则抛出 NoSuchElementException 异常")])]),e._v(" "),u("p",[e._v("BlockingQueue 具有的特殊操作：")]),e._v(" "),u("blockquote",[u("p",[e._v("插入数据：")])]),e._v(" "),u("ol",[u("li",[e._v("put：当阻塞队列容量已经满时，往阻塞队列插入数据的线程会被阻塞，直至阻塞队列已经有空余的容量可供使用；")]),e._v(" "),u("li",[e._v("offer(E e, long timeout, TimeUnit unit)：若阻塞队列已经满时，同样会阻塞插入数据的线程，直至阻塞队列已经有空余的地方，与 put 方法不同的是，该方法会有一个超时时间，若超过当前给定的超时时间，插入数据的线程会退出；")])]),e._v(" "),u("blockquote",[u("p",[e._v("删除数据")])]),e._v(" "),u("ol",[u("li",[e._v("take()：当阻塞队列为空时，获取队头数据的线程会被阻塞；")]),e._v(" "),u("li",[e._v("poll(long timeout, TimeUnit unit)：当阻塞队列为空时，获取数据的线程会被阻塞，另外，如果被阻塞的线程超过了给定的时长，该线程会退出")])]),e._v(" "),u("h2",{attrs:{id:"_3-常用的-blockingqueue"}},[u("a",{staticClass:"header-anchor",attrs:{href:"#_3-常用的-blockingqueue"}},[e._v("#")]),e._v(" 3. 常用的 BlockingQueue")]),e._v(" "),u("p",[e._v("实现 BlockingQueue 接口的有"),u("code",[e._v("ArrayBlockingQueue, DelayQueue, LinkedBlockingDeque, LinkedBlockingQueue, LinkedTransferQueue, PriorityBlockingQueue, SynchronousQueue")]),e._v("，而这几种常见的阻塞队列也是在实际编程中会常用的，下面对这几种常见的阻塞队列进行说明：")]),e._v(" "),u("blockquote",[u("p",[e._v("1.ArrayBlockingQueue")])]),e._v(" "),u("p",[u("strong",[e._v("ArrayBlockingQueue")]),e._v("是由数组实现的有界阻塞队列。该队列命令元素 FIFO（先进先出）。因此，对头元素时队列中存在时间最长的数据元素，而对尾数据则是当前队列最新的数据元素。ArrayBlockingQueue 可作为“有界数据缓冲区”，生产者插入数据到队列容器中，并由消费者提取。ArrayBlockingQueue 一旦创建，容量不能改变。")]),e._v(" "),u("p",[e._v("当队列容量满时，尝试将元素放入队列将导致操作阻塞;尝试从一个空队列中取一个元素也会同样阻塞。")]),e._v(" "),u("p",[e._v("ArrayBlockingQueue 默认情况下不能保证线程访问队列的公平性，所谓公平性是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到 ArrayBlockingQueue。而非公平性则是指访问 ArrayBlockingQueue 的顺序不是遵守严格的时间顺序，有可能存在，一旦 ArrayBlockingQueue 可以被访问时，长时间阻塞的线程依然无法访问到 ArrayBlockingQueue。"),u("strong",[e._v("如果保证公平性，通常会降低吞吐量")]),e._v("。如果需要获得公平性的 ArrayBlockingQueue，可采用如下代码：")]),e._v(" "),u("div",{staticClass:"language- extra-class"},[u("pre",{pre:!0,attrs:{class:"language-text"}},[u("code",[e._v("private static ArrayBlockingQueue<Integer> blockingQueue = new ArrayBlockingQueue<Integer>(10,true);\n复制代码\n")])])]),u("p",[e._v("关于 ArrayBlockingQueue 的实现原理，可以"),u("a",{attrs:{href:"https://juejin.im/post/6844903602448760845",target:"_blank",rel:"noopener noreferrer"}},[e._v("看这篇文章"),u("OutboundLink")],1),e._v("。")]),e._v(" "),u("blockquote",[u("p",[e._v("2.LinkedBlockingQueue")])]),e._v(" "),u("p",[e._v("LinkedBlockingQueue 是用链表实现的有界阻塞队列，同样满足 FIFO 的特性，与 ArrayBlockingQueue 相比起来具有更高的吞吐量，为了防止 LinkedBlockingQueue 容量迅速增，损耗大量内存。通常在创建 LinkedBlockingQueue 对象时，会指定其大小，如果未指定，容量等于 Integer.MAX_VALUE")]),e._v(" "),u("blockquote",[u("p",[e._v("3.PriorityBlockingQueue")])]),e._v(" "),u("p",[e._v("PriorityBlockingQueue 是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现 compareTo()方法来指定元素排序规则，或者初始化时通过构造器参数 Comparator 来指定排序规则。")]),e._v(" "),u("blockquote",[u("p",[e._v("4.SynchronousQueue")])]),e._v(" "),u("p",[e._v("SynchronousQueue 每个插入操作必须等待另一个线程进行相应的删除操作，因此，SynchronousQueue 实际上没有存储任何数据元素，因为只有线程在删除数据时，其他线程才能插入数据，同样的，如果当前有线程在插入数据时，线程才能删除数据。SynchronousQueue 也可以通过构造器参数来为其指定公平性。")]),e._v(" "),u("blockquote",[u("p",[e._v("5.LinkedTransferQueue")])]),e._v(" "),u("p",[e._v("LinkedTransferQueue 是一个由链表数据结构构成的无界阻塞队列，由于该队列实现了 TransferQueue 接口，与其他阻塞队列相比主要有以下不同的方法：")]),e._v(" "),u("p",[u("strong",[e._v("transfer(E e)")]),e._v(" 如果当前有线程（消费者）正在调用 take()方法或者可延时的 poll()方法进行消费数据时，生产者线程可以调用 transfer 方法将数据传递给消费者线程。如果当前没有消费者线程的话，生产者线程就会将数据插入到队尾，直到有消费者能够进行消费才能退出；")]),e._v(" "),u("p",[u("strong",[e._v("tryTransfer(E e)")]),e._v(" tryTransfer 方法如果当前有消费者线程（调用 take 方法或者具有超时特性的 poll 方法）正在消费数据的话，该方法可以将数据立即传送给消费者线程，如果当前没有消费者线程消费数据的话，就立即返回"),u("code",[e._v("false")]),e._v("。因此，与 transfer 方法相比，transfer 方法是必须等到有消费者线程消费数据时，生产者线程才能够返回。而 tryTransfer 方法能够立即返回结果退出。")]),e._v(" "),u("p",[u("strong",[e._v("tryTransfer(E e,long timeout,imeUnit unit)")]),e._v("\n与 transfer 基本功能一样，只是增加了超时特性，如果数据才规定的超时时间内没有消费者进行消费的话，就返回"),u("code",[e._v("false")]),e._v("。")]),e._v(" "),u("blockquote",[u("p",[e._v("6.LinkedBlockingDeque")])]),e._v(" "),u("p",[e._v("LinkedBlockingDeque 是基于链表数据结构的有界阻塞双端队列，如果在创建对象时为指定大小时，其默认大小为 Integer.MAX_VALUE。与 LinkedBlockingQueue 相比，主要的不同点在于，LinkedBlockingDeque 具有双端队列的特性。LinkedBlockingDeque 基本操作如下图所示（来源于 java 文档）")]),e._v(" "),u("p",[e._v('![LinkedBlockingDeque的基本操作.png](data:image/svg+xml;utf8,<?xml version="1.0"?>'),u("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",version:"1.1",width:"600",height:"263"}}),e._v(")LinkedBlockingDeque的基本操作.png")]),e._v(" "),u("p",[e._v("如上图所示，LinkedBlockingDeque 的基本操作可以分为四种类型：1.特殊情况，抛出异常；2.特殊情况，返回特殊值如 null 或者 false；3.当线程不满足操作条件时，线程会被阻塞直至条件满足；4. 操作具有超时特性。")]),e._v(" "),u("p",[e._v("另外，LinkedBlockingDeque 实现了 BlockingDueue 接口而 LinkedBlockingQueue 实现的是 BlockingQueue，这两个接口的主要区别如下图所示（来源于 java 文档）：")]),e._v(" "),u("p",[u("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/5/6/163349267d5efe67?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:"BlockingQueue和BlockingDeque的区别.png"}}),e._v("BlockingQueue和BlockingDeque的区别.png")]),e._v(" "),u("p",[e._v("从上图可以看出，两个接口的功能是可以等价使用的，比如 BlockingQueue 的 add 方法和 BlockingDeque 的 addLast 方法的功能是一样的。")]),e._v(" "),u("blockquote",[u("p",[e._v("7.DelayQueue")])]),e._v(" "),u("p",[e._v("DelayQueue 是一个存放实现 Delayed 接口的数据的无界阻塞队列，只有当数据对象的延时时间达到时才能插入到队列进行存储。如果当前所有的数据都还没有达到创建时所指定的延时期，则队列没有队头，并且线程通过 poll 等方法获取数据元素则返回 null。所谓数据延时期满时，则是通过 Delayed 接口的"),u("code",[e._v("getDelay(TimeUnit.NANOSECONDS)")]),e._v("来进行判定，如果该方法返回的是小于等于 0 则说明该数据元素的延时期已满。")]),e._v(" "),u("p",[e._v("来源于 https://juejin.cn/post/6844903602444582920")])])}),[],!1,null,null,null);n.default=r.exports}}]);