(window.webpackJsonp=window.webpackJsonp||[]).push([[87],{516:function(a,t,s){"use strict";s.r(t);var r=s(30),e=Object(r.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"java-面试题-二-的51-80题答案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java-面试题-二-的51-80题答案"}},[a._v("#")]),a._v(" Java 面试题（二）的51~80题答案")]),a._v(" "),s("h3",{attrs:{id:"_51、arraylist-与-linkedlist-的不区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_51、arraylist-与-linkedlist-的不区别"}},[a._v("#")]),a._v(" 51、ArrayList 与 LinkedList 的不区别？")]),a._v(" "),s("p",[a._v("最明显的区别是 ArrrayList 底层的数据结构是数组，支持随机访问，而LinkedList 的底层数据结构书链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。")]),a._v(" "),s("h3",{attrs:{id:"_52、用哪两种方式来实现集合的排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_52、用哪两种方式来实现集合的排序"}},[a._v("#")]),a._v(" 52、用哪两种方式来实现集合的排序？")]),a._v(" "),s("p",[a._v("你可以使用有序集合，如 TreeSet 或 TreeMap，你也可以使用有顺序的的集合，如 list，然后通过 Collections.sort() 来排序。")]),a._v(" "),s("h3",{attrs:{id:"_53、java-中怎么打印数组"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_53、java-中怎么打印数组"}},[a._v("#")]),a._v(" 53、Java 中怎么打印数组？")]),a._v(" "),s("p",[a._v("你可以使用 Arrays.toString() 和 Arrays.deepToString() 方法来打印数组。由于数组没有实现 toString() 方法，所以如果将数组传递给 System.out.println()方法，将无法打印出数组的内容，但是 Arrays.toString() 可以打印每个元素。")]),a._v(" "),s("h3",{attrs:{id:"_54、java-中的-linkedlist-是单向链表还是双向链表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_54、java-中的-linkedlist-是单向链表还是双向链表"}},[a._v("#")]),a._v(" 54、Java 中的 LinkedList 是单向链表还是双向链表？")]),a._v(" "),s("p",[a._v("是双向链表，你可以检查 JDK 的源码。在 Eclipse，你可以使用快捷键 Ctrl + T，直接在编辑器中打开该类。")]),a._v(" "),s("h3",{attrs:{id:"_55、java-中的-treemap-是采用什么树实现的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_55、java-中的-treemap-是采用什么树实现的"}},[a._v("#")]),a._v(" 55、Java 中的 TreeMap 是采用什么树实现的？")]),a._v(" "),s("p",[a._v("Java 中的 TreeMap 是使用红黑树实现的。")]),a._v(" "),s("h3",{attrs:{id:"_56、hashtable-与-hashmap-有什么不同之处"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_56、hashtable-与-hashmap-有什么不同之处"}},[a._v("#")]),a._v(" 56、Hashtable 与 HashMap 有什么不同之处？")]),a._v(" "),s("p",[a._v("这两个类有许多不同的地方，下面列出了一部分：")]),a._v(" "),s("p",[a._v("a) Hashtable 是 JDK 1 遗留下来的类，而 HashMap 是后来增加的。")]),a._v(" "),s("p",[a._v("b）Hashtable 是同步的，比较慢，但 HashMap 没有同步策略，所以会更快。")]),a._v(" "),s("p",[a._v("c）Hashtable 不允许有个空的 key，但是 HashMap 允许出现一个 null key。")]),a._v(" "),s("h3",{attrs:{id:"_57、java-中的-hashset-内部是如何工作的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_57、java-中的-hashset-内部是如何工作的"}},[a._v("#")]),a._v(" 57、Java 中的 HashSet，内部是如何工作的？")]),a._v(" "),s("p",[a._v("HashSet 的内部采用 HashMap 来实现。由于 Map 需要 key 和 value，所以所有 key 的都有一个默认 value。类似于 HashMap，HashSet 不允许重复的key，只允许有一个 null key，意思就是 HashSet 中只允许存储一个 null 对象。")]),a._v(" "),s("h3",{attrs:{id:"_58、写一段代码在遍历-arraylist-时移除一个元素"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_58、写一段代码在遍历-arraylist-时移除一个元素"}},[a._v("#")]),a._v(" 58、写一段代码在遍历 ArrayList 时移除一个元素？")]),a._v(" "),s("p",[a._v("该问题的关键在于面试者使用的是 ArrayList 的 remove() 还是 Iterator 的remove()方法。这有一段示例代码，是使用正确的方式来实现在遍历的过程中移除元素，而不会出现 ConcurrentModificationException 异常的示例代码。")]),a._v(" "),s("h3",{attrs:{id:"_59、我们能自己写一个容器类-然后使用-for-each-循环码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_59、我们能自己写一个容器类-然后使用-for-each-循环码"}},[a._v("#")]),a._v(" 59、我们能自己写一个容器类，然后使用 for-each 循环码？")]),a._v(" "),s("p",[a._v("可以，你可以写一个自己的容器类。如果你想使用 Java 中增强的循环来遍历，你只需要实现 Iterable 接口。如果你实现 Collection 接口，默认就具有该属性。")]),a._v(" "),s("h3",{attrs:{id:"_60、arraylist-和-hashmap-的默认大小是多数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_60、arraylist-和-hashmap-的默认大小是多数"}},[a._v("#")]),a._v(" 60、ArrayList 和 HashMap 的默认大小是多数？")]),a._v(" "),s("p",[a._v("在 Java 7 中，ArrayList 的默认大小是 10 个元素，HashMap 的默认大小是16 个元素（必须是 2 的幂）。这就是 Java 7 中 ArrayList 和 HashMap 类的代码片段：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("// from ArrayList.java JDK 1.7\nprivate static final int DEFAULT_CAPACITY = 10;\n//from HashMap.java JDK 7\nstatic final int DEFAULT_INITIAL_CAPACITY = 1 << 4;\n// aka 16\n")])])]),s("h3",{attrs:{id:"_61、有没有可能两个不相等的对象有有相同的-hashcode"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_61、有没有可能两个不相等的对象有有相同的-hashcode"}},[a._v("#")]),a._v(" 61、有没有可能两个不相等的对象有有相同的 hashcode？")]),a._v(" "),s("p",[a._v("有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在hashmap 中会有冲突。相等 hashcode 值的规定只是说如果两个对象相等，必须有相同的 hashcode 值，但是没有关于不相等对象的任何规定。")]),a._v(" "),s("h3",{attrs:{id:"_62、两个相同的对象会有不同的的-hash-code-吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_62、两个相同的对象会有不同的的-hash-code-吗"}},[a._v("#")]),a._v(" 62、两个相同的对象会有不同的的 hash code 吗？")]),a._v(" "),s("p",[a._v("不能，根据 hash code 的规定，这是不可能的。")]),a._v(" "),s("h3",{attrs:{id:"_63、我们可以在-hashcode-中使用随机数字吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_63、我们可以在-hashcode-中使用随机数字吗"}},[a._v("#")]),a._v(" 63、我们可以在 hashcode() 中使用随机数字吗？")]),a._v(" "),s("p",[a._v("不行，因为对象的 hashcode 值必须是相同的。参见答案获取更多关于 Java 中重写 hashCode() 方法的知识。")]),a._v(" "),s("h3",{attrs:{id:"_64、java-中-comparator-与-comparable-有什么不同"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_64、java-中-comparator-与-comparable-有什么不同"}},[a._v("#")]),a._v(" 64、Java 中，Comparator 与 Comparable 有什么不同？")]),a._v(" "),s("p",[a._v("Comparable 接口用于定义对象的自然顺序，而 comparator 通常用于定义用户定制的顺序。Comparable 总是只有一个，但是可以有多个 comparator 来定义对象的顺序。")]),a._v(" "),s("h3",{attrs:{id:"_65、为什么在重写-equals-方法的时候需要重写-hashcode-方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_65、为什么在重写-equals-方法的时候需要重写-hashcode-方法"}},[a._v("#")]),a._v(" 65、为什么在重写 equals 方法的时候需要重写 hashCode 方法？")]),a._v(" "),s("p",[a._v("因为有强制的规范指定需要同时重写 hashcode 与 equal 是方法，许多容器类，如 HashMap、HashSet 都依赖于 hashcode 与 equals 的规定。")]),a._v(" "),s("h3",{attrs:{id:"_66、在我-java-程序中-我有三个-socket-我需要多少个线程来处理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_66、在我-java-程序中-我有三个-socket-我需要多少个线程来处理"}},[a._v("#")]),a._v(" 66、在我 Java 程序中，我有三个 socket，我需要多少个线程来处理？")]),a._v(" "),s("p",[a._v("这个需要看你是并行处理还是串行处理了。")]),a._v(" "),s("h3",{attrs:{id:"_67、java-中怎么创建-bytebuffer"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_67、java-中怎么创建-bytebuffer"}},[a._v("#")]),a._v(" 67、Java 中怎么创建 ByteBuffer？")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("byte[] bytes = new byte[10];\nByteBuffer buf = ByteBuffer.wrap(bytes);\n")])])]),s("h3",{attrs:{id:"_68、java-中-怎么读写-bytebuffer"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_68、java-中-怎么读写-bytebuffer"}},[a._v("#")]),a._v(" 68、Java 中，怎么读写 ByteBuffer ？")]),a._v(" "),s("h3",{attrs:{id:"_69、java-采用的是大端还是小端"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_69、java-采用的是大端还是小端"}},[a._v("#")]),a._v(" 69、Java 采用的是大端还是小端？")]),a._v(" "),s("h3",{attrs:{id:"_70、bytebuffer-中的字节序是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_70、bytebuffer-中的字节序是什么"}},[a._v("#")]),a._v(" 70、ByteBuffer 中的字节序是什么？")]),a._v(" "),s("h3",{attrs:{id:"_71、java-中-直接缓冲区与非直接缓冲器有什么区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_71、java-中-直接缓冲区与非直接缓冲器有什么区别"}},[a._v("#")]),a._v(" 71、Java 中，直接缓冲区与非直接缓冲器有什么区别？")]),a._v(" "),s("h3",{attrs:{id:"_72、java-中的内存映射缓存区是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_72、java-中的内存映射缓存区是什么"}},[a._v("#")]),a._v(" 72、Java 中的内存映射缓存区是什么？")]),a._v(" "),s("h3",{attrs:{id:"_73、socket-选项-tcp-no-delay-是指什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_73、socket-选项-tcp-no-delay-是指什么"}},[a._v("#")]),a._v(" 73、socket 选项 TCP NO DELAY 是指什么？")]),a._v(" "),s("h3",{attrs:{id:"_74、tcp-协议与-udp-协议有什么区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_74、tcp-协议与-udp-协议有什么区别"}},[a._v("#")]),a._v(" 74、TCP 协议与 UDP 协议有什么区别？")]),a._v(" "),s("h3",{attrs:{id:"_75、java-中-bytebuffer-与-stringbuffer-有什么区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_75、java-中-bytebuffer-与-stringbuffer-有什么区别"}},[a._v("#")]),a._v(" 75、Java 中，ByteBuffer 与 StringBuffer 有什么区别？")]),a._v(" "),s("h3",{attrs:{id:"_76、java-中-编写多线程程序的时候你会遵循哪些最佳实践"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_76、java-中-编写多线程程序的时候你会遵循哪些最佳实践"}},[a._v("#")]),a._v(" 76、Java 中，编写多线程程序的时候你会遵循哪些最佳实践？")]),a._v(" "),s("p",[a._v("a）给线程命名，这样可以帮助调试。")]),a._v(" "),s("p",[a._v("b）最小化同步的范围，而不是将整个方法同步，只对关键部分做同步。")]),a._v(" "),s("p",[a._v("c）如果可以，更偏向于使用 volatile 而不是 synchronized。")]),a._v(" "),s("p",[a._v("d）使用更高层次的并发工具，而不是使用 wait() 和 notify() 来实现线程间通信，如 BlockingQueue，CountDownLatch 及 Semeaphore。")]),a._v(" "),s("p",[a._v("e）优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。")]),a._v(" "),s("h3",{attrs:{id:"_77、说出几点-java-中使用-collections-的最佳实践"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_77、说出几点-java-中使用-collections-的最佳实践"}},[a._v("#")]),a._v(" 77、说出几点 Java 中使用 Collections 的最佳实践")]),a._v(" "),s("p",[a._v("a）使用正确的集合类，例如，如果不需要同步列表，使用 ArrayList 而不是Vector。")]),a._v(" "),s("p",[a._v("b）优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。")]),a._v(" "),s("p",[a._v("c）使用接口代表和访问集合，如使用 List 存储 ArrayList，使用 Map 存储HashMap 等等。")]),a._v(" "),s("p",[a._v("d）使用迭代器来循环集合。")]),a._v(" "),s("p",[a._v("e）使用集合的时候使用泛型。")]),a._v(" "),s("h3",{attrs:{id:"_78、说出至少-5-点在-java-中使用线程的最佳实践。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_78、说出至少-5-点在-java-中使用线程的最佳实践。"}},[a._v("#")]),a._v(" 78、说出至少 5 点在 Java 中使用线程的最佳实践。")]),a._v(" "),s("p",[a._v("这个问题与之前的问题类似，你可以使用上面的答案。对线程来说，你应该：")]),a._v(" "),s("p",[a._v("a）对线程命名")]),a._v(" "),s("p",[a._v("b）将线程和任务分离，使用线程池执行器来执行 Runnable 或 Callable。")]),a._v(" "),s("p",[a._v("c）使用线程池")]),a._v(" "),s("h3",{attrs:{id:"_79、说出-5-条-io-的最佳实践"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_79、说出-5-条-io-的最佳实践"}},[a._v("#")]),a._v(" 79、说出 5 条 IO 的最佳实践")]),a._v(" "),s("p",[a._v("IO 对 Java 应用的性能非常重要。理想情况下，你不应该在你应用的关键路径上避免 IO 操作。下面是一些你应该遵循的 Java IO 最佳实践：")]),a._v(" "),s("p",[a._v("a）使用有缓冲区的 IO 类，而不要单独读取字节或字符。")]),a._v(" "),s("p",[a._v("b）使用 NIO 和 NIO2")]),a._v(" "),s("p",[a._v("c）在 finally 块中关闭流，或者使用 try-with-resource 语句。")]),a._v(" "),s("p",[a._v("d）使用内存映射文件获取更快的 IO。")]),a._v(" "),s("h3",{attrs:{id:"_80、列出-5-个应该遵循的-jdbc-最佳实践"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_80、列出-5-个应该遵循的-jdbc-最佳实践"}},[a._v("#")]),a._v(" 80、列出 5 个应该遵循的 JDBC 最佳实践")]),a._v(" "),s("p",[a._v("有很多的最佳实践，你可以根据你的喜好来例举。下面是一些更通用的原则：")]),a._v(" "),s("p",[a._v("a）使用批量的操作来插入和更新数据")]),a._v(" "),s("p",[a._v("b）使用 PreparedStatement 来避免 SQL 异常，并提高性能。")]),a._v(" "),s("p",[a._v("c）使用数据库连接池")]),a._v(" "),s("p",[a._v("d）通过列名来获取结果集，不要使用列的下标来获取。")])])}),[],!1,null,null,null);t.default=e.exports}}]);