(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{438:function(e,n,r){"use strict";r.r(n);var t=r(30),a=Object(t.a)({},(function(){var e=this,n=e.$createElement,r=e._self._c||n;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"dubbo-源码分析-服务导出"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#dubbo-源码分析-服务导出"}},[e._v("#")]),e._v(" Dubbo 源码分析 - 服务导出")]),e._v(" "),r("h2",{attrs:{id:"_1-服务导出过程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-服务导出过程"}},[e._v("#")]),e._v(" 1.服务导出过程")]),e._v(" "),r("p",[e._v("本篇文章，我们来研究一下 Dubbo 导出服务的过程。Dubbo 服务导出过程始于 Spring 容器发布刷新事件，Dubbo 在接收到事件后，会立即执行服务导出逻辑。整个逻辑大致可分为三个部分，第一是前置工作，主要用于检查参数，组装 URL。第二是导出服务，包含导出服务到本地 (JVM)，和导出服务到远程两个过程。第三是向注册中心注册服务，用于服务发现。本篇文章将会对这三个部分代码进行详细的分析，在分析之前，我们先来了解一下服务的导出过程。")]),e._v(" "),r("p",[e._v("Dubbo 支持两种服务导出方式，分别延迟导出和立即导出。延迟导出的入口是 ServiceBean 的 afterPropertiesSet 方法，立即导出的入口是 ServiceBean 的 onApplicationEvent 方法。本文打算分析服务延迟导出过程，因此不会分析 afterPropertiesSet 方法。下面从 onApplicationEvent 方法说起，该方法收到 Spring 容器的刷新事件后，会调用 export 方法执行服务导出操作。服务导出之前，要进行对一系列的配置进行检查，以及生成 URL。准备工作做完，随后开始导出服务。首先导出到本地，然后再导出到远程。导出到本地就是将服务导出到 JVM 中，此过程比较简单。导出到远程的过程则要复杂的多，以 dubbo 协议为例，DubboProtocol 类的 export 方法将会被调用。该方法主要用于创建 Exporter 和 ExchangeServer。ExchangeServer 本身并不具备通信能力，需要借助更底层的 Server 实现通信功能。因此，在创建 ExchangeServer 实例时，需要先创建 NettyServer 或者 MinaServer 实例，并将实例作为参数传给 ExchangeServer 实现类的构造方法。ExchangeServer 实例创建完成后，导出服务到远程的过程也就接近尾声了。服务导出结束后，服务消费者即可通过直联的方式消费服务。当然，一般我们不会使用直联的方式消费服务。所以，在服务导出结束后，紧接着要做的事情是向注册中心注册服务。此时，客户端即可从注册中心发现服务。")]),e._v(" "),r("p",[e._v("以上就是 Dubbo 服务导出的过程，比较复杂。下面开始分析源码，从源码的角度展现整个过程。")]),e._v(" "),r("h2",{attrs:{id:"_2-源码分析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-源码分析"}},[e._v("#")]),e._v(" 2.源码分析")]),e._v(" "),r("p",[e._v("一场 Dubbo 源码分析的马拉松比赛即将开始，现在我们站在赛道的起点进行热身准备。本次比赛的起点位置位于 ServiceBean 的 onApplicationEvent 方法处。好了，发令枪响了，我将和一些朋友从 onApplicationEvent 方法处出发，探索 Dubbo 服务导出的全过程。下面我们来看一下 onApplicationEvent 方法的源码。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("public void onApplicationEvent(ContextRefreshedEvent event) {\n    // 是否有延迟导出 && 是否已导出 && 是不是已被取消导出\n    if (isDelay() && !isExported() && !isUnexported()) {\n        // 导出服务\n        export();\n    }\n}\n")])])]),r("p",[e._v("onApplicationEvent 是一个事件响应方法，该方法会在收到 Spring 上下文刷新事件后执行。这个方法首先会根据条件决定是否导出服务，比如有些服务设置了延时导出，那么此时就不应该在此处导出。还有一些服务已经被导出了，或者当前服务被取消导出了，此时也不能再次导出相关服务。注意这里的 isDelay 方法，这个方法字面意思是“是否延迟导出服务”，返回 true 表示延迟导出，false 表示不延迟导出。但是该方法真实意思却并非如此，当方法返回 true 时，表示无需延迟导出。返回 false 时，表示需要延迟导出。与字面意思恰恰相反，让人觉得很奇怪。下面我们来看一下这个方法的逻辑。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// -☆- ServiceBean\nprivate boolean isDelay() {\n    // 获取 delay\n    Integer delay = getDelay();\n    ProviderConfig provider = getProvider();\n    if (delay == null && provider != null) {\n        // 如果前面获取的 delay 为空，这里继续获取\n        delay = provider.getDelay();\n    }\n    // 判断 delay 是否为空，或者等于 -1\n    return supportedApplicationListener && (delay == null || delay == -1);\n}\n")])])]),r("p",[e._v("暂时忽略 supportedApplicationListener 这个条件，当 delay 为空，或者等于-1时，该方法返回 true，而不是 false。这个方法的返回值让人有点困惑，因此我重构了该方法的代码，并给 Dubbo 提了一个 Pull Request，最终这个 PR 被合到了 Dubbo 主分支中。详细请参见 "),r("a",{attrs:{href:"https://github.com/apache/incubator-dubbo/pull/2686",target:"_blank",rel:"noopener noreferrer"}},[e._v("Dubbo #2686"),r("OutboundLink")],1),e._v("。")]),e._v(" "),r("p",[e._v("现在解释一下 supportedApplicationListener 变量含义，该变量用于表示当前的 Spring 容器是否支持 ApplicationListener，这个值初始为 false。在 Spring 容器将自己设置到 ServiceBean 中时，ServiceBean 的 setApplicationContext 方法会检测 Spring 容器是否支持 ApplicationListener。若支持，则将 supportedApplicationListener 置为 true。代码就不分析了，大家自行查阅了解。")]),e._v(" "),r("p",[e._v("ServiceBean 是 Dubbo 与 Spring 框架进行整合的关键，可以看做是两个框架之间的桥梁。具有同样作用的类还有 ReferenceBean。ServiceBean 实现了 Spring 的一些拓展接口，有 FactoryBean、ApplicationContextAware、ApplicationListener、DisposableBean 和 BeanNameAware。这些接口我在 "),r("a",{attrs:{href:"https://www.tianxiaobo.com/2018/05/30/Spring-IOC-%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E5%AF%BC%E8%AF%BB/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Spring 源码分析系列"),r("OutboundLink")],1),e._v("文章中介绍过，大家可以参考一下，这里就不赘述了。")]),e._v(" "),r("p",[e._v("现在我们知道了 Dubbo 服务导出过程的起点。那么接下来，我们快马加鞭，继续进行比赛。赛程预告，下一站是“服务导出的前置工作”。")]),e._v(" "),r("h3",{attrs:{id:"_2-1-前置工作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-前置工作"}},[e._v("#")]),e._v(" 2.1 前置工作")]),e._v(" "),r("p",[e._v("前置工作主要包含两个部分，分别是配置检查，以及 URL 装配。在导出服务之前，Dubbo 需要检查用户的配置是否合理，或者为用户补充缺省配置。配置检查完成后，接下来需要根据这些配置组装 URL。在 Dubbo 中，URL 的作用十分重要。Dubbo 使用 URL 作为配置载体，所有的拓展点都是通过 URL 获取配置。这一点，官方文档中有所说明。")]),e._v(" "),r("blockquote",[r("p",[e._v("采用 URL 作为配置信息的统一格式，所有扩展点都通过传递 URL 携带配置信息。")])]),e._v(" "),r("p",[e._v("接下来，我们先来分析配置检查部分的源码，随后再来分析 URL 组装部分的源码。")]),e._v(" "),r("h4",{attrs:{id:"_2-1-1-检查配置"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-1-检查配置"}},[e._v("#")]),e._v(" 2.1.1 检查配置")]),e._v(" "),r("p",[e._v("本节我们接着前面的源码向下分析，前面说过 onApplicationEvent 方法在经过一些判断后，会决定是否调用 export 方法导出服务。那么下面我们从 export 方法开始进行分析，如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("public synchronized void export() {\n    if (provider != null) {\n        // 获取 export 和 delay 配置\n        if (export == null) {\n            export = provider.getExport();\n        }\n        if (delay == null) {\n            delay = provider.getDelay();\n        }\n    }\n    // 如果 export 为 false，则不导出服务\n    if (export != null && !export) {\n        return;\n    }\n\n    if (delay != null && delay > 0) {    // delay > 0，延时导出服务\n        delayExportExecutor.schedule(new Runnable() {\n            @Override\n            public void run() {\n                doExport();\n            }\n        }, delay, TimeUnit.MILLISECONDS);\n    } else {    // 立即导出服务\n        doExport();\n    }\n}\n")])])]),r("p",[e._v("export 对两个配置进行了检查，并配置执行相应的动作。首先是 export，这个配置决定了是否导出服务。有时候我们只是想本地启动服务进行一些调试工作，这个时候我们并不希望把本地启动的服务暴露出去给别人调用。此时，我们就可以通过配置 export 禁止服务导出，比如：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('<dubbo:provider export="false" />\n')])])]),r("p",[e._v("delay 见名知意了，用于延迟导出服务。下面，我们继续分析源码，这次要分析的是 doExport 方法。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('protected synchronized void doExport() {\n    if (unexported) {\n        throw new IllegalStateException("Already unexported!");\n    }\n    if (exported) {\n        return;\n    }\n    exported = true;\n    // 检测 interfaceName 是否合法\n    if (interfaceName == null || interfaceName.length() == 0) {\n        throw new IllegalStateException("interface not allow null!");\n    }\n    // 检测 provider 是否为空，为空则新建一个，并通过系统变量为其初始化\n    checkDefault();\n\n    // 下面几个 if 语句用于检测 provider、application 等核心配置类对象是否为空，\n    // 若为空，则尝试从其他配置类对象中获取相应的实例。\n    if (provider != null) {\n        if (application == null) {\n            application = provider.getApplication();\n        }\n        if (module == null) {\n            module = provider.getModule();\n        }\n        if (registries == null) {...}\n        if (monitor == null) {...}\n        if (protocols == null) {...}\n    }\n    if (module != null) {\n        if (registries == null) {\n            registries = module.getRegistries();\n        }\n        if (monitor == null) {...}\n    }\n    if (application != null) {\n        if (registries == null) {\n            registries = application.getRegistries();\n        }\n        if (monitor == null) {...}\n    }\n\n    // 检测 ref 是否泛化服务类型\n    if (ref instanceof GenericService) {\n        // 设置 interfaceClass 为 GenericService.class\n        interfaceClass = GenericService.class;\n        if (StringUtils.isEmpty(generic)) {\n            // 设置 generic = "true"\n            generic = Boolean.TRUE.toString();\n        }\n    } else {    // ref 非 GenericService 类型\n        try {\n            interfaceClass = Class.forName(interfaceName, true, Thread.currentThread()\n                    .getContextClassLoader());\n        } catch (ClassNotFoundException e) {\n            throw new IllegalStateException(e.getMessage(), e);\n        }\n        // 对 interfaceClass，以及 <dubbo:method> 必要字段进行检查\n        checkInterfaceAndMethods(interfaceClass, methods);\n        // 对 ref 合法性进行检测\n        checkRef();\n        // 设置 generic = "false"\n        generic = Boolean.FALSE.toString();\n    }\n\n    // local 属性 Dubbo 官方文档中没有说明，不过 local 和 stub 在功能应该是一致的，用于配置本地存根\n    if (local != null) {\n        if ("true".equals(local)) {\n            local = interfaceName + "Local";\n        }\n        Class<?> localClass;\n        try {\n            // 获取本地存根类\n            localClass = ClassHelper.forNameWithThreadContextClassLoader(local);\n        } catch (ClassNotFoundException e) {\n            throw new IllegalStateException(e.getMessage(), e);\n        }\n        // 检测本地存根类是否可赋值给接口类，若不可赋值则会抛出异常，提醒使用者本地存根类类型不合法\n        if (!interfaceClass.isAssignableFrom(localClass)) {\n            throw new IllegalStateException("The local implementation class " + localClass.getName() + " not implement interface " + interfaceName);\n        }\n    }\n\n    // stub 和 local 均用于配置本地存根\n    if (stub != null) {\n        // 此处的代码和上一个 if 分支的代码基本一致，这里省略了\n    }\n\n    // 检测各种对象是否为空，为空则新建，或者抛出异常\n    checkApplication();\n    checkRegistry();\n    checkProtocol();\n    appendProperties(this);\n    checkStubAndMock(interfaceClass);\n    if (path == null || path.length() == 0) {\n        path = interfaceName;\n    }\n\n    // 导出服务\n    doExportUrls();\n\n    // ProviderModel 表示服务提供者模型，此对象中存储了和服务提供者相关的信息。\n    // 比如服务的配置信息，服务实例等。每个被导出的服务对应一个 ProviderModel。\n    // ApplicationModel 持有所有的 ProviderModel。\n    ProviderModel providerModel = new ProviderModel(getUniqueServiceName(), this, ref);\n    ApplicationModel.initProviderModel(getUniqueServiceName(), providerModel);\n}\n')])])]),r("p",[e._v("以上就是配置检查的相关分析，代码比较多，需要大家耐心看一下。下面对配置检查的逻辑进行简单的总结，如下：")]),e._v(" "),r("ol",[r("li",[e._v("检测 "),r("a",{attrs:{href:"dubbo:service"}},[e._v("dubbo:service")]),e._v(" 标签的 interface 属性合法性，不合法则抛出异常")]),e._v(" "),r("li",[e._v("检测 ProviderConfig、ApplicationConfig 等核心配置类对象是否为空，若为空，则尝试从其他配置类对象中获取相应的实例。")]),e._v(" "),r("li",[e._v("检测并处理泛化服务和普通服务类")]),e._v(" "),r("li",[e._v("检测本地存根配置，并进行相应的处理")]),e._v(" "),r("li",[e._v("对 ApplicationConfig、RegistryConfig 等配置类进行检测，为空则尝试创建，若无法创建则抛出异常")])]),e._v(" "),r("p",[e._v("配置检查并非本文重点，因此我不打算对 doExport 方法所调用的方法进行分析（doExportUrls 方法除外）。在这些方法中，除了 appendProperties 方法稍微复杂一些，其他方法都还好。因此，大家可自行进行分析。好了，其他的就不多说了，继续向下分析。")]),e._v(" "),r("h4",{attrs:{id:"_2-1-2-多协议多注册中心导出服务"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-2-多协议多注册中心导出服务"}},[e._v("#")]),e._v(" 2.1.2 多协议多注册中心导出服务")]),e._v(" "),r("p",[e._v("Dubbo 允许我们使用不同的协议导出服务，也允许我们向多个注册中心注册服务。Dubbo 在 doExportUrls 方法中对多协议，多注册中心进行了支持。相关代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("private void doExportUrls() {\n    // 加载注册中心链接\n    List<URL> registryURLs = loadRegistries(true);\n    // 遍历 protocols，导出每个服务\n    for (ProtocolConfig protocolConfig : protocols) {\n        doExportUrlsFor1Protocol(protocolConfig, registryURLs);\n    }\n}\n")])])]),r("p",[e._v("上面代码比较简单，首先是通过 loadRegistries 加载注册中心链接，然后再遍历 ProtocolConfig 集合导出每个服务。并在导出服务的过程中，将服务注册到注册中心处。下面，我们先来看一下 loadRegistries 方法的逻辑。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('protected List<URL> loadRegistries(boolean provider) {\n    // 检测是否存在注册中心配置类，不存在则抛出异常\n    checkRegistry();\n    List<URL> registryList = new ArrayList<URL>();\n    if (registries != null && !registries.isEmpty()) {\n        for (RegistryConfig config : registries) {\n            String address = config.getAddress();\n            if (address == null || address.length() == 0) {\n                // 若 address 为空，则将其设为 0.0.0.0\n                address = Constants.ANYHOST_VALUE;\n            }\n\n            // 从系统属性中加载注册中心地址\n            String sysaddress = System.getProperty("dubbo.registry.address");\n            if (sysaddress != null && sysaddress.length() > 0) {\n                address = sysaddress;\n            }\n            // 判断 address 是否合法\n            if (address.length() > 0 && !RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(address)) {\n                Map<String, String> map = new HashMap<String, String>();\n                // 添加 ApplicationConfig 中的字段信息到 map 中\n                appendParameters(map, application);\n                // 添加 RegistryConfig 字段信息到 map 中\n                appendParameters(map, config);\n                map.put("path", RegistryService.class.getName());\n                map.put("dubbo", Version.getProtocolVersion());\n                map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));\n                if (ConfigUtils.getPid() > 0) {\n                    map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));\n                }\n                if (!map.containsKey("protocol")) {\n                    if (ExtensionLoader.getExtensionLoader(RegistryFactory.class).hasExtension("remote")) {\n                        map.put("protocol", "remote");\n                    } else {\n                        map.put("protocol", "dubbo");\n                    }\n                }\n\n                // 解析得到 URL 列表，address 可能包含多个注册中心 ip，\n                // 因此解析得到的是一个 URL 列表\n                List<URL> urls = UrlUtils.parseURLs(address, map);\n                for (URL url : urls) {\n                    url = url.addParameter(Constants.REGISTRY_KEY, url.getProtocol());\n                    // 将 URL 协议头设置为 registry\n                    url = url.setProtocol(Constants.REGISTRY_PROTOCOL);\n                    // 通过判断条件，决定是否添加 url 到 registryList 中，条件如下：\n                    // (服务提供者 && register = true 或 null) \n                    //    || (非服务提供者 && subscribe = true 或 null)\n                    if ((provider && url.getParameter(Constants.REGISTER_KEY, true))\n                            || (!provider && url.getParameter(Constants.SUBSCRIBE_KEY, true))) {\n                        registryList.add(url);\n                    }\n                }\n            }\n        }\n    }\n    return registryList;\n}\n')])])]),r("p",[e._v("上面代码不是很复杂，包含如下逻辑：")]),e._v(" "),r("ol",[r("li",[e._v("检测是否存在注册中心配置类，不存在则抛出异常")]),e._v(" "),r("li",[e._v("构建参数映射集合，也就是 map")]),e._v(" "),r("li",[e._v("构建注册中心链接列表")]),e._v(" "),r("li",[e._v("遍历链接列表，并根据条件决定是否将其添加到 registryList 中")])]),e._v(" "),r("p",[e._v("关于多协议多注册中心导出服务就先分析到这，代码不是很多，就不过多叙述了。接下来分析 URL 组装过程。")]),e._v(" "),r("h4",{attrs:{id:"_2-1-3-组装-url"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-3-组装-url"}},[e._v("#")]),e._v(" 2.1.3 组装 URL")]),e._v(" "),r("p",[e._v("配置检查完毕后，紧接着要做的事情是根据配置，以及其他一些信息组装 URL。前面说过，URL 是 Dubbo 配置的载体，通过 URL 可让 Dubbo 的各种配置在各个模块之间传递。URL 之于 Dubbo，犹如水之于鱼，非常重要。大家在阅读 Dubbo 服务导出相关源码的过程中，要注意 URL 内容的变化。既然 URL 如此重要，那么下面我们来了解一下 URL 组装的过程。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List<URL> registryURLs) {\n    String name = protocolConfig.getName();\n    // 如果协议名为空，或空串，则将协议名变量设置为 dubbo\n    if (name == null || name.length() == 0) {\n        name = "dubbo";\n    }\n\n    Map<String, String> map = new HashMap<String, String>();\n    // 添加 side、版本、时间戳以及进程号等信息到 map 中\n    map.put(Constants.SIDE_KEY, Constants.PROVIDER_SIDE);\n    map.put(Constants.DUBBO_VERSION_KEY, Version.getProtocolVersion());\n    map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));\n    if (ConfigUtils.getPid() > 0) {\n        map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));\n    }\n\n    // 通过反射将对象的字段信息到 map 中\n    appendParameters(map, application);\n    appendParameters(map, module);\n    appendParameters(map, provider, Constants.DEFAULT_KEY);\n    appendParameters(map, protocolConfig);\n    appendParameters(map, this);\n\n    // methods 为 MethodConfig 集合，MethodConfig 中存储了 <dubbo:method> 标签的配置信息\n    if (methods != null && !methods.isEmpty()) {\n        // 这段代码用于添加 Callback 配置到 map 中，代码太长，待会单独分析\n    }\n\n    // 检测 generic 是否为 "true"，并根据检测结果向 map 中添加不同的信息\n    if (ProtocolUtils.isGeneric(generic)) {\n        map.put(Constants.GENERIC_KEY, generic);\n        map.put(Constants.METHODS_KEY, Constants.ANY_VALUE);\n    } else {\n        String revision = Version.getVersion(interfaceClass, version);\n        if (revision != null && revision.length() > 0) {\n            map.put("revision", revision);\n        }\n\n        // 为接口生成包裹类 Wrapper，Wrapper 中包含了接口的详细信息，比如接口方法名数组，字段信息等\n        String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();\n        // 添加方法名到 map 中，如果包含多个方法名，则用逗号隔开，比如 method = init,destroy\n        if (methods.length == 0) {\n            logger.warn("NO method found in service interface ...");\n            map.put(Constants.METHODS_KEY, Constants.ANY_VALUE);\n        } else {\n            // 将逗号作为分隔符连接方法名，并将连接后的字符串放入 map 中\n            map.put(Constants.METHODS_KEY, StringUtils.join(new HashSet<String>(Arrays.asList(methods)), ","));\n        }\n    }\n\n    // 添加 token 到 map 中\n    if (!ConfigUtils.isEmpty(token)) {\n        if (ConfigUtils.isDefault(token)) {\n            map.put(Constants.TOKEN_KEY, UUID.randomUUID().toString());\n        } else {\n            map.put(Constants.TOKEN_KEY, token);\n        }\n    }\n    // 判断协议名是否为 injvm\n    if (Constants.LOCAL_PROTOCOL.equals(protocolConfig.getName())) {\n        protocolConfig.setRegister(false);\n        map.put("notify", "false");\n    }\n\n    // 获取上下文路径\n    String contextPath = protocolConfig.getContextpath();\n    if ((contextPath == null || contextPath.length() == 0) && provider != null) {\n        contextPath = provider.getContextpath();\n    }\n\n    // 获取 host 和 port\n    String host = this.findConfigedHosts(protocolConfig, registryURLs, map);\n    Integer port = this.findConfigedPorts(protocolConfig, name, map);\n    // 组装 URL\n    URL url = new URL(name, host, port, (contextPath == null || contextPath.length() == 0 ? "" : contextPath + "/") + path, map);\n    \n    // 省略无关代码\n}\n')])])]),r("p",[e._v("上面的代码首先是将一些信息，比如版本、时间戳、方法名以及各种配置对象的字段信息放入到 map 中，map 中的内容将作为 URL 的查询字符串。构建好 map 后，紧接着是获取上下文路径、主机名以及端口号等信息。最后将 map 和主机名等数据传给 URL 构造方法创建 URL 对象。需要注意的是，这里出现的 URL 并非 java.net.URL，而是 com.alibaba.dubbo.common.URL。")]),e._v(" "),r("p",[e._v("上面省略了一段代码，这里简单分析一下。这段代码用于检测 "),r("a",{attrs:{href:"dubbo:argument"}},[e._v("dubbo:argument")]),e._v(" 标签中的配置信息，并将相关配置添加到 map 中。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List<URL> registryURLs) {\n    // ...\n\n    // methods 为 MethodConfig 集合，MethodConfig 中存储了 <dubbo:method> 标签的配置信息\n    if (methods != null && !methods.isEmpty()) {\n        for (MethodConfig method : methods) {\n            // 添加 MethodConfig 对象的字段信息到 map 中，键 = 方法名.属性名。\n            // 比如存储 <dubbo:method name="sayHello" retries="2"> 对应的 MethodConfig，\n            // 键 = sayHello.retries，map = {"sayHello.retries": 2, "xxx": "yyy"}\n            appendParameters(map, method, method.getName());\n\n            String retryKey = method.getName() + ".retry";\n            if (map.containsKey(retryKey)) {\n                String retryValue = map.remove(retryKey);\n                // 检测 MethodConfig retry 是否为 false，若是，则设置重试次数为0\n                if ("false".equals(retryValue)) {\n                    map.put(method.getName() + ".retries", "0");\n                }\n            }\n            \n            // 获取 ArgumentConfig 列表\n            List<ArgumentConfig> arguments = method.getArguments();\n            if (arguments != null && !arguments.isEmpty()) {\n                for (ArgumentConfig argument : arguments) {\n                    // 检测 type 属性是否为空，或者空串（分支1 ⭐️）\n                    if (argument.getType() != null && argument.getType().length() > 0) {\n                        Method[] methods = interfaceClass.getMethods();\n                        if (methods != null && methods.length > 0) {\n                            for (int i = 0; i < methods.length; i++) {\n                                String methodName = methods[i].getName();\n                                // 比对方法名，查找目标方法\n                                if (methodName.equals(method.getName())) {\n                                    Class<?>[] argtypes = methods[i].getParameterTypes();\n                                    if (argument.getIndex() != -1) {\n                                        // 检测 ArgumentConfig 中的 type 属性与方法参数列表\n                                        // 中的参数名称是否一致，不一致则抛出异常(分支2 ⭐️)\n                                        if (argtypes[argument.getIndex()].getName().equals(argument.getType())) {\n                                            // 添加 ArgumentConfig 字段信息到 map 中，\n                                            // 键前缀 = 方法名.index，比如:\n                                            // map = {"sayHello.3": true}\n                                            appendParameters(map, argument, method.getName() + "." + argument.getIndex());\n                                        } else {\n                                            throw new IllegalArgumentException("argument config error: ...");\n                                        }\n                                    } else {    // 分支3 ⭐️\n                                        for (int j = 0; j < argtypes.length; j++) {\n                                            Class<?> argclazz = argtypes[j];\n                                            // 从参数类型列表中查找类型名称为 argument.type 的参数\n                                            if (argclazz.getName().equals(argument.getType())) {\n                                                appendParameters(map, argument, method.getName() + "." + j);\n                                                if (argument.getIndex() != -1 && argument.getIndex() != j) {\n                                                    throw new IllegalArgumentException("argument config error: ...");\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n\n                    // 用户未配置 type 属性，但配置了 index 属性，且 index != -1\n                    } else if (argument.getIndex() != -1) {    // 分支4 ⭐️\n                        // 添加 ArgumentConfig 字段信息到 map 中\n                        appendParameters(map, argument, method.getName() + "." + argument.getIndex());\n                    } else {\n                        throw new IllegalArgumentException("argument config must set index or type");\n                    }\n                }\n            }\n        }\n    }\n\n    // ...\n}\n')])])]),r("p",[e._v("上面这段代码 for 循环和 if else 分支嵌套太多，导致层次太深，不利于阅读，需要耐心看一下。大家在看这段代码时，注意把几个重要的条件分支找出来。只要理解了这几个分支的意图，就可以弄懂这段代码。我在上面代码中用⭐️符号标识出了4个重要的分支，下面用伪代码解释一下这几个分支的含义。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// 获取 ArgumentConfig 列表\nfor (遍历 ArgumentConfig 列表) {\n    if (type 不为 null，也不为空串) {    // 分支1\n        1. 通过反射获取 interfaceClass 的方法列表\n        for (遍历方法列表) {\n            1. 比对方法名，查找目标方法\n        \t2. 通过反射获取目标方法的参数类型数组 argtypes\n            if (index != -1) {    // 分支2\n                1. 从 argtypes 数组中获取下标 index 处的元素 argType\n                2. 检测 argType 的名称与 ArgumentConfig 中的 type 属性是否一致\n                3. 添加 ArgumentConfig 字段信息到 map 中，或抛出异常\n            } else {    // 分支3\n                1. 遍历参数类型数组 argtypes，查找 argument.type 类型的参数\n                2. 添加 ArgumentConfig 字段信息到 map 中\n            }\n        }\n    } else if (index != -1) {    // 分支4\n\t\t1. 添加 ArgumentConfig 字段信息到 map 中\n    }\n}\n")])])]),r("p",[e._v("在本节分析的源码中，appendParameters 这个方法出现的次数比较多，该方法用于将对象字段信息添加到 map 中。实现上则是通过反射获取目标对象的 getter 方法，并调用该方法获取属性值。然后再通过 getter 方法名解析出属性名，比如从方法名 getName 中可解析出属性 name。如果用户传入了属性名前缀，此时需要将属性名加入前缀内容。最后将 <属性名，属性值> 键值对存入到 map 中就行了。限于篇幅原因，这里就不分析 appendParameters 方法的源码了，大家请自行分析。")]),e._v(" "),r("h3",{attrs:{id:"_2-2-导出-dubbo-服务"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-导出-dubbo-服务"}},[e._v("#")]),e._v(" 2.2 导出 Dubbo 服务")]),e._v(" "),r("p",[e._v("前置工作做完，接下来就可以进行服务导出工作。服务导出，分为导出到本地 (JVM)，和导出到远程。在深入分析服务导出源码前，我们先来从宏观层面上看一下服务导出逻辑。如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List<URL> registryURLs) {\n    \n    // 省略无关代码\n    \n    if (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)\n            .hasExtension(url.getProtocol())) {\n        // 加载 ConfiguratorFactory，并生成 Configurator 配置 url\n        url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)\n                .getExtension(url.getProtocol()).getConfigurator(url).configure(url);\n    }\n\n    String scope = url.getParameter(Constants.SCOPE_KEY);\n    // 如果 scope = none，则什么都不做\n    if (!Constants.SCOPE_NONE.toString().equalsIgnoreCase(scope)) {\n        // scope != remote，导出到本地\n        if (!Constants.SCOPE_REMOTE.toString().equalsIgnoreCase(scope)) {\n            exportLocal(url);\n        }\n\n        // scope != local，导出到远程\n        if (!Constants.SCOPE_LOCAL.toString().equalsIgnoreCase(scope)) {\n            if (registryURLs != null && !registryURLs.isEmpty()) {\n                for (URL registryURL : registryURLs) {\n                    url = url.addParameterIfAbsent(Constants.DYNAMIC_KEY, registryURL.getParameter(Constants.DYNAMIC_KEY));\n                    // 加载监视器链接\n                    URL monitorUrl = loadMonitor(registryURL);\n                    if (monitorUrl != null) {\n                        // 将监视器链接作为参数添加到 url 中\n                        url = url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString());\n                    }\n\n                    String proxy = url.getParameter(Constants.PROXY_KEY);\n                    if (StringUtils.isNotEmpty(proxy)) {\n                        registryURL = registryURL.addParameter(Constants.PROXY_KEY, proxy);\n                    }\n\n                    // 为服务提供类(ref)生成 Invoker\n                    Invoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));\n                    // DelegateProviderMetaDataInvoker 仅用于持有 Invoker 和 ServiceConfig\n                    DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);\n\n                    // 导出服务，并生成 Exporter\n                    Exporter<?> exporter = protocol.export(wrapperInvoker);\n                    exporters.add(exporter);\n                }\n            } else {    // 不存在注册中心，仅导出服务\n                Invoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url);\n                DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);\n\n                Exporter<?> exporter = protocol.export(wrapperInvoker);\n                exporters.add(exporter);\n            }\n        }\n    }\n    this.urls.add(url);\n}\n")])])]),r("p",[e._v("上面代码根据 url 中的 scope 参数决定服务导出方式，分别如下：")]),e._v(" "),r("ul",[r("li",[e._v("scope = none，不导出服务")]),e._v(" "),r("li",[e._v("scope != remote，导出到本地")]),e._v(" "),r("li",[e._v("scope != local，导出到远程")])]),e._v(" "),r("p",[e._v("不管是导出到本地，还是远程。进行服务导出之前，均需要先创建 Invoker。这是一个很重要的步骤，因此接下来我会先分析 Invoker 的创建过程。")]),e._v(" "),r("h3",{attrs:{id:"_2-2-1-invoker-创建过程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-1-invoker-创建过程"}},[e._v("#")]),e._v(" 2.2.1 Invoker 创建过程")]),e._v(" "),r("p",[e._v("在 Dubbo 中，Invoker 是一个非常重要的模型。在服务提供端，以及服务引用端均会出现 Invoker。Dubbo 官方文档中对 Invoker 进行了说明，这里引用一下。")]),e._v(" "),r("blockquote",[r("p",[e._v("Invoker 是实体域，它是 Dubbo 的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起 invoke 调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。")])]),e._v(" "),r("p",[e._v("既然 Invoker 如此重要，那么我们很有必要搞清楚 Invoker 的用途。Invoker 是由 ProxyFactory 创建而来，Dubbo 默认的 ProxyFactory 实现类是 JavassistProxyFactory。下面我们到 JavassistProxyFactory 代码中，探索 Invoker 的创建过程。如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("-- JavassistProxyFactory\npublic <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) {\n\t// 为目标类创建 Wrapper\n    final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf('$') < 0 ? proxy.getClass() : type);\n    // 创建匿名 Invoker 类对象，并实现 doInvoke 方法。\n    return new AbstractProxyInvoker<T>(proxy, type, url) {\n        @Override\n        protected Object doInvoke(T proxy, String methodName,\n                                  Class<?>[] parameterTypes,\n                                  Object[] arguments) throws Throwable {\n\t\t\t// 调用 Wrapper 的 invokeMethod 方法，invokeMethod 最终会调用目标方法\n            return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);\n        }\n    };\n}\n")])])]),r("p",[e._v("如上，JavassistProxyFactory 创建了一个继承自 AbstractProxyInvoker 类的匿名对象，并覆写了抽象方法 doInvoke。覆写后的 doInvoke 逻辑比较简单，仅是将调用请求转发给了 Wrapper 类的 invokeMethod 方法。Wrapper 用于“包裹”目标类，Wrapper 是一个抽象类，仅可通过 getWrapper(Class) 方法创建子类。在创建 Wrapper 子类的过程中，子类代码生成逻辑会对 getWrapper 方法传入的 Class 对象进行解析，拿到诸如类方法，类成员变量等信息。以及生成 invokeMethod 方法代码，和其他一些方法代码。代码生成完毕后，通过 Javassist 生成 Class 对象，最后再通过反射创建 Wrapper 实例。相关的代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v(" public static Wrapper getWrapper(Class<?> c) {\n    while (ClassGenerator.isDynamicClass(c))\n        c = c.getSuperclass();\n\n    if (c == Object.class)\n        return OBJECT_WRAPPER;\n\n    // 访存\n    Wrapper ret = WRAPPER_MAP.get(c);\n    if (ret == null) {\n        // 缓存未命中，创建 Wrapper\n        ret = makeWrapper(c);\n        // 写入缓存\n        WRAPPER_MAP.put(c, ret);\n    }\n    return ret;\n}\n")])])]),r("p",[e._v("getWrapper 方法只是包含了一些缓存操作逻辑，非重点。下面我们重点关注 makeWrapper 方法。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('private static Wrapper makeWrapper(Class<?> c) {\n    // 检测 c 是否为私有类型，若是则抛出异常\n    if (c.isPrimitive())\n        throw new IllegalArgumentException("Can not create wrapper for primitive type: " + c);\n\n    String name = c.getName();\n    ClassLoader cl = ClassHelper.getClassLoader(c);\n\n    // c1 用于存储 setPropertyValue 方法代码\n    StringBuilder c1 = new StringBuilder("public void setPropertyValue(Object o, String n, Object v){ ");\n    // c2 用于存储 getPropertyValue 方法代码\n    StringBuilder c2 = new StringBuilder("public Object getPropertyValue(Object o, String n){ ");\n    // c3 用于存储 invokeMethod 方法代码\n    StringBuilder c3 = new StringBuilder("public Object invokeMethod(Object o, String n, Class[] p, Object[] v) throws " + InvocationTargetException.class.getName() + "{ ");\n\n    // 生成类型转换代码及异常捕捉代码，比如：\n    //   DemoService w; try { w = ((DemoServcie) $1); }}catch(Throwable e){ throw new IllegalArgumentException(e); }\n    c1.append(name).append(" w; try{ w = ((").append(name).append(")$1); }catch(Throwable e){ throw new IllegalArgumentException(e); }");\n    c2.append(name).append(" w; try{ w = ((").append(name).append(")$1); }catch(Throwable e){ throw new IllegalArgumentException(e); }");\n    c3.append(name).append(" w; try{ w = ((").append(name).append(")$1); }catch(Throwable e){ throw new IllegalArgumentException(e); }");\n\n    // pts 用于存储成员变量名和类型\n    Map<String, Class<?>> pts = new HashMap<String, Class<?>>();\n    // ms 用于存储方法描述信息（可理解为方法签名）及 Method 实例\n    Map<String, Method> ms = new LinkedHashMap<String, Method>();\n    // mns 为方法名列表\n    List<String> mns = new ArrayList<String>();\n    // dmns 用于存储定义在当前类中的方法的名称\n    List<String> dmns = new ArrayList<String>();\n\n    // --------------------------------✨ 分割线1 ✨-------------------------------------\n\n    // 获取 public 访问级别的字段，并为所有字段生成条件判断语句\n    for (Field f : c.getFields()) {\n        String fn = f.getName();\n        Class<?> ft = f.getType();\n        if (Modifier.isStatic(f.getModifiers()) || Modifier.isTransient(f.getModifiers()))\n            // 忽略关键字 static 或 transient 修饰的变量\n            continue;\n\n        // 生成条件判断及赋值语句，比如：\n        // if( $2.equals("name") ) { w.name = (java.lang.String) $3; return;}\n        // if( $2.equals("age") ) { w.age = ((Number) $3).intValue(); return;}\n        c1.append(" if( $2.equals(\\"").append(fn).append("\\") ){ w.").append(fn).append("=").append(arg(ft, "$3")).append("; return; }");\n\n        // 生成条件判断及返回语句，比如：\n        // if( $2.equals("name") ) { return ($w)w.name; }\n        c2.append(" if( $2.equals(\\"").append(fn).append("\\") ){ return ($w)w.").append(fn).append("; }");\n\n        // 存储 <字段名, 字段类型> 键值对到 pts 中\n        pts.put(fn, ft);\n    }\n\n    // --------------------------------✨ 分割线2 ✨-------------------------------------\n\n    Method[] methods = c.getMethods();\n    // 检测 c 中是否包含在当前类中声明的方法\n    boolean hasMethod = hasMethods(methods);\n    if (hasMethod) {\n        c3.append(" try{");\n    }\n    for (Method m : methods) {\n        if (m.getDeclaringClass() == Object.class)\n            // 忽略 Object 中定义的方法\n            continue;\n\n        String mn = m.getName();\n        // 生成方法名判断语句，示例如下：\n        // if ( "sayHello".equals( $2 )\n        c3.append(" if( \\"").append(mn).append("\\".equals( $2 ) ");\n        int len = m.getParameterTypes().length;\n        // 生成运行时传入参数的数量与方法的参数列表长度判断语句，示例如下：\n        // && $3.length == 2\n        c3.append(" && ").append(" $3.length == ").append(len);\n\n        boolean override = false;\n        for (Method m2 : methods) {\n            // 检测方法是否存在重载情况，条件为：方法对象不同 && 方法名相同\n            if (m != m2 && m.getName().equals(m2.getName())) {\n                override = true;\n                break;\n            }\n        }\n        // 对重载方法进行处理，考虑下面的方法：\n        //    1. void sayHello(Integer, String)\n        //    2. void sayHello(Integer, Integer)\n        // 方法名相同，参数列表长度也相同，因此不能仅通过这两项判断两个方法是否相等。\n        // 需要进一步判断方法的参数类型\n        if (override) {\n            if (len > 0) {\n                for (int l = 0; l < len; l++) {\n                    // && $3[0].getName().equals("java.lang.Integer") \n                    //    && $3[1].getName().equals("java.lang.String")\n                    c3.append(" && ").append(" $3[").append(l).append("].getName().equals(\\"")\n                            .append(m.getParameterTypes()[l].getName()).append("\\")");\n                }\n            }\n        }\n\n        // 添加 ) {，完成方法判断语句，此时生成的方法可能如下（已格式化）：\n        // if ("sayHello".equals($2) \n        //     && $3.length == 2\n        //     && $3[0].getName().equals("java.lang.Integer") \n        //     && $3[1].getName().equals("java.lang.String")) {\n        c3.append(" ) { ");\n\n        // 根据返回值类型生成目标方法调用语句\n        if (m.getReturnType() == Void.TYPE)\n            // w.sayHello((java.lang.Integer)$4[0], (java.lang.String)$4[1]); return null;\n            c3.append(" w.").append(mn).append(\'(\').append(args(m.getParameterTypes(), "$4")).append(");").append(" return null;");\n        else\n            // return w.sayHello((java.lang.Integer)$4[0], (java.lang.String)$4[1]);\n            c3.append(" return ($w)w.").append(mn).append(\'(\').append(args(m.getParameterTypes(), "$4")).append(");");\n\n        // 添加 }, 当前”方法判断条件“代码生成完毕，示例代码如下（已格式化）：\n        // if ("sayHello".equals($2) \n        //     && $3.length == 2\n        //     && $3[0].getName().equals("java.lang.Integer") \n        //     && $3[1].getName().equals("java.lang.String")) {\n        //\n        //     w.sayHello((java.lang.Integer)$4[0], (java.lang.String)$4[1]); \n        //     return null;\n        // }\n        c3.append(" }");\n\n        // 添加方法名到 mns 集合中\n        mns.add(mn);\n        // 检测当前方法是否在 c 中被声明的\n        if (m.getDeclaringClass() == c)\n            // 若是，则将当前方法名添加到 dmns 中\n            dmns.add(mn);\n        ms.put(ReflectUtils.getDesc(m), m);\n    }\n    if (hasMethod) {\n        // 添加异常捕捉语句\n        c3.append(" } catch(Throwable e) { ");\n        c3.append("     throw new java.lang.reflect.InvocationTargetException(e); ");\n        c3.append(" }");\n    }\n\n    // 添加 NoSuchMethodException 异常抛出代码\n    c3.append(" throw new " + NoSuchMethodException.class.getName() + "(\\"Not found method \\\\\\"\\"+$2+\\"\\\\\\" in class " + c.getName() + ".\\"); }");\n\n    // --------------------------------✨ 分割线3 ✨-------------------------------------\n\n    Matcher matcher;\n    // 处理 get/set 方法\n    for (Map.Entry<String, Method> entry : ms.entrySet()) {\n        String md = entry.getKey();\n        Method method = (Method) entry.getValue();\n        // 匹配以 get 开头的方法\n        if ((matcher = ReflectUtils.GETTER_METHOD_DESC_PATTERN.matcher(md)).matches()) {\n            // 获取属性名\n            String pn = propertyName(matcher.group(1));\n            // 生成属性判断以及返回语句，示例如下：\n            // if( $2.equals("name") ) { return ($w).w.getName(); }\n            c2.append(" if( $2.equals(\\"").append(pn).append("\\") ){ return ($w)w.").append(method.getName()).append("(); }");\n            pts.put(pn, method.getReturnType());\n\n        // 匹配以 is/has/can 开头的方法\n        } else if ((matcher = ReflectUtils.IS_HAS_CAN_METHOD_DESC_PATTERN.matcher(md)).matches()) {\n            String pn = propertyName(matcher.group(1));\n            // 生成属性判断以及返回语句，示例如下：\n            // if( $2.equals("dream") ) { return ($w).w.hasDream(); }\n            c2.append(" if( $2.equals(\\"").append(pn).append("\\") ){ return ($w)w.").append(method.getName()).append("(); }");\n            pts.put(pn, method.getReturnType());\n\n        // 匹配以 set 开头的方法\n        } else if ((matcher = ReflectUtils.SETTER_METHOD_DESC_PATTERN.matcher(md)).matches()) {\n            Class<?> pt = method.getParameterTypes()[0];\n            String pn = propertyName(matcher.group(1));\n            // 生成属性判断以及 setter 调用语句，示例如下：\n            // if( $2.equals("name") ) { w.setName((java.lang.String)$3); return; }\n            c1.append(" if( $2.equals(\\"").append(pn).append("\\") ){ w.").append(method.getName()).append("(").append(arg(pt, "$3")).append("); return; }");\n            pts.put(pn, pt);\n        }\n    }\n\n    // 添加 NoSuchPropertyException 异常抛出代码\n    c1.append(" throw new " + NoSuchPropertyException.class.getName() + "(\\"Not found property \\\\\\"\\"+$2+\\"\\\\\\" filed or setter method in class " + c.getName() + ".\\"); }");\n    c2.append(" throw new " + NoSuchPropertyException.class.getName() + "(\\"Not found property \\\\\\"\\"+$2+\\"\\\\\\" filed or setter method in class " + c.getName() + ".\\"); }");\n\n    // --------------------------------✨ 分割线4 ✨-------------------------------------\n\n    long id = WRAPPER_CLASS_COUNTER.getAndIncrement();\n    // 创建类生成器\n    ClassGenerator cc = ClassGenerator.newInstance(cl);\n    // 设置类名及超类\n    cc.setClassName((Modifier.isPublic(c.getModifiers()) ? Wrapper.class.getName() : c.getName() + "$sw") + id);\n    cc.setSuperClass(Wrapper.class);\n\n    // 添加默认构造方法\n    cc.addDefaultConstructor();\n\n    // 添加字段\n    cc.addField("public static String[] pns;");\n    cc.addField("public static " + Map.class.getName() + " pts;");\n    cc.addField("public static String[] mns;");\n    cc.addField("public static String[] dmns;");\n    for (int i = 0, len = ms.size(); i < len; i++)\n        cc.addField("public static Class[] mts" + i + ";");\n\n    // 添加方法代码\n    cc.addMethod("public String[] getPropertyNames(){ return pns; }");\n    cc.addMethod("public boolean hasProperty(String n){ return pts.containsKey($1); }");\n    cc.addMethod("public Class getPropertyType(String n){ return (Class)pts.get($1); }");\n    cc.addMethod("public String[] getMethodNames(){ return mns; }");\n    cc.addMethod("public String[] getDeclaredMethodNames(){ return dmns; }");\n    cc.addMethod(c1.toString());\n    cc.addMethod(c2.toString());\n    cc.addMethod(c3.toString());\n\n    try {\n        // 生成类\n        Class<?> wc = cc.toClass();\n        \n        // 设置字段值\n        wc.getField("pts").set(null, pts);\n        wc.getField("pns").set(null, pts.keySet().toArray(new String[0]));\n        wc.getField("mns").set(null, mns.toArray(new String[0]));\n        wc.getField("dmns").set(null, dmns.toArray(new String[0]));\n        int ix = 0;\n        for (Method m : ms.values())\n            wc.getField("mts" + ix++).set(null, m.getParameterTypes());\n\n        // 创建 Wrapper 实例\n        return (Wrapper) wc.newInstance();\n    } catch (RuntimeException e) {\n        throw e;\n    } catch (Throwable e) {\n        throw new RuntimeException(e.getMessage(), e);\n    } finally {\n        cc.release();\n        ms.clear();\n        mns.clear();\n        dmns.clear();\n    }\n}\n')])])]),r("p",[e._v("上面代码很长，大家耐心看一下。我在上面代码中做了大量的注释，并按功能对代码进行了分块，以帮助大家理解代码逻辑。下面对这段代码进行讲解。首先我们把目光移到分割线1之上的代码，这段代码主要用于进行一些初始化操作。比如创建 c1、c2、c3 以及 pts、ms、mns 等变量，以及向 c1、c2、c3 中添加方法定义和类型类型转换代码。接下来是分割线1到分割线2之间的代码，这段代码用于为 public 级别的字段生成条件判断取值与赋值代码。这段代码不是很难看懂，就不多说了。继续向下看，分割线2和分隔线3之间的代码用于为定义在当前类中的方法生成判断语句，和方法调用语句。因为需要对方法重载进行校验，因此到这这段代码看起来有点复杂。不过耐心开一下，也不是很难理解。接下来是分割线3和分隔线4之间的代码，这段代码用于处理 getter、setter 以及以 is/has/can 开头的方法。处理方式是通过正则表达式获取方法类型（get/set/is/…），以及属性名。之后为属性名生成判断语句，然后为方法生成调用语句。最后我们再来看一下分隔线4以下的代码，这段代码通过 ClassGenerator 为刚刚生成的代码构建 Class 类，并通过反射创建对象。ClassGenerator 是 Dubbo 自己封装的，该类的核心是 toClass() 的重载方法 toClass(ClassLoader, ProtectionDomain)，该方法通过 javassist 构建 Class。这里就不分析 toClass 方法了，大家请自行分析。")]),e._v(" "),r("p",[e._v("阅读 Wrapper 类代码需要对 javassist 框架有所了解。关于 javassist，大家如果不熟悉，请自行查阅资料，本节不打算介绍 javassist 相关内容。")]),e._v(" "),r("p",[e._v("好了，关于 Wrapper 类生成过程就分析到这。如果大家看的不是很明白，可以单独为 Wrapper 创建单元测试，然后单步调试。并将生成的代码拷贝出来，格式化后再进行观察和理解。好了，本节先到这。")]),e._v(" "),r("h3",{attrs:{id:"_2-2-2-导出服务到本地"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-2-导出服务到本地"}},[e._v("#")]),e._v(" 2.2.2 导出服务到本地")]),e._v(" "),r("p",[e._v("本节我们来看一下服务导出相关的代码，按照代码执行顺序，本节先来分析导出服务到本地的过程。相关代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("private void exportLocal(URL url) {\n    // 如果 URL 的协议头等于 injvm，说明已经导出到本地了，无需再次导出\n    if (!Constants.LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) {\n        URL local = URL.valueOf(url.toFullString())\n            .setProtocol(Constants.LOCAL_PROTOCOL)    // 设置协议头为 injvm\n            .setHost(LOCALHOST)\n            .setPort(0);\n        ServiceClassHolder.getInstance().pushServiceClass(getServiceClass(ref));\n        // 创建 Invoker，并导出服务，这里的 protocol 会在运行时调用 InjvmProtocol 的 export 方法\n        Exporter<?> exporter = protocol.export(\n            proxyFactory.getInvoker(ref, (Class) interfaceClass, local));\n        exporters.add(exporter);\n    }\n}\n")])])]),r("p",[e._v("exportLocal 方法比较简单，首先根据 URL 协议头决定是否导出服务。若需导出，则创建一个新的 URL 并将协议头、主机名以及端口设置成新的值。然后创建 Invoker，并调用 InjvmProtocol 的 export 方法导出服务。下面我们来看一下 InjvmProtocol 的 export 方法都做了哪些事情。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {\n    // 创建 InjvmExporter\n    return new InjvmExporter<T>(invoker, invoker.getUrl().getServiceKey(), exporterMap);\n}\n")])])]),r("p",[e._v("如上，InjvmProtocol 的 export 方法仅创建了一个 InjvmExporter，无其他逻辑。到此导出服务到本地就分析完了，接下来，我们继续分析导出服务到远程的过程。")]),e._v(" "),r("h3",{attrs:{id:"_2-2-3-导出服务到远程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-3-导出服务到远程"}},[e._v("#")]),e._v(" 2.2.3 导出服务到远程")]),e._v(" "),r("p",[e._v("与导出服务到本地相比，导出服务到远程的过程要复杂不少，其包含了服务导出与服务注册两个过程。这两个过程涉及到了大量的调用，因此比较复杂。不过不管再难，我们都要看一下，万一看懂了呢。按照代码执行顺序，本节先来分析服务导出逻辑，服务注册逻辑将在下一节进行分析。下面开始分析，我们把目光移动到 RegistryProtocol 的 export 方法上。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('public <T> Exporter<T> export(final Invoker<T> originInvoker) throws RpcException {\n    // 导出服务\n    final ExporterChangeableWrapper<T> exporter = doLocalExport(originInvoker);\n\n    // 获取注册中心 URL，以 zookeeper 注册中心为例，得到的示例 URL 如下：\n    // zookeeper://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-provider&dubbo=2.0.2&export=dubbo%3A%2F%2F172.17.48.52%3A20880%2Fcom.alibaba.dubbo.demo.DemoService%3Fanyhost%3Dtrue%26application%3Ddemo-provider\n    URL registryUrl = getRegistryUrl(originInvoker);\n\n    // 根据 URL 加载 Registry 实现类，比如 ZookeeperRegistry\n    final Registry registry = getRegistry(originInvoker);\n    \n    // 获取已注册的服务提供者 URL，比如：\n    // dubbo://172.17.48.52:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&dubbo=2.0.2&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello\n    final URL registeredProviderUrl = getRegisteredProviderUrl(originInvoker);\n\n    // 获取 register 参数\n    boolean register = registeredProviderUrl.getParameter("register", true);\n\n    // 向服务提供者与消费者注册表中注册服务提供者\n    ProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registeredProviderUrl);\n\n    // 根据 register 的值决定是否注册服务\n    if (register) {\n        // 向注册中心注册服务\n        register(registryUrl, registeredProviderUrl);\n        ProviderConsumerRegTable.getProviderWrapper(originInvoker).setReg(true);\n    }\n\n    // 获取订阅 URL，比如：\n    // provider://172.17.48.52:20880/com.alibaba.dubbo.demo.DemoService?category=configurators&check=false&anyhost=true&application=demo-provider&dubbo=2.0.2&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello\n    final URL overrideSubscribeUrl = getSubscribedOverrideUrl(registeredProviderUrl);\n    // 创建监听器\n    final OverrideListener overrideSubscribeListener = new OverrideListener(overrideSubscribeUrl, originInvoker);\n    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);\n    // 向注册中心进行订阅 override 数据\n    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);\n    // 创建并返回 DestroyableExporter\n    return new DestroyableExporter<T>(exporter, originInvoker, overrideSubscribeUrl, registeredProviderUrl);\n}\n')])])]),r("p",[e._v("上面代码看起来比较复杂，主要做如下一些操作：")]),e._v(" "),r("ol",[r("li",[e._v("调用 doLocalExport 导出服务")]),e._v(" "),r("li",[e._v("向注册中心注册服务")]),e._v(" "),r("li",[e._v("向注册中心进行订阅 override 数据")]),e._v(" "),r("li",[e._v("创建并返回 DestroyableExporter")])]),e._v(" "),r("p",[e._v("在以上操作中，除了创建并返回 DestroyableExporter 没啥难度外，其他几步操作都不是很简单。这其中，导出服务和注册服务是本章要重点分析的逻辑。 订阅 override 数据这个是非重点内容，后面会简单介绍一下。下面开始本节的分析，先来分析 doLocalExport 方法的逻辑，如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("private <T> ExporterChangeableWrapper<T> doLocalExport(final Invoker<T> originInvoker) {\n    String key = getCacheKey(originInvoker);\n    // 访问缓存\n    ExporterChangeableWrapper<T> exporter = (ExporterChangeableWrapper<T>) bounds.get(key);\n    if (exporter == null) {\n        synchronized (bounds) {\n            exporter = (ExporterChangeableWrapper<T>) bounds.get(key);\n            if (exporter == null) {\n                // 创建 Invoker 为委托类对象\n                final Invoker<?> invokerDelegete = new InvokerDelegete<T>(originInvoker, getProviderUrl(originInvoker));\n                // 调用 protocol 的 export 方法导出服务\n                exporter = new ExporterChangeableWrapper<T>((Exporter<T>) protocol.export(invokerDelegete), originInvoker);\n                \n                // 写缓存\n                bounds.put(key, exporter);\n            }\n        }\n    }\n    return exporter;\n}\n")])])]),r("p",[e._v("上面的代码是典型的双重检查，这个大家应该都知道。接下来，我们把重点放在 Protocol 的 export 方法上。假设运行时协议为 dubbo，此处的 protocol 会在运行时加载 DubboProtocol，并调用 DubboProtocol 的 export 方法。我们目光转移到 DubboProtocol 的 export 方法上，相关分析如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {\n    URL url = invoker.getUrl();\n\n    // 获取服务标识，理解成服务坐标也行。由服务组名，服务名，服务版本号以及端口组成。比如：\n    // demoGroup/com.alibaba.dubbo.demo.DemoService:1.0.1:20880\n    String key = serviceKey(url);\n    // 创建 DubboExporter\n    DubboExporter<T> exporter = new DubboExporter<T>(invoker, key, exporterMap);\n    // 将 <key, exporter> 键值对放入缓存中\n    exporterMap.put(key, exporter);\n\n    // 以下代码应该和本地存根有关，代码不难看懂，但具体用途暂时不清楚，先忽略\n    Boolean isStubSupportEvent = url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT);\n    Boolean isCallbackservice = url.getParameter(Constants.IS_CALLBACK_SERVICE, false);\n    if (isStubSupportEvent && !isCallbackservice) {\n        String stubServiceMethods = url.getParameter(Constants.STUB_EVENT_METHODS_KEY);\n        if (stubServiceMethods == null || stubServiceMethods.length() == 0) {\n            // 省略日志打印代码\n        } else {\n            stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);\n        }\n    }\n\n    // 启动服务器\n    openServer(url);\n    // 优化序列化\n    optimizeSerialization(url);\n    return exporter;\n}\n")])])]),r("p",[e._v("如上，我们重点关注 DubboExporter 的创建以及 openServer 方法，其他逻辑看不懂也没关系，不影响理解服务导出过程。另外，DubboExporter 的代码比较简单，就不分析了。下面分析 openServer 方法。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("private void openServer(URL url) {\n    // 获取 host:port，并将其作为服务器实例的 key，用于标识当前的服务器实例\n    String key = url.getAddress();\n    boolean isServer = url.getParameter(Constants.IS_SERVER_KEY, true);\n    if (isServer) {\n        // 访问缓存\n        ExchangeServer server = serverMap.get(key);\n        if (server == null) {\n            // 创建服务器实例\n            serverMap.put(key, createServer(url));\n        } else {\n            // 服务器已创建，则根据 url 中的配置重置服务器\n            server.reset(url);\n        }\n    }\n}\n")])])]),r("p",[e._v("如上，在同一台机器上（单网卡），同一个端口上仅允许启动一个服务器实例。若某个端口上已有服务器实例，此时则调用 reset 方法重置服务器的一些配置。考虑到篇幅问题，关于服务器实例重置的代码就不分析了。接下来分析服务器实例的创建过程。如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('private ExchangeServer createServer(URL url) {\n    url = url.addParameterIfAbsent(Constants.CHANNEL_READONLYEVENT_SENT_KEY,\n    // 添加心跳检测配置到 url 中\n    url = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));\n\t// 获取 server 参数，默认为 netty\n    String str = url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_SERVER);\n\n\t// 通过 SPI 检测是否存在 server 参数所代表的 Transporter 拓展，不存在则抛出异常\n    if (str != null && str.length() > 0 && !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str))\n        throw new RpcException("Unsupported server type: " + str + ", url: " + url);\n\n    // 添加编码解码器参数\n    url = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);\n    ExchangeServer server;\n    try {\n        // 创建 ExchangeServer\n        server = Exchangers.bind(url, requestHandler);\n    } catch (RemotingException e) {\n        throw new RpcException("Fail to start server...");\n    }\n                                   \n\t// 获取 client 参数，可指定 netty，mina\n    str = url.getParameter(Constants.CLIENT_KEY);\n    if (str != null && str.length() > 0) {\n        // 获取所有的 Transporter 实现类名称集合，比如 supportedTypes = [netty, mina]\n        Set<String> supportedTypes = ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions();\n        // 检测当前 Dubbo 所支持的 Transporter 实现类名称列表中，\n        // 是否包含 client 所表示的 Transporter，若不包含，则抛出异常\n        if (!supportedTypes.contains(str)) {\n            throw new RpcException("Unsupported client type...");\n        }\n    }\n    return server;\n}\n')])])]),r("p",[e._v("如上，createServer 包含三个核心的操作。第一是检测是否存在 server 参数所代表的 Transporter 拓展，不存在则抛出异常。第二是创建服务器实例。第三是检测是否支持 client 参数所表示的 Transporter 拓展，不存在也是抛出异常。两次检测操作所对应的代码比较直白了，无需多说。但创建服务器的操作目前还不是很清晰，我们继续往下看。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('public static ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException {\n    if (url == null) {\n        throw new IllegalArgumentException("url == null");\n    }\n    if (handler == null) {\n        throw new IllegalArgumentException("handler == null");\n    }\n    url = url.addParameterIfAbsent(Constants.CODEC_KEY, "exchange");\n    // 获取 Exchanger，默认为 HeaderExchanger。\n    // 紧接着调用 HeaderExchanger 的 bind 方法创建 ExchangeServer 实例\n    return getExchanger(url).bind(url, handler);\n}\n')])])]),r("p",[e._v("上面代码比较简单，就不多说了。下面看一下 HeaderExchanger 的 bind 方法。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("public ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException {\n\t// 创建 HeaderExchangeServer 实例，该方法包含了多步操作，本别如下：\n\t//   1. new HeaderExchangeHandler(handler)\n\t//\t 2. new DecodeHandler(new HeaderExchangeHandler(handler))\n\t//   3. Transporters.bind(url, new DecodeHandler(new HeaderExchangeHandler(handler)))\n    return new HeaderExchangeServer(Transporters.bind(url, new DecodeHandler(new HeaderExchangeHandler(handler))));\n}\n")])])]),r("p",[e._v("HeaderExchanger 的 bind 方法包含的逻辑比较多，但目前我们仅需关心 Transporters 的 bind 方法逻辑即可。该方法的代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('public static Server bind(URL url, ChannelHandler... handlers) throws RemotingException {\n    if (url == null) {\n        throw new IllegalArgumentException("url == null");\n    }\n    if (handlers == null || handlers.length == 0) {\n        throw new IllegalArgumentException("handlers == null");\n    }\n    ChannelHandler handler;\n    if (handlers.length == 1) {\n        handler = handlers[0];\n    } else {\n    \t// 如果 handlers 元素数量大于1，则创建 ChannelHandler 分发器\n        handler = new ChannelHandlerDispatcher(handlers);\n    }\n    // 获取自适应 Transporter 实例，并调用实例方法\n    return getTransporter().bind(url, handler);\n}\n')])])]),r("p",[e._v("如上，getTransporter() 方法获取的 Transporter 是在运行时动态创建的，类名为 TransporterAdaptive，也就是自适应拓展类。我在"),r("a",{attrs:{href:"http://www.tianxiaobo.com/2018/10/13/Dubbo-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%87%AA%E9%80%82%E5%BA%94%E6%8B%93%E5%B1%95%E5%8E%9F%E7%90%86/",target:"_blank",rel:"noopener noreferrer"}},[e._v("上一篇文章"),r("OutboundLink")],1),e._v("中详细分析了自适应拓展类的生成过程，对自适应拓展类不了解的同学可以参考我之前的文章，这里不再赘述。TransporterAdaptive 会在运行时根据传入的 URL 参数决定加载什么类型的 Transporter，默认为 NettyTransporter。下面我们继续跟下去，这次分析的是 NettyTransporter 的 bind 方法。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("public Server bind(URL url, ChannelHandler listener) throws RemotingException {\n\t// 创建 NettyServer\n\treturn new NettyServer(url, listener);\n}\n")])])]),r("p",[e._v("这里仅有一句创建 NettyServer 的代码，没啥好讲的，我们继续向下看。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('public class NettyServer extends AbstractServer implements Server {\n    public NettyServer(URL url, ChannelHandler handler) throws RemotingException {\n        // 调用父类构造方法\n        super(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME)));\n    }\n}\n\n\npublic abstract class AbstractServer extends AbstractEndpoint implements Server {\n    public AbstractServer(URL url, ChannelHandler handler) throws RemotingException {\n        // 调用父类构造方法，这里就不用跟进去了，没什么复杂逻辑\n        super(url, handler);\n        localAddress = getUrl().toInetSocketAddress();\n\n        // 获取 ip 和端口\n        String bindIp = getUrl().getParameter(Constants.BIND_IP_KEY, getUrl().getHost());\n        int bindPort = getUrl().getParameter(Constants.BIND_PORT_KEY, getUrl().getPort());\n        if (url.getParameter(Constants.ANYHOST_KEY, false) || NetUtils.isInvalidLocalHost(bindIp)) {\n            // 设置 ip 为 0.0.0.0\n            bindIp = NetUtils.ANYHOST;\n        }\n        bindAddress = new InetSocketAddress(bindIp, bindPort);\n        // 获取最大可接受连接数\n        this.accepts = url.getParameter(Constants.ACCEPTS_KEY, Constants.DEFAULT_ACCEPTS);\n        this.idleTimeout = url.getParameter(Constants.IDLE_TIMEOUT_KEY, Constants.DEFAULT_IDLE_TIMEOUT);\n        try {\n            // 调用模板方法 doOpen 启动服务器\n            doOpen();\n        } catch (Throwable t) {\n            throw new RemotingException("Failed to bind ");\n        }\n\n        DataStore dataStore = ExtensionLoader.getExtensionLoader(DataStore.class).getDefaultExtension();\n        executor = (ExecutorService) dataStore.get(Constants.EXECUTOR_SERVICE_COMPONENT_KEY, Integer.toString(url.getPort()));\n    }\n    \n    protected abstract void doOpen() throws Throwable;\n\n    protected abstract void doClose() throws Throwable;\n}\n')])])]),r("p",[e._v("上面多数代码为赋值代码，不需要多讲。我们重点关注 doOpen 抽象方法，该方法需要子类实现。下面回到 NettyServer 中。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('protected void doOpen() throws Throwable {\n    NettyHelper.setNettyLoggerFactory();\n    // 创建 boss 和 worker 线程池\n    ExecutorService boss = Executors.newCachedThreadPool(new NamedThreadFactory("NettyServerBoss", true));\n    ExecutorService worker = Executors.newCachedThreadPool(new NamedThreadFactory("NettyServerWorker", true));\n    ChannelFactory channelFactory = new NioServerSocketChannelFactory(boss, worker, getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS));\n    \n    // 创建 ServerBootstrap\n    bootstrap = new ServerBootstrap(channelFactory);\n\n    final NettyHandler nettyHandler = new NettyHandler(getUrl(), this);\n    channels = nettyHandler.getChannels();\n    bootstrap.setOption("child.tcpNoDelay", true);\n    // 设置 PipelineFactory\n    bootstrap.setPipelineFactory(new ChannelPipelineFactory() {\n        @Override\n        public ChannelPipeline getPipeline() {\n            NettyCodecAdapter adapter = new NettyCodecAdapter(getCodec(), getUrl(), NettyServer.this);\n            ChannelPipeline pipeline = Channels.pipeline();\n            pipeline.addLast("decoder", adapter.getDecoder());\n            pipeline.addLast("encoder", adapter.getEncoder());\n            pipeline.addLast("handler", nettyHandler);\n            return pipeline;\n        }\n    });\n    // 绑定到指定的 ip 和端口上\n    channel = bootstrap.bind(getBindAddress());\n}\n')])])]),r("p",[e._v("以上就是 NettyServer 创建的过程，dubbo 默认使用的 NettyServer 是基于 netty 3.x 版本实现的，比较老了。因此 Dubbo 中另外提供了 netty 4.x 版本的 NettyServer，大家可在使用 Dubbo 的过程中按需进行配置。")]),e._v(" "),r("p",[e._v("到此，关于服务导出的过程就分析完了。整个过程比较复杂，大家在分析的过程中耐心一些。并且多写 Demo 进行进行调试，以便能够更好的理解代码逻辑。好了，本节内容先到这里，接下来分析服务导出的另一块逻辑 – 服务注册。")]),e._v(" "),r("h3",{attrs:{id:"_2-2-4-服务注册"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-4-服务注册"}},[e._v("#")]),e._v(" 2.2.4 服务注册")]),e._v(" "),r("p",[e._v("本节我们来分析服务注册过程，服务注册操作对于 Dubbo 来说不是必需的，通过服务直连的方式就可以绕过注册中心。但通常我们不会这么做，直连方式不利于服务治理，仅推荐在测试环境测试服务时使用。对于 Dubbo 来说，注册中心虽不是必需，但却是必要的。因此，关于注册中心以及服务注册相关逻辑，我们也需要搞懂。")]),e._v(" "),r("p",[e._v("本节内容以 Zookeeper 注册中心作为分析目标，其他类型注册中心大家可自行分析。下面从服务注册的入口方法开始分析，我们把目光再次移到 RegistryProtocol 的 export 方法上。如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('public <T> Exporter<T> export(final Invoker<T> originInvoker) throws RpcException {\n    \n    // ${导出服务}\n    \n    // 省略其他代码\n    \n    boolean register = registeredProviderUrl.getParameter("register", true);\n    if (register) {\n        // 注册服务\n        register(registryUrl, registeredProviderUrl);\n        ProviderConsumerRegTable.getProviderWrapper(originInvoker).setReg(true);\n    }\n    \n    final URL overrideSubscribeUrl = getSubscribedOverrideUrl(registeredProviderUrl);\n    final OverrideListener overrideSubscribeListener = new OverrideListener(overrideSubscribeUrl, originInvoker);\n    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);\n    // 订阅 override 数据\n    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);\n\n    // 省略部分代码\n}\n')])])]),r("p",[e._v("RegistryProtocol 的 export 方法包含了服务导出，注册，以及数据订阅等逻辑。其中服务导出逻辑上一节已经分析过了，本节将分析服务注册逻辑，数据订阅逻辑将在下一节进行分析。下面开始本节的分析，相关代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("public void register(URL registryUrl, URL registedProviderUrl) {\n    // 获取 Registry\n    Registry registry = registryFactory.getRegistry(registryUrl);\n    // 注册服务\n    registry.register(registedProviderUrl);\n}\n")])])]),r("p",[e._v("register 方法包含两步操作，第一步是获取注册中心实例，第二步是向注册中心注册服务。接下来，我分两节内容对这两步操作进行分析。按照顺序，先来分析获取注册中心的逻辑。")]),e._v(" "),r("h4",{attrs:{id:"_2-2-4-1-创建注册中心"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-4-1-创建注册中心"}},[e._v("#")]),e._v(" 2.2.4.1 创建注册中心")]),e._v(" "),r("p",[e._v("本节内容以 Zookeeper 注册中心为例进行分析。下面先来看一下 getRegistry 方法的源码，这个方法由 AbstractRegistryFactory 实现。如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('public Registry getRegistry(URL url) {\n    url = url.setPath(RegistryService.class.getName())\n            .addParameter(Constants.INTERFACE_KEY, RegistryService.class.getName())\n            .removeParameters(Constants.EXPORT_KEY, Constants.REFER_KEY);\n    String key = url.toServiceString();\n    LOCK.lock();\n    try {\n    \t// 访问缓存\n        Registry registry = REGISTRIES.get(key);\n        if (registry != null) {\n            return registry;\n        }\n        \n        // 缓存未命中，创建 Registry 实例\n        registry = createRegistry(url);\n        if (registry == null) {\n            throw new IllegalStateException("Can not create registry...");\n        }\n        \n        // 写入缓存\n        REGISTRIES.put(key, registry);\n        return registry;\n    } finally {\n        LOCK.unlock();\n    }\n}\n\nprotected abstract Registry createRegistry(URL url);\n')])])]),r("p",[e._v("如上，getRegistry 方法先访问缓存，缓存未命中则调用 createRegistry 创建 Registry，然后写入缓存。这里的 createRegistry 是一个模板方法，由具体的子类实现。因此，下面我们到 ZookeeperRegistryFactory 中探究一番。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("public class ZookeeperRegistryFactory extends AbstractRegistryFactory {\n\n    // zookeeperTransporter 由 SPI 在运行时注入，类型为 ZookeeperTransporter$Adaptive\n    private ZookeeperTransporter zookeeperTransporter;\n\n    public void setZookeeperTransporter(ZookeeperTransporter zookeeperTransporter) {\n        this.zookeeperTransporter = zookeeperTransporter;\n    }\n\n    @Override\n    public Registry createRegistry(URL url) {\n        // 创建 ZookeeperRegistry\n        return new ZookeeperRegistry(url, zookeeperTransporter);\n    }\n}\n")])])]),r("p",[e._v("ZookeeperRegistryFactory 的 createRegistry 方法仅包含一句代码，无需解释，继续跟下去。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('public ZookeeperRegistry(URL url, ZookeeperTransporter zookeeperTransporter) {\n    super(url);\n    if (url.isAnyHost()) {\n        throw new IllegalStateException("registry address == null");\n    }\n    \n    // 获取组名，默认为 dubbo\n    String group = url.getParameter(Constants.GROUP_KEY, DEFAULT_ROOT);\n    if (!group.startsWith(Constants.PATH_SEPARATOR)) {\n        // group = "/" + group\n        group = Constants.PATH_SEPARATOR + group;\n    }\n    this.root = group;\n    // 创建 Zookeeper 客户端，默认为 CuratorZookeeperTransporter\n    zkClient = zookeeperTransporter.connect(url);\n    // 添加状态监听器\n    zkClient.addStateListener(new StateListener() {\n        @Override\n        public void stateChanged(int state) {\n            if (state == RECONNECTED) {\n                try {\n                    recover();\n                } catch (Exception e) {\n                    logger.error(e.getMessage(), e);\n                }\n            }\n        }\n    });\n}\n')])])]),r("p",[e._v("在上面的代码代码中，我们重点关注 ZookeeperTransporter 的 connect 方法调用，这个方法用于创建 Zookeeper 客户端。创建好 Zookeeper 客户端，意味着注册中心的创建过程就结束了。不过，显然我们不能就此停止，难道大家没有兴趣了解一下 Zookeeper 客户端的创建过程吗？如果有，那么继续向下看。没有的话，直接跳到下一节。那我接着分析了。")]),e._v(" "),r("p",[e._v("前面说过，这里的 zookeeperTransporter 类型为自适应拓展类，因此 connect 方法会在被调用时决定加载什么类型的 ZookeeperTransporter 拓展，默认为 CuratorZookeeperTransporter。下面我们到 CuratorZookeeperTransporter 中看一看。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("public ZookeeperClient connect(URL url) {\n    // 创建 CuratorZookeeperClient\n    return new CuratorZookeeperClient(url);\n}\n")])])]),r("p",[e._v("上面方法仅用于创建 CuratorZookeeperClient 实例，没什么好说的，继续往下看。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('public class CuratorZookeeperClient extends AbstractZookeeperClient<CuratorWatcher> {\n\n    private final CuratorFramework client;\n    \n    public CuratorZookeeperClient(URL url) {\n        super(url);\n        try {\n            // 创建 CuratorFramework 构造器\n            CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder()\n                    .connectString(url.getBackupAddress())\n                    .retryPolicy(new RetryNTimes(1, 1000))\n                    .connectionTimeoutMs(5000);\n            String authority = url.getAuthority();\n            if (authority != null && authority.length() > 0) {\n                builder = builder.authorization("digest", authority.getBytes());\n            }\n            // 构建 CuratorFramework 实例\n            client = builder.build();\n            // 添加监听器\n            client.getConnectionStateListenable().addListener(new ConnectionStateListener() {\n                @Override\n                public void stateChanged(CuratorFramework client, ConnectionState state) {\n                    if (state == ConnectionState.LOST) {\n                        CuratorZookeeperClient.this.stateChanged(StateListener.DISCONNECTED);\n                    } else if (state == ConnectionState.CONNECTED) {\n                        CuratorZookeeperClient.this.stateChanged(StateListener.CONNECTED);\n                    } else if (state == ConnectionState.RECONNECTED) {\n                        CuratorZookeeperClient.this.stateChanged(StateListener.RECONNECTED);\n                    }\n                }\n            });\n            \n            // 启动客户端\n            client.start();\n        } catch (Exception e) {\n            throw new IllegalStateException(e.getMessage(), e);\n        }\n    }\n}\n')])])]),r("p",[e._v("CuratorZookeeperClient 构造方法主要用于创建和启动 CuratorFramework 实例。以上基本上都是 Curator 框架的代码，大家如果对 Curator 框架不是很了解，可以参考 Curator 官方文档，并写点 Demo 跑跑。")]),e._v(" "),r("p",[e._v("本节分析了 ZookeeperRegistry 实例的创建过程，整个过程并不是很复杂。大家在看完分析后，可以自行调试，以加深印象。现在注册中心实例创建好了，接下来要做的事情是向注册中心注册服务，我们继续往下看。")]),e._v(" "),r("h4",{attrs:{id:"_2-2-4-2-节点创建"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-4-2-节点创建"}},[e._v("#")]),e._v(" 2.2.4.2 节点创建")]),e._v(" "),r("p",[e._v("以 Zookeeper 为例，所谓的服务注册，本质上是将服务配置数据写入到 Zookeeper 的某个路径的节点下。为了验证这个说法，下面我们将 Dobbo 官方提供提供的实例跑起来，然后通过 Zookeeper 可视化客户端 "),r("a",{attrs:{href:"https://github.com/apache/zookeeper/tree/b79af153d0f98a4f3f3516910ed47234d7b3d74e/src/contrib/zooinspector",target:"_blank",rel:"noopener noreferrer"}},[e._v("ZooInspector"),r("OutboundLink")],1),e._v(" 查看节点数据。如下：")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15408854116509.jpg",alt:"img"}})]),e._v(" "),r("p",[e._v("从上图中可以看到 com.alibaba.dubbo.demo.DemoService 这个服务对应的配置信息（存储在 URL 中）最终被注册到了 /dubbo/com.alibaba.dubbo.demo.DemoService/providers/ 节点下。搞懂了服务注册的本质，那么接下来我们就可以去阅读服务注册的代码了。服务注册的接口为 register(URL)，这个方法定义在 FailbackRegistry 抽象类中。方法代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('public void register(URL url) {\n    super.register(url);\n    failedRegistered.remove(url);\n    failedUnregistered.remove(url);\n    try {\n        // 模板方法，由子类实现\n        doRegister(url);\n    } catch (Exception e) {\n        Throwable t = e;\n\n        // 获取 check 参数，若 check = true 将会直接抛出异常\n        boolean check = getUrl().getParameter(Constants.CHECK_KEY, true)\n                && url.getParameter(Constants.CHECK_KEY, true)\n                && !Constants.CONSUMER_PROTOCOL.equals(url.getProtocol());\n        boolean skipFailback = t instanceof SkipFailbackWrapperException;\n        if (check || skipFailback) {\n            if (skipFailback) {\n                t = t.getCause();\n            }\n            throw new IllegalStateException("Failed to register");\n        } else {\n            logger.error("Failed to register");\n        }\n\n        // 记录注册失败的链接\n        failedRegistered.add(url);\n    }\n}\n\nprotected abstract void doRegister(URL url);\n')])])]),r("p",[e._v("如上，我们重点关注 doRegister 方法调用即可，其他的代码先忽略。doRegister 方法是一个模板方法，因此我们到 FailbackRegistry 子类 ZookeeperRegistry 中进行分析。如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('protected void doRegister(URL url) {\n    try {\n        // 通过 Zookeeper 客户端创建节点，节点路径由 toUrlPath 方法生成，路径格式如下:\n        //   /${group}/${serviceInterface}/providers/${url}\n        // 比如\n        //   /dubbo/com.tianxiaobo.DemoService/providers/dubbo%3A%2F%2F127.0.0.1......\n        zkClient.create(toUrlPath(url), url.getParameter(Constants.DYNAMIC_KEY, true));\n    } catch (Throwable e) {\n        throw new RpcException("Failed to register...");\n    }\n}\n')])])]),r("p",[e._v("如上，ZookeeperRegistry 在 doRegister 中调用了 Zookeeper 客户端创建服务节点。节点路径由 toUrlPath 方法生成，该方法逻辑不难理解，就不分析了。接下来分析 create 方法，如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("public void create(String path, boolean ephemeral) {\n    if (!ephemeral) {\n        // 如果要创建的节点类型非临时节点，那么这里要检测节点是否存在\n        if (checkExists(path)) {\n            return;\n        }\n    }\n    int i = path.lastIndexOf('/');\n    if (i > 0) {\n        create(path.substring(0, i), false);    // 递归创建上一级路径\n    }\n    \n    // 根据 ephemeral 的值创建临时或持久节点\n    if (ephemeral) {\n        createEphemeral(path);\n    } else {\n        createPersistent(path);\n    }\n}\n")])])]),r("p",[e._v("上面方法先是通过递归创建当前节点的上一级路径，然后再根据 ephemeral 的值决定创建临时还是持久节点。createEphemeral 和 createPersistent 这两个方法都比较简单，这里简单分析其中的一个。如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("public void createEphemeral(String path) {\n    try {\n        // 通过 Curator 框架创建节点\n        client.create().withMode(CreateMode.EPHEMERAL).forPath(path);\n    } catch (NodeExistsException e) {\n    } catch (Exception e) {\n        throw new IllegalStateException(e.getMessage(), e);\n    }\n}\n")])])]),r("p",[e._v("好了，到此关于服务注册的过程就分析完了。整个过程可简单总结为：先创建注册中心实例，之后再通过注册中心实例注册服务。本节先到这，接下来分析数据订阅过程。")]),e._v(" "),r("h3",{attrs:{id:"_2-2-5-订阅-override-数据"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-5-订阅-override-数据"}},[e._v("#")]),e._v(" 2.2.5 订阅 override 数据")]),e._v(" "),r("p",[e._v("订阅 override 数据对应的代码我粗略看了一遍，这部分代码的主要目的是为了在服务配置发生变化时，重新导出服务。具体的使用场景应该当我们通过 Dubbo 管理后台修改了服务配置后，Dubbo 得到服务配置被修改的通知，然后重新导出服务。这个使用场景只是猜测，我并未进行过验证。如果大家有兴趣可以自行验证。")]),e._v(" "),r("p",[e._v("override 数据订阅相关代码也不是很少，考虑到文章篇幅问题以及重要性，遂决定不对此逻辑进行详细的分析。如果大家有兴趣，可自行分析。")])])}),[],!1,null,null,null);n.default=a.exports}}]);