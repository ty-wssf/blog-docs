(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{437:function(e,n,t){"use strict";t.r(n);var a=t(30),r=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"dubbo-源码分析-服务调用过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dubbo-源码分析-服务调用过程"}},[e._v("#")]),e._v(" Dubbo 源码分析 - 服务调用过程")]),e._v(" "),t("h2",{attrs:{id:"_1-简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-简介"}},[e._v("#")]),e._v(" 1. 简介")]),e._v(" "),t("p",[e._v("在前面的文章中，我们分析了 Dubbo SPI、服务导出与引入、以及集群容错方面的代码。经过前文的铺垫，本篇文章我们终于可以分析服务调用过程了。Dubbo 服务调用过程比较复杂，包含众多步骤。比如发送请求、编解码、服务降级、过滤器链处理、序列化、线程派发以及响应请求等步骤。限于篇幅原因，本篇文章无法对所有的步骤一一进行分析。本篇文章将会重点分析请求的发送与接收、编解码、线程派发以及响应的发送与接收等过程，至于服务降级、过滤器链和序列化大家自行进行分析，也可以将其当成一个黑盒，暂时忽略也没关系。介绍完本篇文章要分析的内容，接下来我们进入正题吧。")]),e._v(" "),t("h2",{attrs:{id:"_2-源码分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-源码分析"}},[e._v("#")]),e._v(" 2. 源码分析")]),e._v(" "),t("p",[e._v("在进行源码分析之前，我们先来通过一张图了解 Dubbo 服务调用过程。")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15464925642600.jpg",alt:"img"}})]),e._v(" "),t("p",[e._v("首先服务消费者通过代理对象 Proxy 发起远程调用，接着通过网络客户端 Client 将编码后的请求发送给服务提供方的网络层上，也就是 Server。Server 在收到请求后，首先要做的事情是对数据包进行解码。然后将解码后的请求发送至分发器 Dispatcher，再由分发器将请求派发到指定的线程池上，最后由线程池调用具体的服务。这就是一个远程调用请求的发送与接收过程。至于响应的发送与接收过程，这张图中没有表现出来。对于这两个过程，我们也会进行详细分析。")]),e._v(" "),t("h3",{attrs:{id:"_2-1-服务调用方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-服务调用方式"}},[e._v("#")]),e._v(" 2.1 服务调用方式")]),e._v(" "),t("p",[e._v("Dubbo 支持同步和异步两种调用方式，其中异步调用还可细分为“有返回值”的异步调用和“无返回值”的异步调用。所谓“无返回值”异步调用是指服务消费方只管调用，但不关心调用结果，此时 Dubbo 会直接返回一个空的 RpcResult。若要使用异步特性，需要服务消费方手动进行配置。默认情况下，Dubbo 使用同步调用方式。")]),e._v(" "),t("p",[e._v("本节以及其他章节将会使用 Dubbo 官方提供的 Demo 分析整个调用过程，下面我们从 DemoService 接口的代理类开始进行分析。Dubbo 默认使用 Javassist 框架为服务接口生成动态代理类，因此我们需要先将代理类进行反编译才能看到源码。这里使用阿里开源 Java 应用诊断工具 "),t("a",{attrs:{href:"https://github.com/alibaba/arthas",target:"_blank",rel:"noopener noreferrer"}},[e._v("Arthas"),t("OutboundLink")],1),e._v(" 反编译代理类，结果如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("/**\n * Arthas 反编译步骤：\n * 1. 启动 Arthas\n *    java -jar arthas-boot.jar\n *\n * 2. 输入编号选择进程\n *    Arthas 启动后，会打印 Java 应用进程列表，比如：\n *    [1]: 11232 org.jetbrains.jps.cmdline.Launcher\n *    [2]: 22370 org.jetbrains.jps.cmdline.Launcher\n *    [3]: 22371 com.alibaba.dubbo.demo.consumer.Consumer\n *    [4]: 22362 com.alibaba.dubbo.demo.provider.Provider\n *    [5]: 2074 org.apache.zookeeper.server.quorum.QuorumPeerMain\n * 这里输入编号 3，让 Arthas 关联到启动类为 com.....Consumer 的 Java 进程上\n *\n * 3. 由于 Demo 项目中只有一个服务接口，因此此接口的代理类类名为 proxy0，此时使用 sc 命令搜索这个类名。\n *    $ sc *.proxy0\n *    com.alibaba.dubbo.common.bytecode.proxy0\n *\n * 4. 使用 jad 命令反编译 com.alibaba.dubbo.common.bytecode.proxy0\n *    $ jad com.alibaba.dubbo.common.bytecode.proxy0\n *\n * 更多使用方法请参考 Arthas 官方文档：\n *   https://alibaba.github.io/arthas/quick-start.html\n */\npublic class proxy0 implements ClassGenerator.DC, EchoService, DemoService {\n    // 方法数组\n    public static Method[] methods;\n    private InvocationHandler handler;\n\n    public proxy0(InvocationHandler invocationHandler) {\n        this.handler = invocationHandler;\n    }\n\n    public proxy0() {\n    }\n\n    public String sayHello(String string) {\n        // 将参数存储到 Object 数组中\n        Object[] arrobject = new Object[]{string};\n        // 调用 InvocationHandler 实现类的 invoke 方法得到调用结果\n        Object object = this.handler.invoke(this, methods[0], arrobject);\n        // 返回调用结果\n        return (String)object;\n    }\n\n    /** 回声测试方法 */\n    public Object $echo(Object object) {\n        Object[] arrobject = new Object[]{object};\n        Object object2 = this.handler.invoke(this, methods[1], arrobject);\n        return object2;\n    }\n}\n")])])]),t("p",[e._v("如上，代理类的逻辑比较简单。首先将运行时参数存储到数组中，然后调用 InvocationHandler 接口实现类的 invoke 方法，得到调用结果，最后将结果转型并返回给调用方。关于代理类的逻辑就说这么多，继续向下分析。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public class InvokerInvocationHandler implements InvocationHandler {\n\n    private final Invoker<?> invoker;\n\n    public InvokerInvocationHandler(Invoker<?> handler) {\n        this.invoker = handler;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        String methodName = method.getName();\n        Class<?>[] parameterTypes = method.getParameterTypes();\n        \n        // 拦截定义在 Object 类中的方法（未被子类重写），比如 wait/notify\n        if (method.getDeclaringClass() == Object.class) {\n            return method.invoke(invoker, args);\n        }\n        \n        // 如果 toString、hashCode 和 equals 等方法被子类重写了，这里也直接调用\n        if ("toString".equals(methodName) && parameterTypes.length == 0) {\n            return invoker.toString();\n        }\n        if ("hashCode".equals(methodName) && parameterTypes.length == 0) {\n            return invoker.hashCode();\n        }\n        if ("equals".equals(methodName) && parameterTypes.length == 1) {\n            return invoker.equals(args[0]);\n        }\n        \n        // 将 method 和 args 封装到 RpcInvocation 中，并执行后续的调用\n        return invoker.invoke(new RpcInvocation(method, args)).recreate();\n    }\n}\n')])])]),t("p",[e._v("InvokerInvocationHandler 中的 invoker 成员变量类型为 MockClusterInvoker，MockClusterInvoker 内部封装了服务降级逻辑。下面简单看一下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public class MockClusterInvoker<T> implements Invoker<T> {\n    \n    private final Invoker<T> invoker;\n    \n    public Result invoke(Invocation invocation) throws RpcException {\n        Result result = null;\n\n        // 获取 mock 配置值\n        String value = directory.getUrl().getMethodParameter(invocation.getMethodName(), Constants.MOCK_KEY, Boolean.FALSE.toString()).trim();\n        if (value.length() == 0 || value.equalsIgnoreCase("false")) {\n            // 无 mock 逻辑，直接调用其他 Invoker 对象的 invoke 方法，\n            // 比如 FailoverClusterInvoker\n            result = this.invoker.invoke(invocation);\n        } else if (value.startsWith("force")) {\n            // force:xxx 直接执行 mock 逻辑，不发起远程调用\n            result = doMockInvoke(invocation, null);\n        } else {\n            // fail:xxx 表示消费方对调用服务失败后，再执行 mock 逻辑，不抛出异常\n            try {\n                // 调用其他 Invoker 对象的 invoke 方法\n                result = this.invoker.invoke(invocation);\n            } catch (RpcException e) {\n                if (e.isBiz()) {\n                    throw e;\n                } else {\n                    // 调用失败，执行 mock 逻辑\n                    result = doMockInvoke(invocation, e);\n                }\n            }\n        }\n        return result;\n    }\n    \n    // 省略其他方法\n}\n')])])]),t("p",[e._v("服务降级不是本文重点，因此这里就不分析 doMockInvoke 方法了。考虑到前文已经详细分析过 FailoverClusterInvoker，因此本节略过 FailoverClusterInvoker，直接分析 DubboInvoker。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public abstract class AbstractInvoker<T> implements Invoker<T> {\n    \n    public Result invoke(Invocation inv) throws RpcException {\n        if (destroyed.get()) {\n            throw new RpcException("Rpc invoker for service ...");\n        }\n        RpcInvocation invocation = (RpcInvocation) inv;\n        // 设置 Invoker\n        invocation.setInvoker(this);\n        if (attachment != null && attachment.size() > 0) {\n            // 设置 attachment\n            invocation.addAttachmentsIfAbsent(attachment);\n        }\n        Map<String, String> contextAttachments = RpcContext.getContext().getAttachments();\n        if (contextAttachments != null && contextAttachments.size() != 0) {\n            // 添加 contextAttachments 到 RpcInvocation#attachment 变量中\n            invocation.addAttachments(contextAttachments);\n        }\n        if (getUrl().getMethodParameter(invocation.getMethodName(), Constants.ASYNC_KEY, false)) {\n            // 设置异步信息到 RpcInvocation#attachment 中\n            invocation.setAttachment(Constants.ASYNC_KEY, Boolean.TRUE.toString());\n        }\n        RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);\n\n        try {\n            // 抽象方法，由子类实现\n            return doInvoke(invocation);\n        } catch (InvocationTargetException e) {\n            // ...\n        } catch (RpcException e) {\n            // ...\n        } catch (Throwable e) {\n            return new RpcResult(e);\n        }\n    }\n\n    protected abstract Result doInvoke(Invocation invocation) throws Throwable;\n    \n    // 省略其他方法\n}\n')])])]),t("p",[e._v("上面的代码来自 AbstractInvoker 类，其中大部分代码用于添加信息到 RpcInvocation#attachment 变量中，添加完毕后，调用 doInvoke 执行后续的调用。doInvoke 是一个抽象方法，需要由子类实现，下面到 DubboInvoker 中看一下。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public class DubboInvoker<T> extends AbstractInvoker<T> {\n    \n    private final ExchangeClient[] clients;\n    \n    protected Result doInvoke(final Invocation invocation) throws Throwable {\n        RpcInvocation inv = (RpcInvocation) invocation;\n        final String methodName = RpcUtils.getMethodName(invocation);\n        // 设置 path 和 version 到 attachment 中\n        inv.setAttachment(Constants.PATH_KEY, getUrl().getPath());\n        inv.setAttachment(Constants.VERSION_KEY, version);\n\n        ExchangeClient currentClient;\n        if (clients.length == 1) {\n            // 从 clients 数组中获取 ExchangeClient\n            currentClient = clients[0];\n        } else {\n            currentClient = clients[index.getAndIncrement() % clients.length];\n        }\n        try {\n            // 获取异步配置\n            boolean isAsync = RpcUtils.isAsync(getUrl(), invocation);\n            // isOneway 为 true，表示“单向”通信\n            boolean isOneway = RpcUtils.isOneway(getUrl(), invocation);\n            int timeout = getUrl().getMethodParameter(methodName, Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);\n\n            // 异步无返回值\n            if (isOneway) {\n                boolean isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, false);\n                // 发送请求\n                currentClient.send(inv, isSent);\n                // 设置上下文中的 future 为 null\n                RpcContext.getContext().setFuture(null);\n                // 返回一个空的 RpcResult\n                return new RpcResult();\n            } \n\n            // 异步有返回值\n            else if (isAsync) {\n                // 发送请求，获得 ResponseFuture 实例\n                ResponseFuture future = currentClient.request(inv, timeout);\n                // 设置 future 到上下文中\n                RpcContext.getContext().setFuture(new FutureAdapter<Object>(future));\n                // 暂时返回一个空结果\n                return new RpcResult();\n            } \n\n            // 同步调用\n            else {\n                RpcContext.getContext().setFuture(null);\n                // 发送请求，得到一个 ResponseFuture 实例，并调用该实例的 get 方法进行等待\n                return (Result) currentClient.request(inv, timeout).get();\n            }\n        } catch (TimeoutException e) {\n            throw new RpcException(..., "Invoke remote method timeout....");\n        } catch (RemotingException e) {\n            throw new RpcException(..., "Failed to invoke remote method: ...");\n        }\n    }\n    \n    // 省略其他方法\n}\n')])])]),t("p",[e._v("上面的代码包含了 Dubbo 对同步和异步调用的处理逻辑，搞懂了上面的代码，会对 Dubbo 的同步和异步调用方式有更深入的了解。Dubbo 实现同步和异步调用比较关键的一点就在于由谁调用 ResponseFuture 的 get 方法。同步调用模式下，由框架自身调用 ResponseFuture 的 get 方法。异步调用模式下，则由用户调用该方法。ResponseFuture 是一个接口，下面我们来看一下它的默认实现类 DefaultFuture 的源码。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public class DefaultFuture implements ResponseFuture {\n    \n    private static final Map<Long, Channel> CHANNELS = \n        new ConcurrentHashMap<Long, Channel>();\n\n    private static final Map<Long, DefaultFuture> FUTURES = \n        new ConcurrentHashMap<Long, DefaultFuture>();\n    \n    private final long id;\n    private final Channel channel;\n    private final Request request;\n    private final int timeout;\n    private final Lock lock = new ReentrantLock();\n    private final Condition done = lock.newCondition();\n    private volatile Response response;\n    \n    public DefaultFuture(Channel channel, Request request, int timeout) {\n        this.channel = channel;\n        this.request = request;\n        \n        // 获取请求 id，这个 id 很重要，后面还会见到\n        this.id = request.getId();\n        this.timeout = timeout > 0 ? timeout : channel.getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);\n        // 存储 <requestId, DefaultFuture> 映射关系到 FUTURES 中\n        FUTURES.put(id, this);\n        CHANNELS.put(id, channel);\n    }\n    \n    @Override\n    public Object get() throws RemotingException {\n        return get(timeout);\n    }\n\n    @Override\n    public Object get(int timeout) throws RemotingException {\n        if (timeout <= 0) {\n            timeout = Constants.DEFAULT_TIMEOUT;\n        }\n        if (!isDone()) {\n            long start = System.currentTimeMillis();\n            lock.lock();\n            try {\n                // 循环检测服务提供方是否成功返回了调用结果\n                while (!isDone()) {\n                    // 如果调用结果尚未返回，这里等待一段时间\n                    done.await(timeout, TimeUnit.MILLISECONDS);\n                    // 如果调用结果成功返回，或等待超时，此时跳出 while 循环，执行后续的逻辑\n                    if (isDone() || System.currentTimeMillis() - start > timeout) {\n                        break;\n                    }\n                }\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            } finally {\n                lock.unlock();\n            }\n            \n            // 如果调用结果仍未返回，则抛出超时异常\n            if (!isDone()) {\n                throw new TimeoutException(sent > 0, channel, getTimeoutMessage(false));\n            }\n        }\n        \n        // 返回调用结果\n        return returnFromResponse();\n    }\n    \n    @Override\n    public boolean isDone() {\n        // 通过检测 response 字段为空与否，判断是否收到了调用结果\n        return response != null;\n    }\n    \n    private Object returnFromResponse() throws RemotingException {\n        Response res = response;\n        if (res == null) {\n            throw new IllegalStateException("response cannot be null");\n        }\n        \n        // 如果调用结果的状态为 Response.OK，则表示调用过程正常，服务提供方成功返回了调用结果\n        if (res.getStatus() == Response.OK) {\n            return res.getResult();\n        }\n        \n        // 抛出异常\n        if (res.getStatus() == Response.CLIENT_TIMEOUT || res.getStatus() == Response.SERVER_TIMEOUT) {\n            throw new TimeoutException(res.getStatus() == Response.SERVER_TIMEOUT, channel, res.getErrorMessage());\n        }\n        throw new RemotingException(channel, res.getErrorMessage());\n    }\n    \n    // 省略其他方法\n}\n')])])]),t("p",[e._v("如上，当服务消费者还未接收到调用结果时，用户线程调用 get 方法会被阻塞住。同步调用模式下，框架获得 DefaultFuture 对象后，会立即调用 get 方法进行等待。而异步模式下则是将该对象封装到 FutureAdapter 实例中，并将 FutureAdapter 实例设置到 RpcContext 中，供用户使用。FutureAdapter 是一个适配器，用于将 Dubbo 中的 ResponseFuture 与 JDK 中的 Future 进行适配。这样当用户线程调用 Future 的 get 方法时，经过 FutureAdapter 适配，最终会调用 ResponseFuture 实现类对象的 get 方法，也就是 DefaultFuture 的 get 方法。")]),e._v(" "),t("p",[e._v("到这里关于 Dubbo 几种调用方式的代码逻辑就分析完了，下面来分析请求数据的发送与接收，以及响应数据的发送与接收过程。")]),e._v(" "),t("h3",{attrs:{id:"_2-2-服务消费方发送请求"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-服务消费方发送请求"}},[e._v("#")]),e._v(" 2.2 服务消费方发送请求")]),e._v(" "),t("h4",{attrs:{id:"_2-2-1-发送请求"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-1-发送请求"}},[e._v("#")]),e._v(" 2.2.1 发送请求")]),e._v(" "),t("p",[e._v("本节我们来看一下同步调用模式下，服务消费方是如何发送调用请求的。在深入分析源码前，我们先来看一张图。")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15465692163211.jpg",alt:"img"}})]),e._v(" "),t("p",[e._v("这张图展示了服务消费方发送请求过程的部分调用栈，略为复杂。从上图可以看出，经过多次调用后，才将请求数据送至 Netty NioClientSocketChannel。这样做的原因是通过 Exchange 层为框架引入 Request 和 Response 语义，这一点会在接下来的源码分析过程中会看到。其他的就不多说了，下面开始进行分析。首先分析 ReferenceCountExchangeClient 的源码。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("final class ReferenceCountExchangeClient implements ExchangeClient {\n\n    private final URL url;\n    private final AtomicInteger referenceCount = new AtomicInteger(0);\n\n    public ReferenceCountExchangeClient(ExchangeClient client, ConcurrentMap<String, LazyConnectExchangeClient> ghostClientMap) {\n        this.client = client;\n        // 引用计数自增\n        referenceCount.incrementAndGet();\n        this.url = client.getUrl();\n        \n        // ...\n    }\n\n    @Override\n    public ResponseFuture request(Object request) throws RemotingException {\n        // 直接调用被装饰对象的同签名方法\n        return client.request(request);\n    }\n\n    @Override\n    public ResponseFuture request(Object request, int timeout) throws RemotingException {\n        // 直接调用被装饰对象的同签名方法\n        return client.request(request, timeout);\n    }\n\n    /** 引用计数自增，该方法由外部调用 */\n    public void incrementAndGetCount() {\n        // referenceCount 自增\n        referenceCount.incrementAndGet();\n    }\n    \n        @Override\n    public void close(int timeout) {\n        // referenceCount 自减\n        if (referenceCount.decrementAndGet() <= 0) {\n            if (timeout == 0) {\n                client.close();\n            } else {\n                client.close(timeout);\n            }\n            client = replaceWithLazyClient();\n        }\n    }\n    \n    // 省略部分方法\n}\n")])])]),t("p",[e._v("ReferenceCountExchangeClient 内部定义了一个引用计数变量 referenceCount，每当该对象被引用一次 referenceCount 都会进行自增。每当 close 方法被调用时，referenceCount 进行自减。ReferenceCountExchangeClient 内部仅实现了一个引用计数的功能，其他方法并无复杂逻辑，均是直接调用被装饰对象的相关方法。所以这里就不多说了，继续向下分析，这次是 HeaderExchangeClient。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public class HeaderExchangeClient implements ExchangeClient {\n\n    private static final ScheduledThreadPoolExecutor scheduled = new ScheduledThreadPoolExecutor(2, new NamedThreadFactory("dubbo-remoting-client-heartbeat", true));\n    private final Client client;\n    private final ExchangeChannel channel;\n    private ScheduledFuture<?> heartbeatTimer;\n    private int heartbeat;\n    private int heartbeatTimeout;\n\n    public HeaderExchangeClient(Client client, boolean needHeartbeat) {\n        if (client == null) {\n            throw new IllegalArgumentException("client == null");\n        }\n        this.client = client;\n        \n        // 创建 HeaderExchangeChannel 对象\n        this.channel = new HeaderExchangeChannel(client);\n        \n        // 以下代码均与心跳检测逻辑有关\n        String dubbo = client.getUrl().getParameter(Constants.DUBBO_VERSION_KEY);\n        this.heartbeat = client.getUrl().getParameter(Constants.HEARTBEAT_KEY, dubbo != null && dubbo.startsWith("1.0.") ? Constants.DEFAULT_HEARTBEAT : 0);\n        this.heartbeatTimeout = client.getUrl().getParameter(Constants.HEARTBEAT_TIMEOUT_KEY, heartbeat * 3);\n        if (heartbeatTimeout < heartbeat * 2) {\n            throw new IllegalStateException("heartbeatTimeout < heartbeatInterval * 2");\n        }\n        if (needHeartbeat) {\n            // 开启心跳检测定时器\n            startHeartbeatTimer();\n        }\n    }\n\n    @Override\n    public ResponseFuture request(Object request) throws RemotingException {\n        // 直接 HeaderExchangeChannel 对象的同签名方法\n        return channel.request(request);\n    }\n\n    @Override\n    public ResponseFuture request(Object request, int timeout) throws RemotingException {\n        // 直接 HeaderExchangeChannel 对象的同签名方法\n        return channel.request(request, timeout);\n    }\n\n    @Override\n    public void close() {\n        doClose();\n        channel.close();\n    }\n    \n    private void doClose() {\n        // 停止心跳检测定时器\n        stopHeartbeatTimer();\n    }\n\n    private void startHeartbeatTimer() {\n        stopHeartbeatTimer();\n        if (heartbeat > 0) {\n            heartbeatTimer = scheduled.scheduleWithFixedDelay(\n                    new HeartBeatTask(new HeartBeatTask.ChannelProvider() {\n                        @Override\n                        public Collection<Channel> getChannels() {\n                            return Collections.<Channel>singletonList(HeaderExchangeClient.this);\n                        }\n                    }, heartbeat, heartbeatTimeout),\n                    heartbeat, heartbeat, TimeUnit.MILLISECONDS);\n        }\n    }\n\n    private void stopHeartbeatTimer() {\n        if (heartbeatTimer != null && !heartbeatTimer.isCancelled()) {\n            try {\n                heartbeatTimer.cancel(true);\n                scheduled.purge();\n            } catch (Throwable e) {\n                if (logger.isWarnEnabled()) {\n                    logger.warn(e.getMessage(), e);\n                }\n            }\n        }\n        heartbeatTimer = null;\n    }\n    \n    // 省略部分方法\n}\n')])])]),t("p",[e._v("HeaderExchangeClient 中很多方法只有一行代码，即调用 HeaderExchangeChannel 对象的同签名方法。那 HeaderExchangeClient 有什么用处呢？答案是封装了一些关于心跳检测的逻辑。心跳检测并非本文所关注的点，因此就不多说了，继续向下看。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('final class HeaderExchangeChannel implements ExchangeChannel {\n    \n    private final Channel channel;\n    \n    HeaderExchangeChannel(Channel channel) {\n        if (channel == null) {\n            throw new IllegalArgumentException("channel == null");\n        }\n        \n        // 这里的 channel 指向的是 NettyClient\n        this.channel = channel;\n    }\n    \n    @Override\n    public ResponseFuture request(Object request) throws RemotingException {\n        return request(request, channel.getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT));\n    }\n\n    @Override\n    public ResponseFuture request(Object request, int timeout) throws RemotingException {\n        if (closed) {\n            throw new RemotingException(..., "Failed to send request ...");\n        }\n        // 创建 Request 对象\n        Request req = new Request();\n        req.setVersion(Version.getProtocolVersion());\n        // 设置双向通信标志为 true\n        req.setTwoWay(true);\n        // 这里的 request 变量类型为 RpcInvocation\n        req.setData(request);\n                                        \n        // 创建 DefaultFuture 对象\n        DefaultFuture future = new DefaultFuture(channel, req, timeout);\n        try {\n            // 调用 NettyClient 的 send 方法发送请求\n            channel.send(req);\n        } catch (RemotingException e) {\n            future.cancel();\n            throw e;\n        }\n        // 返回 DefaultFuture 对象\n        return future;\n    }\n}\n')])])]),t("p",[e._v("到这里大家终于看到了 Request 语义了，上面的方法首先定义了一个 Request 对象，然后再将该对象传给 NettyClient 的 send 方法，进行后续的调用。需要说明的是，NettyClient 中并未实现 send 方法，该方法继承自父类 AbstractPeer，下面直接分析 AbstractPeer 的代码。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public abstract class AbstractPeer implements Endpoint, ChannelHandler {\n    \n    @Override\n    public void send(Object message) throws RemotingException {\n        // 该方法由 AbstractClient 类实现\n        send(message, url.getParameter(Constants.SENT_KEY, false));\n    }\n    \n    // 省略其他方法\n}\n\npublic abstract class AbstractClient extends AbstractEndpoint implements Client {\n    \n    @Override\n    public void send(Object message, boolean sent) throws RemotingException {\n        if (send_reconnect && !isConnected()) {\n            connect();\n        }\n        \n        // 获取 Channel，getChannel 是一个抽象方法，具体由子类实现\n        Channel channel = getChannel();\n        if (channel == null || !channel.isConnected()) {\n            throw new RemotingException(this, "message can not send ...");\n        }\n        \n        // 继续向下调用\n        channel.send(message, sent);\n    }\n    \n    protected abstract Channel getChannel();\n    \n    // 省略其他方法\n}\n')])])]),t("p",[e._v("默认情况下，Dubbo 使用 Netty 作为底层的通信框架，因此下面我们到 NettyClient 类中看一下 getChannel 方法的实现逻辑。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public class NettyClient extends AbstractClient {\n    \n    // 这里的 Channel 全限定名称为 org.jboss.netty.channel.Channel\n    private volatile Channel channel;\n\n    @Override\n    protected com.alibaba.dubbo.remoting.Channel getChannel() {\n        Channel c = channel;\n        if (c == null || !c.isConnected())\n            return null;\n        // 获取一个 NettyChannel 类型对象\n        return NettyChannel.getOrAddChannel(c, getUrl(), this);\n    }\n}\n\nfinal class NettyChannel extends AbstractChannel {\n\n    private static final ConcurrentMap<org.jboss.netty.channel.Channel, NettyChannel> channelMap = \n        new ConcurrentHashMap<org.jboss.netty.channel.Channel, NettyChannel>();\n\n    private final org.jboss.netty.channel.Channel channel;\n    \n    /** 私有构造方法 */\n    private NettyChannel(org.jboss.netty.channel.Channel channel, URL url, ChannelHandler handler) {\n        super(url, handler);\n        if (channel == null) {\n            throw new IllegalArgumentException("netty channel == null;");\n        }\n        this.channel = channel;\n    }\n\n    static NettyChannel getOrAddChannel(org.jboss.netty.channel.Channel ch, URL url, ChannelHandler handler) {\n        if (ch == null) {\n            return null;\n        }\n        \n        // 尝试从集合中获取 NettyChannel 实例\n        NettyChannel ret = channelMap.get(ch);\n        if (ret == null) {\n            // 如果 ret = null，则创建一个新的 NettyChannel 实例\n            NettyChannel nc = new NettyChannel(ch, url, handler);\n            if (ch.isConnected()) {\n                // 将 <Channel, NettyChannel> 键值对存入 channelMap 集合中\n                ret = channelMap.putIfAbsent(ch, nc);\n            }\n            if (ret == null) {\n                ret = nc;\n            }\n        }\n        return ret;\n    }\n}\n')])])]),t("p",[e._v("获取到 NettyChannel 实例后，即可进行后续的调用。下面看一下 NettyChannel 的 send 方法。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public void send(Object message, boolean sent) throws RemotingException {\n    super.send(message, sent);\n\n    boolean success = true;\n    int timeout = 0;\n    try {\n        // 发送消息(包含请求和响应消息)\n        ChannelFuture future = channel.write(message);\n        \n        // sent 的值源于 <dubbo:method sent="true/false" /> 中 sent 的配置值，有两种配置值：\n        //   1. true: 等待消息发出，消息发送失败将抛出异常\n        //   2. false: 不等待消息发出，将消息放入 IO 队列，即刻返回\n        // 默认情况下 sent = false；\n        if (sent) {\n            timeout = getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);\n            // 等待消息发出，若在规定时间没能发出，success 会被置为 false\n            success = future.await(timeout);\n        }\n        Throwable cause = future.getCause();\n        if (cause != null) {\n            throw cause;\n        }\n    } catch (Throwable e) {\n        throw new RemotingException(this, "Failed to send message ...");\n    }\n\n    // 若 success 为 false，这里抛出异常\n    if (!success) {\n        throw new RemotingException(this, "Failed to send message ...");\n    }\n}\n')])])]),t("p",[e._v("经历多次调用，到这里请求数据的发送过程就结束了，过程漫长。为了便于大家阅读代码，这里以 DemoService 为例，将 sayHello 方法的整个调用路径贴出来。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("proxy0#sayHello(String)\n  —> InvokerInvocationHandler#invoke(Object, Method, Object[])\n    —> MockClusterInvoker#invoke(Invocation)\n      —> AbstractClusterInvoker#invoke(Invocation)\n        —> FailoverClusterInvoker#doInvoke(Invocation, List<Invoker<T>>, LoadBalance)\n          —> Filter#invoke(Invoker, Invocation)  // 包含多个 Filter 调用\n            —> ListenerInvokerWrapper#invoke(Invocation) \n              —> AbstractInvoker#invoke(Invocation) \n                —> DubboInvoker#doInvoke(Invocation)\n                  —> ReferenceCountExchangeClient#request(Object, int)\n                    —> HeaderExchangeClient#request(Object, int)\n                      —> HeaderExchangeChannel#request(Object, int)\n                        —> AbstractPeer#send(Object)\n                          —> AbstractClient#send(Object, boolean)\n                            —> NettyChannel#send(Object, boolean)\n                              —> NioClientSocketChannel#write(Object)\n")])])]),t("p",[e._v("在 Netty 中，出站数据在发出之前还需要进行编码操作，接下来我们来分析一下请求数据的编码逻辑。")]),e._v(" "),t("h4",{attrs:{id:"_2-2-2-请求编码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-2-请求编码"}},[e._v("#")]),e._v(" 2.2.2 请求编码")]),e._v(" "),t("p",[e._v("在分析请求编码逻辑之前，我们先来看一下 Dubbo 数据包结构。")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15467560506028.jpg",alt:"img"}})]),e._v(" "),t("p",[e._v("Dubbo 数据包分为消息头和消息体，消息头用于存储一些元信息，比如魔数（Magic），数据包类型（Request/Response），消息体长度（Data Length）等。消息体中用于存储具体的调用消息，比如方法名称，参数列表等。下面简单列举一下消息头的内容。")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",{staticStyle:{"text-align":"left"}},[e._v("偏移量(Bit)")]),e._v(" "),t("th",{staticStyle:{"text-align":"left"}},[e._v("字段")]),e._v(" "),t("th",{staticStyle:{"text-align":"left"}},[e._v("取值")])])]),e._v(" "),t("tbody",[t("tr",[t("td",{staticStyle:{"text-align":"left"}},[e._v("0 ~ 7")]),e._v(" "),t("td",{staticStyle:{"text-align":"left"}},[e._v("魔数高位")]),e._v(" "),t("td",{staticStyle:{"text-align":"left"}},[e._v("0xda00")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"left"}},[e._v("8 ~ 15")]),e._v(" "),t("td",{staticStyle:{"text-align":"left"}},[e._v("魔数低位")]),e._v(" "),t("td",{staticStyle:{"text-align":"left"}},[e._v("0xbb")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"left"}},[e._v("16")]),e._v(" "),t("td",{staticStyle:{"text-align":"left"}},[e._v("数据包类型")]),e._v(" "),t("td",{staticStyle:{"text-align":"left"}},[e._v("0 - Response, 1 - Request")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"left"}},[e._v("17")]),e._v(" "),t("td",{staticStyle:{"text-align":"left"}},[e._v("调用方式")]),e._v(" "),t("td",{staticStyle:{"text-align":"left"}},[e._v("仅在第16位被设为1的情况下有效，0 - 单向调用，1 - 双向调用")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"left"}},[e._v("18")]),e._v(" "),t("td",{staticStyle:{"text-align":"left"}},[e._v("事件标识")]),e._v(" "),t("td",{staticStyle:{"text-align":"left"}},[e._v("0 - 当前数据包是请求或响应包，1 - 当前数据包是心跳包")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"left"}},[e._v("19 ~ 23")]),e._v(" "),t("td",{staticStyle:{"text-align":"left"}},[e._v("序列化器编号")]),e._v(" "),t("td",{staticStyle:{"text-align":"left"}},[e._v("2 - Hessian2Serialization 3 - JavaSerialization 4 - CompactedJavaSerialization 6 - FastJsonSerialization 7 - NativeJavaSerialization 8 - KryoSerialization 9 - FstSerialization")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"left"}},[e._v("24 ~ 31")]),e._v(" "),t("td",{staticStyle:{"text-align":"left"}},[e._v("状态")]),e._v(" "),t("td",{staticStyle:{"text-align":"left"}},[e._v("20 - OK 30 - CLIENT_TIMEOUT 31 - SERVER_TIMEOUT 40 - BAD_REQUEST 50 - BAD_RESPONSE …")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"left"}},[e._v("32 ~ 95")]),e._v(" "),t("td",{staticStyle:{"text-align":"left"}},[e._v("请求编号")]),e._v(" "),t("td",{staticStyle:{"text-align":"left"}},[e._v("共8字节，运行时生成")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"left"}},[e._v("96 ~ 127")]),e._v(" "),t("td",{staticStyle:{"text-align":"left"}},[e._v("消息体长度")]),e._v(" "),t("td",{staticStyle:{"text-align":"left"}},[e._v("运行时计算")])])])]),e._v(" "),t("p",[e._v("了解了 Dubbo 数据包格式，接下来我们就可以探索编码过程了。这次我们开门见山，直接分析编码逻辑所在类。如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public class ExchangeCodec extends TelnetCodec {\n\n    // 消息头长度\n    protected static final int HEADER_LENGTH = 16;\n    // 魔数内容\n    protected static final short MAGIC = (short) 0xdabb;\n    protected static final byte MAGIC_HIGH = Bytes.short2bytes(MAGIC)[0];\n    protected static final byte MAGIC_LOW = Bytes.short2bytes(MAGIC)[1];\n    protected static final byte FLAG_REQUEST = (byte) 0x80;\n    protected static final byte FLAG_TWOWAY = (byte) 0x40;\n    protected static final byte FLAG_EVENT = (byte) 0x20;\n    protected static final int SERIALIZATION_MASK = 0x1f;\n    private static final Logger logger = LoggerFactory.getLogger(ExchangeCodec.class);\n\n    public Short getMagicCode() {\n        return MAGIC;\n    }\n\n    @Override\n    public void encode(Channel channel, ChannelBuffer buffer, Object msg) throws IOException {\n        if (msg instanceof Request) {\n            // 对 Request 对象进行编码\n            encodeRequest(channel, buffer, (Request) msg);\n        } else if (msg instanceof Response) {\n            // 对 Response 对象进行编码，后面分析\n            encodeResponse(channel, buffer, (Response) msg);\n        } else {\n            super.encode(channel, buffer, msg);\n        }\n    }\n\n    protected void encodeRequest(Channel channel, ChannelBuffer buffer, Request req) throws IOException {\n        Serialization serialization = getSerialization(channel);\n\n        // 创建消息头字节数组，长度为 16\n        byte[] header = new byte[HEADER_LENGTH];\n\n        // 设置魔数\n        Bytes.short2bytes(MAGIC, header);\n\n        // 设置数据包类型（Request/Response）和序列化器编号\n        header[2] = (byte) (FLAG_REQUEST | serialization.getContentTypeId());\n\n        // 设置通信方式(单向/双向)\n        if (req.isTwoWay()) {\n            header[2] |= FLAG_TWOWAY;\n        }\n        \n        // 设置事件标识\n        if (req.isEvent()) {\n            header[2] |= FLAG_EVENT;\n        }\n\n        // 设置请求编号，8个字节，从第4个字节开始设置\n        Bytes.long2bytes(req.getId(), header, 4);\n\n        // 获取 buffer 当前的写位置\n        int savedWriteIndex = buffer.writerIndex();\n        // 更新 writerIndex，为消息头预留 16 个字节的空间\n        buffer.writerIndex(savedWriteIndex + HEADER_LENGTH);\n        ChannelBufferOutputStream bos = new ChannelBufferOutputStream(buffer);\n        // 创建序列化器，比如 Hessian2ObjectOutput\n        ObjectOutput out = serialization.serialize(channel.getUrl(), bos);\n        if (req.isEvent()) {\n            // 对事件数据进行序列化操作\n            encodeEventData(channel, out, req.getData());\n        } else {\n            // 对请求数据进行序列化操作\n            encodeRequestData(channel, out, req.getData(), req.getVersion());\n        }\n        out.flushBuffer();\n        if (out instanceof Cleanable) {\n            ((Cleanable) out).cleanup();\n        }\n        bos.flush();\n        bos.close();\n        \n        // 获取写入的字节数，也就是消息体长度\n        int len = bos.writtenBytes();\n        checkPayload(channel, len);\n\n        // 将消息体长度写入到消息头中\n        Bytes.int2bytes(len, header, 12);\n\n        // 将 buffer 指针移动到 savedWriteIndex，为写消息头做准备\n        buffer.writerIndex(savedWriteIndex);\n        // 从 savedWriteIndex 下标处写入消息头\n        buffer.writeBytes(header);\n        // 设置新的 writerIndex，writerIndex = 原写下标 + 消息头长度 + 消息体长度\n        buffer.writerIndex(savedWriteIndex + HEADER_LENGTH + len);\n    }\n    \n    // 省略其他方法\n}\n")])])]),t("p",[e._v("以上就是请求对象的编码过程，该过程首先会通过位运算将消息头写入到 header 数组中。然后对 Request 对象的 data 字段执行序列化操作，序列化后的数据最终会存储到 ChannelBuffer 中。序列化操作执行完后，可得到数据序列化后的长度 len，紧接着将 len 写入到 header 指定位置处。最后再将消息头字节数组 header 写入到 ChannelBuffer 中，整个编码过程就结束了。本节的最后，我们再来看一下 Request 对象的 data 字段序列化过程，也就是 encodeRequestData 方法的逻辑，如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public class DubboCodec extends ExchangeCodec implements Codec2 {\n    \n\tprotected void encodeRequestData(Channel channel, ObjectOutput out, Object data, String version) throws IOException {\n        RpcInvocation inv = (RpcInvocation) data;\n\n        // 依次序列化 dubbo version、path、version\n        out.writeUTF(version);\n        out.writeUTF(inv.getAttachment(Constants.PATH_KEY));\n        out.writeUTF(inv.getAttachment(Constants.VERSION_KEY));\n\n        // 序列化调用方法名\n        out.writeUTF(inv.getMethodName());\n        // 将参数类型转换为字符串，并进行序列化\n        out.writeUTF(ReflectUtils.getDesc(inv.getParameterTypes()));\n        Object[] args = inv.getArguments();\n        if (args != null)\n            for (int i = 0; i < args.length; i++) {\n                // 对运行时参数进行序列化\n                out.writeObject(encodeInvocationArgument(channel, inv, i));\n            }\n        \n        // 序列化 attachments\n        out.writeObject(inv.getAttachments());\n    }\n}\n")])])]),t("p",[e._v("至此，关于服务消费方发送请求的过程就分析完了，接下来我们来看一下服务提供方是如何接收请求的。")]),e._v(" "),t("h3",{attrs:{id:"_2-3-服务提供方接收请求"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-服务提供方接收请求"}},[e._v("#")]),e._v(" 2.3 服务提供方接收请求")]),e._v(" "),t("p",[e._v("前面说过，默认情况下 Dubbo 使用 Netty 作为底层的通信框架。Netty 检测到有数据入站后，首先会通过解码器对数据进行解码，并将解码后的数据传递给下一个入站处理器的指定方法。所以在进行后续的分析之前，我们先来看一下数据解码过程。")]),e._v(" "),t("h4",{attrs:{id:"_2-3-1-请求解码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-1-请求解码"}},[e._v("#")]),e._v(" 2.3.1 请求解码")]),e._v(" "),t("p",[e._v("这里直接分析请求数据的解码逻辑，忽略中间过程，如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public class ExchangeCodec extends TelnetCodec {\n    \n    @Override\n    public Object decode(Channel channel, ChannelBuffer buffer) throws IOException {\n        int readable = buffer.readableBytes();\n        // 创建消息头字节数组\n        byte[] header = new byte[Math.min(readable, HEADER_LENGTH)];\n        // 读取消息头数据\n        buffer.readBytes(header);\n        // 调用重载方法进行后续解码工作\n        return decode(channel, buffer, readable, header);\n    }\n\n    @Override\n    protected Object decode(Channel channel, ChannelBuffer buffer, int readable, byte[] header) throws IOException {\n        // 检查魔数是否相等\n        if (readable > 0 && header[0] != MAGIC_HIGH\n                || readable > 1 && header[1] != MAGIC_LOW) {\n            int length = header.length;\n            if (header.length < readable) {\n                header = Bytes.copyOf(header, readable);\n                buffer.readBytes(header, length, readable - length);\n            }\n            for (int i = 1; i < header.length - 1; i++) {\n                if (header[i] == MAGIC_HIGH && header[i + 1] == MAGIC_LOW) {\n                    buffer.readerIndex(buffer.readerIndex() - header.length + i);\n                    header = Bytes.copyOf(header, i);\n                    break;\n                }\n            }\n            // 通过 telnet 命令行发送的数据包不包含消息头，所以这里\n            // 调用 TelnetCodec 的 decode 方法对数据包进行解码\n            return super.decode(channel, buffer, readable, header);\n        }\n        \n        // 检测可读数据量是否少于消息头长度，若小于则立即返回 DecodeResult.NEED_MORE_INPUT\n        if (readable < HEADER_LENGTH) {\n            return DecodeResult.NEED_MORE_INPUT;\n        }\n\n        // 从消息头中获取消息体长度\n        int len = Bytes.bytes2int(header, 12);\n        // 检测消息体长度是否超出限制，超出则抛出异常\n        checkPayload(channel, len);\n\n        int tt = len + HEADER_LENGTH;\n        // 检测可读的字节数是否小于实际的字节数\n        if (readable < tt) {\n            return DecodeResult.NEED_MORE_INPUT;\n        }\n        \n        ChannelBufferInputStream is = new ChannelBufferInputStream(buffer, len);\n\n        try {\n            // 继续进行解码工作\n            return decodeBody(channel, is, header);\n        } finally {\n            if (is.available() > 0) {\n                try {\n                    StreamUtils.skipUnusedStream(is);\n                } catch (IOException e) {\n                    logger.warn(e.getMessage(), e);\n                }\n            }\n        }\n    }\n}\n")])])]),t("p",[e._v("上面方法通过检测消息头中的魔数是否与规定的魔数相等，提前拦截掉非常规数据包，比如通过 telnet 命令行发出的数据包。接着再对消息体长度，以及可读字节数进行检测。最后调用 decodeBody 方法进行后续的解码工作，ExchangeCodec 中实现了 decodeBody 方法，但因其子类 DubboCodec 覆写了该方法，所以在运行时 DubboCodec 中的 decodeBody 方法会被调用。下面我们来看一下该方法的代码。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public class DubboCodec extends ExchangeCodec implements Codec2 {\n\n    @Override\n    protected Object decodeBody(Channel channel, InputStream is, byte[] header) throws IOException {\n        // 获取消息头中的第三个字节，并通过逻辑与运算得到序列化器编号\n        byte flag = header[2], proto = (byte) (flag & SERIALIZATION_MASK);\n        Serialization s = CodecSupport.getSerialization(channel.getUrl(), proto);\n        // 获取调用编号\n        long id = Bytes.bytes2long(header, 4);\n        // 通过逻辑与运算得到调用类型，0 - Response，1 - Request\n        if ((flag & FLAG_REQUEST) == 0) {\n            // 对响应结果进行解码，得到 Response 对象。这个非本节内容，后面再分析\n            // ...\n        } else {\n            // 创建 Request 对象\n            Request req = new Request(id);\n            req.setVersion(Version.getProtocolVersion());\n            // 通过逻辑与运算得到通信方式，并设置到 Request 对象中\n            req.setTwoWay((flag & FLAG_TWOWAY) != 0);\n            \n            // 通过位运算检测数据包是否为事件类型\n            if ((flag & FLAG_EVENT) != 0) {\n                // 设置心跳事件到 Request 对象中\n                req.setEvent(Request.HEARTBEAT_EVENT);\n            }\n            try {\n                Object data;\n                if (req.isHeartbeat()) {\n                    // 对心跳包进行解码，该方法已被标注为废弃\n                    data = decodeHeartbeatData(channel, deserialize(s, channel.getUrl(), is));\n                } else if (req.isEvent()) {\n                    // 对事件数据进行解码\n                    data = decodeEventData(channel, deserialize(s, channel.getUrl(), is));\n                } else {\n                    DecodeableRpcInvocation inv;\n                    // 根据 url 参数判断是否在 IO 线程上对消息体进行解码\n                    if (channel.getUrl().getParameter(\n                            Constants.DECODE_IN_IO_THREAD_KEY,\n                            Constants.DEFAULT_DECODE_IN_IO_THREAD)) {\n                        inv = new DecodeableRpcInvocation(channel, req, is, proto);\n                        // 在当前线程，也就是 IO 线程上进行后续的解码工作。此工作完成后，可将\n                        // 调用方法名、attachment、以及调用参数解析出来\n                        inv.decode();\n                    } else {\n                        // 仅创建 DecodeableRpcInvocation 对象，但不在当前线程上执行解码逻辑\n                        inv = new DecodeableRpcInvocation(channel, req,\n                                new UnsafeByteArrayInputStream(readMessageData(is)), proto);\n                    }\n                    data = inv;\n                }\n                \n                // 设置 data 到 Request 对象中\n                req.setData(data);\n            } catch (Throwable t) {\n                // 若解码过程中出现异常，则将 broken 字段设为 true，\n                // 并将异常对象设置到 Reqeust 对象中\n                req.setBroken(true);\n                req.setData(t);\n            }\n            return req;\n        }\n    }\n}\n")])])]),t("p",[e._v("如上，decodeBody 对部分字段进行了解码，并将解码得到的字段封装到 Request 中。随后会调用 DecodeableRpcInvocation 的 decode 方法进行后续的解码工作。此工作完成后，可将调用方法名、attachment、以及运行时调用参数解析出来。下面我们来看一下 DecodeableRpcInvocation 的 decode 方法逻辑。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public class DecodeableRpcInvocation extends RpcInvocation implements Codec, Decodeable {\n    \n\t@Override\n    public Object decode(Channel channel, InputStream input) throws IOException {\n        ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType)\n                .deserialize(channel.getUrl(), input);\n\n        // 通过反序列化得到 dubbo version，并保存到 attachments 变量中\n        String dubboVersion = in.readUTF();\n        request.setVersion(dubboVersion);\n        setAttachment(Constants.DUBBO_VERSION_KEY, dubboVersion);\n\n        // 通过反序列化得到 path，version，并保存到 attachments 变量中\n        setAttachment(Constants.PATH_KEY, in.readUTF());\n        setAttachment(Constants.VERSION_KEY, in.readUTF());\n\n        // 通过反序列化得到调用方法名\n        setMethodName(in.readUTF());\n        try {\n            Object[] args;\n            Class<?>[] pts;\n            // 通过反序列化得到参数类型字符串，比如 Ljava/lang/String;\n            String desc = in.readUTF();\n            if (desc.length() == 0) {\n                pts = DubboCodec.EMPTY_CLASS_ARRAY;\n                args = DubboCodec.EMPTY_OBJECT_ARRAY;\n            } else {\n                // 将 desc 解析为参数类型数组\n                pts = ReflectUtils.desc2classArray(desc);\n                args = new Object[pts.length];\n                for (int i = 0; i < args.length; i++) {\n                    try {\n                        // 解析运行时参数\n                        args[i] = in.readObject(pts[i]);\n                    } catch (Exception e) {\n                        if (log.isWarnEnabled()) {\n                            log.warn("Decode argument failed: " + e.getMessage(), e);\n                        }\n                    }\n                }\n            }\n            \n            // 设置参数类型数组\n            setParameterTypes(pts);\n\n            // 通过反序列化得到原 attachments 的内容\n            Map<String, String> map = (Map<String, String>) in.readObject(Map.class);\n            if (map != null && map.size() > 0) {\n                Map<String, String> attachment = getAttachments();\n                if (attachment == null) {\n                    attachment = new HashMap<String, String>();\n                }\n                // 将 map 与当前对象中的 attachment 集合进行融合\n                attachment.putAll(map);\n                setAttachments(attachment);\n            }\n            \n            // 对 callback 类型的参数进行处理\n            for (int i = 0; i < args.length; i++) {\n                args[i] = decodeInvocationArgument(channel, this, pts, i, args[i]);\n            }\n\n            // 设置参数列表\n            setArguments(args);\n\n        } catch (ClassNotFoundException e) {\n            throw new IOException(StringUtils.toString("Read invocation data failed.", e));\n        } finally {\n            if (in instanceof Cleanable) {\n                ((Cleanable) in).cleanup();\n            }\n        }\n        return this;\n    }\n}\n')])])]),t("p",[e._v("上面的方法通过反序列化将诸如 path、version、调用方法名、参数列表等信息依次解析出来，并设置到相应的字段中，最终得到一个具有完整调用信息的 DecodeableRpcInvocation 对象。")]),e._v(" "),t("p",[e._v("到这里，请求数据解码的过程就分析完了。此时我们得到了一个 Request 对象，这个对象会被传送到下一个入站处理器中，我们继续往下看。")]),e._v(" "),t("h4",{attrs:{id:"_2-3-2-调用服务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-2-调用服务"}},[e._v("#")]),e._v(" 2.3.2 调用服务")]),e._v(" "),t("p",[e._v("解码器将数据包解析成 Request 对象后，NettyHandler 的 messageReceived 方法紧接着会收到这个对象，并将这个对象继续向下传递。这期间该对象会被依次传递给 NettyServer、MultiMessageHandler、HeartbeatHandler 以及 AllChannelHandler。最后由 AllChannelHandler 将该对象封装到 Runnable 实现类对象中，并将 Runnable 放入线程池中执行后续的调用逻辑。整个调用栈如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("NettyHandler#messageReceived(ChannelHandlerContext, MessageEvent)\n  —> AbstractPeer#received(Channel, Object)\n    —> MultiMessageHandler#received(Channel, Object)\n      —> HeartbeatHandler#received(Channel, Object)\n        —> AllChannelHandler#received(Channel, Object)\n          —> ExecutorService#execute(Runnable)    // 由线程池执行后续的调用逻辑\n")])])]),t("p",[e._v("考虑到篇幅，以及很多中间调用的逻辑并非十分重要，所以这里就不对调用栈中的每个方法都进行分析了。这里我们直接分析调用栈中的分析第一个和最后一个调用方法逻辑。如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('@Sharable\npublic class NettyHandler extends SimpleChannelHandler {\n    \n    private final Map<String, Channel> channels = new ConcurrentHashMap<String, Channel>();\n\n    private final URL url;\n\n    private final ChannelHandler handler;\n    \n    public NettyHandler(URL url, ChannelHandler handler) {\n        if (url == null) {\n            throw new IllegalArgumentException("url == null");\n        }\n        if (handler == null) {\n            throw new IllegalArgumentException("handler == null");\n        }\n        this.url = url;\n        \n        // 这里的 handler 类型为 NettyServer\n        this.handler = handler;\n    }\n    \n\tpublic void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {\n        // 获取 NettyChannel\n        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.getChannel(), url, handler);\n        try {\n            // 继续向下调用\n            handler.received(channel, e.getMessage());\n        } finally {\n            NettyChannel.removeChannelIfDisconnected(ctx.getChannel());\n        }\n    }\n}\n')])])]),t("p",[e._v("如上，NettyHandler 中的 messageReceived 逻辑比较简单。首先根据一些信息获取 NettyChannel 实例，然后将 NettyChannel 实例以及 Request 对象向下传递。下面再来看看 AllChannelHandler 的逻辑，在详细分析代码之前，我们先来了解一下 Dubbo 中的线程派发模型。")]),e._v(" "),t("h5",{attrs:{id:"_2-3-2-1-线程派发模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-2-1-线程派发模型"}},[e._v("#")]),e._v(" 2.3.2.1 线程派发模型")]),e._v(" "),t("p",[e._v("Dubbo 将底层通信框架中接收请求的线程称为 IO 线程。如果一些事件处理逻辑可以很快执行完，比如只在内存打一个标记，此时直接在 IO 线程上执行该段逻辑即可。但如果事件的处理逻辑比较耗时，比如该段逻辑会发起数据库查询或者 HTTP 请求。此时我们就不应该让事件处理逻辑在 IO 线程上执行，而是应该派发到线程池中去执行。原因也很简单，IO 线程主要用于接收请求，如果 IO 线程被占满，将导致它不能接收新的请求。")]),e._v(" "),t("p",[e._v("以上就是线程派发的背景，下面我们再来通过 Dubbo 调用图，看一下线程派发器所处的位置。")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15468300059945.jpg",alt:"img"}})]),e._v(" "),t("p",[e._v("如上图，红框中的 Dispatcher 就是线程派发器。需要说明的是，Dispatcher 真实的职责创建具有线程派发能力的 ChannelHandler，比如 AllChannelHandler、MessageOnlyChannelHandler 和 ExecutionChannelHandler 等，其本身并不具备线程派发能力。Dubbo 支持 5 种不同的线程派发策略，下面通过一个表格列举一下。")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",{staticStyle:{"text-align":"left"}},[e._v("策略")]),e._v(" "),t("th",{staticStyle:{"text-align":"left"}},[e._v("用途")])])]),e._v(" "),t("tbody",[t("tr",[t("td",{staticStyle:{"text-align":"left"}},[e._v("all")]),e._v(" "),t("td",{staticStyle:{"text-align":"left"}},[e._v("所有消息都派发到线程池，包括请求，响应，连接事件，断开事件等")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"left"}},[e._v("direct")]),e._v(" "),t("td",{staticStyle:{"text-align":"left"}},[e._v("所有消息都不派发到线程池，全部在 IO 线程上直接执行")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"left"}},[e._v("message")]),e._v(" "),t("td",{staticStyle:{"text-align":"left"}},[e._v("只有"),t("strong",[e._v("请求")]),e._v("和"),t("strong",[e._v("响应")]),e._v("消息派发到线程池，其它消息均在 IO 线程上执行")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"left"}},[e._v("execution")]),e._v(" "),t("td",{staticStyle:{"text-align":"left"}},[e._v("只有"),t("strong",[e._v("请求")]),e._v("消息派发到线程池，不含响应。其它消息均在 IO 线程上执行")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"left"}},[e._v("connection")]),e._v(" "),t("td",{staticStyle:{"text-align":"left"}},[e._v("在 IO 线程上，将连接断开事件放入队列，有序逐个执行，其它消息派发到线程池")])])])]),e._v(" "),t("p",[e._v("默认配置下，Dubbo 使用 "),t("code",[e._v("all")]),e._v(" 派发策略，即将所有的消息都派发到线程池中。下面我们来分析一下 AllChannelHandler 的代码。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public class AllChannelHandler extends WrappedChannelHandler {\n\n    public AllChannelHandler(ChannelHandler handler, URL url) {\n        super(handler, url);\n    }\n\n    /** 处理连接事件 */\n    @Override\n    public void connected(Channel channel) throws RemotingException {\n        // 获取线程池\n        ExecutorService cexecutor = getExecutorService();\n        try {\n            // 将连接事件派发到线程池中处理\n            cexecutor.execute(new ChannelEventRunnable(channel, handler, ChannelState.CONNECTED));\n        } catch (Throwable t) {\n            throw new ExecutionException(..., " error when process connected event .", t);\n        }\n    }\n\n    /** 处理断开事件 */\n    @Override\n    public void disconnected(Channel channel) throws RemotingException {\n        ExecutorService cexecutor = getExecutorService();\n        try {\n            cexecutor.execute(new ChannelEventRunnable(channel, handler, ChannelState.DISCONNECTED));\n        } catch (Throwable t) {\n            throw new ExecutionException(..., "error when process disconnected event .", t);\n        }\n    }\n\n    /** 处理请求和响应消息，这里的 message 变量类型可能是 Request，也可能是 Response */\n    @Override\n    public void received(Channel channel, Object message) throws RemotingException {\n        ExecutorService cexecutor = getExecutorService();\n        try {\n            // 将请求和响应消息派发到线程池中处理\n            cexecutor.execute(new ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message));\n        } catch (Throwable t) {\n            if(message instanceof Request && t instanceof RejectedExecutionException){\n                Request request = (Request)message;\n                // 如果通信方式为双向通信，此时将 Server side ... threadpool is exhausted \n                // 错误信息封装到 Response 中，并返回给服务消费方。\n                if(request.isTwoWay()){\n                    String msg = "Server side(" + url.getIp() + "," + url.getPort() \n                        + ") threadpool is exhausted ,detail msg:" + t.getMessage();\n                    Response response = new Response(request.getId(), request.getVersion());\n                    response.setStatus(Response.SERVER_THREADPOOL_EXHAUSTED_ERROR);\n                    response.setErrorMessage(msg);\n                    // 返回包含错误信息的 Response 对象\n                    channel.send(response);\n                    return;\n                }\n            }\n            throw new ExecutionException(..., " error when process received event .", t);\n        }\n    }\n\n    /** 处理异常信息 */\n    @Override\n    public void caught(Channel channel, Throwable exception) throws RemotingException {\n        ExecutorService cexecutor = getExecutorService();\n        try {\n            cexecutor.execute(new ChannelEventRunnable(channel, handler, ChannelState.CAUGHT, exception));\n        } catch (Throwable t) {\n            throw new ExecutionException(..., "error when process caught event ...");\n        }\n    }\n}\n')])])]),t("p",[e._v("如上，请求对象会被封装 ChannelEventRunnable 中，ChannelEventRunnable 将会是服务调用过程的新起点。所以接下来我们以 ChannelEventRunnable 为起点向下探索。")]),e._v(" "),t("h5",{attrs:{id:"_2-3-2-2-调用服务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-2-2-调用服务"}},[e._v("#")]),e._v(" 2.3.2.2 调用服务")]),e._v(" "),t("p",[e._v("本小节，我们从 ChannelEventRunnable 开始分析，该类的主要代码如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public class ChannelEventRunnable implements Runnable {\n    \n    private final ChannelHandler handler;\n    private final Channel channel;\n    private final ChannelState state;\n    private final Throwable exception;\n    private final Object message;\n    \n    @Override\n    public void run() {\n        // 检测通道状态，对于请求或响应消息，此时 state = RECEIVED\n        if (state == ChannelState.RECEIVED) {\n            try {\n                // 将 channel 和 message 传给 ChannelHandler 对象，进行后续的调用\n                handler.received(channel, message);\n            } catch (Exception e) {\n                logger.warn("... operation error, channel is ... message is ...");\n            }\n        } \n        \n        // 其他消息类型通过 switch 进行处理\n        else {\n            switch (state) {\n            case CONNECTED:\n                try {\n                    handler.connected(channel);\n                } catch (Exception e) {\n                    logger.warn("... operation error, channel is ...");\n                }\n                break;\n            case DISCONNECTED:\n                // ...\n            case SENT:\n                // ...\n            case CAUGHT:\n                // ...\n            default:\n                logger.warn("unknown state: " + state + ", message is " + message);\n            }\n        }\n\n    }\n}\n')])])]),t("p",[e._v("如上，请求和响应消息出现频率明显比其他类型消息高，所以这里对该类型的消息进行了针对性判断。ChannelEventRunnable 仅是一个中转站，它的 run 方法中并不包含具体的调用逻辑，仅用于将参数传给其他 ChannelHandler 对象进行处理，该对象类型为 DecodeHandler。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public class DecodeHandler extends AbstractChannelHandlerDelegate {\n\n    public DecodeHandler(ChannelHandler handler) {\n        super(handler);\n    }\n\n    @Override\n    public void received(Channel channel, Object message) throws RemotingException {\n        if (message instanceof Decodeable) {\n            // 对 Decodeable 接口实现类对象进行解码\n            decode(message);\n        }\n\n        if (message instanceof Request) {\n            // 对 Request 的 data 字段进行解码\n            decode(((Request) message).getData());\n        }\n\n        if (message instanceof Response) {\n            // 对 Request 的 result 字段进行解码\n            decode(((Response) message).getResult());\n        }\n\n        // 执行后续逻辑\n        handler.received(channel, message);\n    }\n\n    private void decode(Object message) {\n        // Decodeable 接口目前有两个实现类，\n        // 分别为 DecodeableRpcInvocation 和 DecodeableRpcResult\n        if (message != null && message instanceof Decodeable) {\n            try {\n                // 执行解码逻辑\n                ((Decodeable) message).decode();\n            } catch (Throwable e) {\n                if (log.isWarnEnabled()) {\n                    log.warn("Call Decodeable.decode failed: " + e.getMessage(), e);\n                }\n            }\n        }\n    }\n}\n')])])]),t("p",[e._v("DecodeHandler 主要是包含了一些解码逻辑。2.2.1 节分析请求解码时说过，请求解码可在 IO 线程上执行，也可在线程池中执行，这个取决于运行时配置。DecodeHandler 存在的意义就是保证请求或响应对象可在线程池中被解码。解码完毕后，完全解码后的 Request 对象会继续向后传递，下一站是 HeaderExchangeHandler。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public class HeaderExchangeHandler implements ChannelHandlerDelegate {\n\n    private final ExchangeHandler handler;\n\n    public HeaderExchangeHandler(ExchangeHandler handler) {\n        if (handler == null) {\n            throw new IllegalArgumentException("handler == null");\n        }\n        this.handler = handler;\n    }\n\n    @Override\n    public void received(Channel channel, Object message) throws RemotingException {\n        channel.setAttribute(KEY_READ_TIMESTAMP, System.currentTimeMillis());\n        ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);\n        try {\n            // 处理请求对象\n            if (message instanceof Request) {\n                Request request = (Request) message;\n                if (request.isEvent()) {\n                    // 处理事件\n                    handlerEvent(channel, request);\n                } \n                // 处理普通的请求\n                else {\n                    // 双向通信\n                    if (request.isTwoWay()) {\n                        // 向后调用服务，并得到调用结果\n                        Response response = handleRequest(exchangeChannel, request);\n                        // 将调用结果返回给服务消费端\n                        channel.send(response);\n                    } \n                    // 如果是单向通信，仅向后调用指定服务即可，无需返回调用结果\n                    else {\n                        handler.received(exchangeChannel, request.getData());\n                    }\n                }\n            }      \n            // 处理响应对象，服务消费方会执行此处逻辑，后面分析\n            else if (message instanceof Response) {\n                handleResponse(channel, (Response) message);\n            } else if (message instanceof String) {\n                // telnet 相关，忽略\n            } else {\n                handler.received(exchangeChannel, message);\n            }\n        } finally {\n            HeaderExchangeChannel.removeChannelIfDisconnected(channel);\n        }\n    }\n\n    Response handleRequest(ExchangeChannel channel, Request req) throws RemotingException {\n        Response res = new Response(req.getId(), req.getVersion());\n        // 检测请求是否合法，不合法则返回状态码为 BAD_REQUEST 的响应\n        if (req.isBroken()) {\n            Object data = req.getData();\n\n            String msg;\n            if (data == null)\n                msg = null;\n            else if\n                (data instanceof Throwable) msg = StringUtils.toString((Throwable) data);\n            else\n                msg = data.toString();\n            res.setErrorMessage("Fail to decode request due to: " + msg);\n            // 设置 BAD_REQUEST 状态\n            res.setStatus(Response.BAD_REQUEST);\n\n            return res;\n        }\n        \n        // 获取 data 字段值，也就是 RpcInvocation 对象\n        Object msg = req.getData();\n        try {\n            // 继续向下调用\n            Object result = handler.reply(channel, msg);\n            // 设置 OK 状态码\n            res.setStatus(Response.OK);\n            // 设置调用结果\n            res.setResult(result);\n        } catch (Throwable e) {\n            // 若调用过程出现异常，则设置 SERVICE_ERROR，表示服务端异常\n            res.setStatus(Response.SERVICE_ERROR);\n            res.setErrorMessage(StringUtils.toString(e));\n        }\n        return res;\n    }\n}\n')])])]),t("p",[e._v("到这里，我们看到了比较清晰的请求和响应逻辑。对于双向通信，HeaderExchangeHandler 首先向后进行调用，得到调用结果。然后将调用结果封装到 Response 对象中，最后再将该对象返回给服务消费方。如果请求不合法，或者调用失败，则将错误信息封装到 Response 对象中，并返回给服务消费方。接下来我们继续向后分析，把剩余的调用过程分析完。下面分析定义在 DubboProtocol 类中的匿名类对象逻辑，如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public class DubboProtocol extends AbstractProtocol {\n\n    public static final String NAME = "dubbo";\n    \n    private ExchangeHandler requestHandler = new ExchangeHandlerAdapter() {\n\n        @Override\n        public Object reply(ExchangeChannel channel, Object message) throws RemotingException {\n            if (message instanceof Invocation) {\n                Invocation inv = (Invocation) message;\n                // 获取 Invoker 实例\n                Invoker<?> invoker = getInvoker(channel, inv);\n                if (Boolean.TRUE.toString().equals(inv.getAttachments().get(IS_CALLBACK_SERVICE_INVOKE))) {\n                    // 回调相关，忽略\n                }\n                RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress());\n                // 通过 Invoker 调用具体的服务\n                return invoker.invoke(inv);\n            }\n            throw new RemotingException(channel, "Unsupported request: ...");\n        }\n        \n        // 忽略其他方法\n    }\n    \n    Invoker<?> getInvoker(Channel channel, Invocation inv) throws RemotingException {\n        // 忽略回调和本地存根相关逻辑\n        // ...\n        \n        int port = channel.getLocalAddress().getPort();\n        \n        // 计算 service key，格式为 groupName/serviceName:serviceVersion:port。比如：\n        //   dubbo/com.alibaba.dubbo.demo.DemoService:1.0.0:20880\n        String serviceKey = serviceKey(port, path, inv.getAttachments().get(Constants.VERSION_KEY), inv.getAttachments().get(Constants.GROUP_KEY));\n\n        // 从 exporterMap 查找与 serviceKey 相对应的 DubboExporter 对象，\n        // 服务导出过程中会将 <serviceKey, DubboExporter> 映射关系存储到 exporterMap 集合中\n        DubboExporter<?> exporter = (DubboExporter<?>) exporterMap.get(serviceKey);\n\n        if (exporter == null)\n            throw new RemotingException(channel, "Not found exported service ...");\n\n        // 获取 Invoker 对象，并返回\n        return exporter.getInvoker();\n    }\n    \n    // 忽略其他方法\n}\n')])])]),t("p",[e._v("以上逻辑用于获取与指定服务对应的 Invoker 实例，并通过 Invoker 的 invoke 方法调用服务逻辑。invoke 方法定义在 AbstractProxyInvoker 中，代码如下。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public abstract class AbstractProxyInvoker<T> implements Invoker<T> {\n\n    @Override\n    public Result invoke(Invocation invocation) throws RpcException {\n        try {\n            // 调用 doInvoke 执行后续的调用，并将调用结果封装到 RpcResult 中，并\n            return new RpcResult(doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments()));\n        } catch (InvocationTargetException e) {\n            return new RpcResult(e.getTargetException());\n        } catch (Throwable e) {\n            throw new RpcException("Failed to invoke remote proxy method ...");\n        }\n    }\n\n    protected abstract Object doInvoke(T proxy, String methodName, Class<?>[] parameterTypes, Object[] arguments) throws Throwable;\n}\n')])])]),t("p",[e._v("如上，doInvoke 是一个抽象方法，这个需要由具体的 Invoker 实例实现。Invoker 实例是在运行时通过 JavassistProxyFactory 创建的，创建逻辑如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public class JavassistProxyFactory extends AbstractProxyFactory {\n    \n    // 省略其他方法\n\n    @Override\n    public <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) {\n        final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf('$') < 0 ? proxy.getClass() : type);\n        // 创建匿名类对象\n        return new AbstractProxyInvoker<T>(proxy, type, url) {\n            @Override\n            protected Object doInvoke(T proxy, String methodName,\n                                      Class<?>[] parameterTypes,\n                                      Object[] arguments) throws Throwable {\n                // 调用 invokeMethod 方法进行后续的调用\n                return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);\n            }\n        };\n    }\n}\n")])])]),t("p",[e._v("Wrapper 是一个抽象类，其中 invokeMethod 是一个抽象方法。Dubbo 会在运行时通过 Javassist 框架为 Wrapper 生成实现类，并实现 invokeMethod 方法，该方法最终会根据调用信息调用具体的服务。以 DemoServiceImpl 为例，Javassist 为其生成的代理类如下。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('/** Wrapper0 是在运行时生成的，大家可使用 Arthas 进行反编译 */\npublic class Wrapper0 extends Wrapper implements ClassGenerator.DC {\n    public static String[] pns;\n    public static Map pts;\n    public static String[] mns;\n    public static String[] dmns;\n    public static Class[] mts0;\n\n    // 省略其他方法\n\n    public Object invokeMethod(Object object, String string, Class[] arrclass, Object[] arrobject) throws InvocationTargetException {\n        DemoService demoService;\n        try {\n            // 类型转换\n            demoService = (DemoService)object;\n        }\n        catch (Throwable throwable) {\n            throw new IllegalArgumentException(throwable);\n        }\n        try {\n            // 根据方法名调用指定的方法\n            if ("sayHello".equals(string) && arrclass.length == 1) {\n                return demoService.sayHello((String)arrobject[0]);\n            }\n        }\n        catch (Throwable throwable) {\n            throw new InvocationTargetException(throwable);\n        }\n        throw new NoSuchMethodException(new StringBuffer().append("Not found method \\"").append(string).append("\\" in class com.alibaba.dubbo.demo.DemoService.").toString());\n    }\n}\n')])])]),t("p",[e._v("到这里，整个服务调用过程就分析完了。最后把调用过程贴出来，如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("ChannelEventRunnable#run()\n  —> DecodeHandler#received(Channel, Object)\n    —> HeaderExchangeHandler#received(Channel, Object)\n      —> HeaderExchangeHandler#handleRequest(ExchangeChannel, Request)\n        —> DubboProtocol.requestHandler#reply(ExchangeChannel, Object)\n          —> Filter#invoke(Invoker, Invocation)\n            —> AbstractProxyInvoker#invoke(Invocation)\n              —> Wrapper#invokeMethod(Object, String, Class[], Object[])\n                —> DemoServiceImpl#sayHello(String)\n")])])]),t("h3",{attrs:{id:"_2-4-服务提供方响应请求"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-服务提供方响应请求"}},[e._v("#")]),e._v(" 2.4 服务提供方响应请求")]),e._v(" "),t("p",[e._v("服务提供方调用指定服务后，会将调用结果封装到 Response 对象中，并将该对象返回给服务消费方。服务提供方也是通过 NettyChannel 的 send 方法将 Response 对象返回，这个方法在 2.2.1 节分析过，这里就不在重复分析了。本节我们仅需关注 Response 对象的编码过程即可，这里仍然省略一些中间调用，直接分析具体的编码逻辑。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public class ExchangeCodec extends TelnetCodec {\n\tpublic void encode(Channel channel, ChannelBuffer buffer, Object msg) throws IOException {\n        if (msg instanceof Request) {\n            encodeRequest(channel, buffer, (Request) msg);\n        } else if (msg instanceof Response) {\n            // 对响应对象进行编码\n            encodeResponse(channel, buffer, (Response) msg);\n        } else {\n            super.encode(channel, buffer, msg);\n        }\n    }\n    \n    protected void encodeResponse(Channel channel, ChannelBuffer buffer, Response res) throws IOException {\n        int savedWriteIndex = buffer.writerIndex();\n        try {\n            Serialization serialization = getSerialization(channel);\n            // 创建消息头字节数组\n            byte[] header = new byte[HEADER_LENGTH];\n            // 设置魔数\n            Bytes.short2bytes(MAGIC, header);\n            // 设置序列化器编号\n            header[2] = serialization.getContentTypeId();\n            if (res.isHeartbeat()) header[2] |= FLAG_EVENT;\n            // 获取响应状态\n            byte status = res.getStatus();\n            // 设置响应状态\n            header[3] = status;\n            // 设置请求编号\n            Bytes.long2bytes(res.getId(), header, 4);\n\n            // 更新 writerIndex，为消息头预留 16 个字节的空间\n            buffer.writerIndex(savedWriteIndex + HEADER_LENGTH);\n            ChannelBufferOutputStream bos = new ChannelBufferOutputStream(buffer);\n            ObjectOutput out = serialization.serialize(channel.getUrl(), bos);\n           \n            if (status == Response.OK) {\n                if (res.isHeartbeat()) {\n                    // 对心跳响应结果进行序列化，已废弃\n                    encodeHeartbeatData(channel, out, res.getResult());\n                } else {\n                    // 对调用结果进行序列化\n                    encodeResponseData(channel, out, res.getResult(), res.getVersion());\n                }\n            } else { \n                // 对错误信息进行序列化\n                out.writeUTF(res.getErrorMessage())\n            };\n            out.flushBuffer();\n            if (out instanceof Cleanable) {\n                ((Cleanable) out).cleanup();\n            }\n            bos.flush();\n            bos.close();\n\n            // 获取写入的字节数，也就是消息体长度\n            int len = bos.writtenBytes();\n            checkPayload(channel, len);\n            \n            // 将消息体长度写入到消息头中\n            Bytes.int2bytes(len, header, 12);\n            // 将 buffer 指针移动到 savedWriteIndex，为写消息头做准备\n            buffer.writerIndex(savedWriteIndex);\n            // 从 savedWriteIndex 下标处写入消息头\n            buffer.writeBytes(header); \n            // 设置新的 writerIndex，writerIndex = 原写下标 + 消息头长度 + 消息体长度\n            buffer.writerIndex(savedWriteIndex + HEADER_LENGTH + len);\n        } catch (Throwable t) {\n            // 异常处理逻辑不是很难理解，但是代码略多，这里忽略了\n        }\n    }\n}\n\npublic class DubboCodec extends ExchangeCodec implements Codec2 {\n    \n\tprotected void encodeResponseData(Channel channel, ObjectOutput out, Object data, String version) throws IOException {\n        Result result = (Result) data;\n        // 检测当前协议版本是否支持带有 attachments 集合的 Response 对象\n        boolean attach = Version.isSupportResponseAttachment(version);\n        Throwable th = result.getException();\n        \n        // 异常信息为空\n        if (th == null) {\n            Object ret = result.getValue();\n            // 调用结果为空\n            if (ret == null) {\n                // 序列化响应类型\n                out.writeByte(attach ? RESPONSE_NULL_VALUE_WITH_ATTACHMENTS : RESPONSE_NULL_VALUE);\n            } \n            // 调用结果非空\n            else {\n                // 序列化响应类型\n                out.writeByte(attach ? RESPONSE_VALUE_WITH_ATTACHMENTS : RESPONSE_VALUE);\n                // 序列化调用结果\n                out.writeObject(ret);\n            }\n        } \n        // 异常信息非空\n        else {\n            // 序列化响应类型\n            out.writeByte(attach ? RESPONSE_WITH_EXCEPTION_WITH_ATTACHMENTS : RESPONSE_WITH_EXCEPTION);\n            // 序列化异常对象\n            out.writeObject(th);\n        }\n\n        if (attach) {\n            // 记录 Dubbo 协议版本\n            result.getAttachments().put(Constants.DUBBO_VERSION_KEY, Version.getProtocolVersion());\n            // 序列化 attachments 集合\n            out.writeObject(result.getAttachments());\n        }\n    }\n}\n")])])]),t("p",[e._v("以上就是 Response 对象编码的过程，和前面分析的 Request 对象编码过程很相似。如果大家能看 Request 对象的编码逻辑，那么这里的 Response 对象的编码逻辑也不难理解，就不多说了。接下来我们再来分析双向通信的最后一环 —— 服务消费方接收调用结果。")]),e._v(" "),t("h3",{attrs:{id:"_2-5-服务消费方接收调用结果"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-服务消费方接收调用结果"}},[e._v("#")]),e._v(" 2.5 服务消费方接收调用结果")]),e._v(" "),t("p",[e._v("服务消费方在收到响应数据后，首先要做的事情是对响应数据进行解码，得到 Response 对象。然后再将该对象传给下一个入站处理器，这个入站处理器就是 NettyHandler。接下来 NettyHandler 会将这个对象继续向下传递，最后 AllChannelHandler 的 received 方法会收到这个对象，并将这个对象派发到线程池中。这个过程和服务提供方接收请求的过程是一样的，因此这里就不重复分析了。本节我们重点分析两个方面的内容，一是响应数据的解码过程，二是 Dubbo 如何将调用结果传递给用户线程的。下面先来分析响应数据的解码过程。")]),e._v(" "),t("h4",{attrs:{id:"_2-5-1-响应数据解码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-1-响应数据解码"}},[e._v("#")]),e._v(" 2.5.1 响应数据解码")]),e._v(" "),t("p",[e._v("响应数据解码逻辑主要的逻辑封装在 DubboCodec 中，我们直接分析这个类的代码。如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public class DubboCodec extends ExchangeCodec implements Codec2 {\n\n    @Override\n    protected Object decodeBody(Channel channel, InputStream is, byte[] header) throws IOException {\n        byte flag = header[2], proto = (byte) (flag & SERIALIZATION_MASK);\n        Serialization s = CodecSupport.getSerialization(channel.getUrl(), proto);\n        // 获取请求编号\n        long id = Bytes.bytes2long(header, 4);\n        // 检测消息类型，若下面的条件成立，表明消息类型为 Response\n        if ((flag & FLAG_REQUEST) == 0) {\n            // 创建 Response 对象\n            Response res = new Response(id);\n            // 检测事件标志位\n            if ((flag & FLAG_EVENT) != 0) {\n                // 设置心跳事件\n                res.setEvent(Response.HEARTBEAT_EVENT);\n            }\n            // 获取响应状态\n            byte status = header[3];\n            // 设置响应状态\n            res.setStatus(status);\n            \n            // 如果响应状态为 OK，表明调用过程正常\n            if (status == Response.OK) {\n                try {\n                    Object data;\n                    if (res.isHeartbeat()) {\n                        // 反序列化心跳数据，已废弃\n                        data = decodeHeartbeatData(channel, deserialize(s, channel.getUrl(), is));\n                    } else if (res.isEvent()) {\n                        // 反序列化事件数据\n                        data = decodeEventData(channel, deserialize(s, channel.getUrl(), is));\n                    } else {\n                        DecodeableRpcResult result;\n                        // 根据 url 参数决定是否在 IO 线程上执行解码逻辑\n                        if (channel.getUrl().getParameter(\n                                Constants.DECODE_IN_IO_THREAD_KEY,\n                                Constants.DEFAULT_DECODE_IN_IO_THREAD)) {\n                            // 创建 DecodeableRpcResult 对象\n                            result = new DecodeableRpcResult(channel, res, is,\n                                    (Invocation) getRequestData(id), proto);\n                            // 进行后续的解码工作\n                            result.decode();\n                        } else {\n                            // 创建 DecodeableRpcResult 对象\n                            result = new DecodeableRpcResult(channel, res,\n                                    new UnsafeByteArrayInputStream(readMessageData(is)),\n                                    (Invocation) getRequestData(id), proto);\n                        }\n                        data = result;\n                    }\n                    \n                    // 设置 DecodeableRpcResult 对象到 Response 对象中\n                    res.setResult(data);\n                } catch (Throwable t) {\n                    // 解码过程中出现了错误，此时设置 CLIENT_ERROR 状态码到 Response 对象中\n                    res.setStatus(Response.CLIENT_ERROR);\n                    res.setErrorMessage(StringUtils.toString(t));\n                }\n            } \n            // 响应状态非 OK，表明调用过程出现了异常\n            else {\n                // 反序列化异常信息，并设置到 Response 对象中\n                res.setErrorMessage(deserialize(s, channel.getUrl(), is).readUTF());\n            }\n            return res;\n        } else {\n            // 对请求数据进行解码，前面已分析过，此处忽略\n        }\n    }\n}\n")])])]),t("p",[e._v("以上就是响应数据的解码过程，上面逻辑看起来是不是似曾相识。对的，我们在前面章节分析过 DubboCodec 的 decodeBody 方法中关于请求数据的解码过程，该过程和响应数据的解码过程很相似。下面，我们继续分析调用结果的反序列化过程，如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public class DecodeableRpcResult extends RpcResult implements Codec, Decodeable {\n    \n    private Invocation invocation;\n\t\n    @Override\n    public void decode() throws Exception {\n        if (!hasDecoded && channel != null && inputStream != null) {\n            try {\n                // 执行反序列化操作\n                decode(channel, inputStream);\n            } catch (Throwable e) {\n                // 反序列化失败，设置 CLIENT_ERROR 状态到 Response 对象中\n                response.setStatus(Response.CLIENT_ERROR);\n                // 设置异常信息\n                response.setErrorMessage(StringUtils.toString(e));\n            } finally {\n                hasDecoded = true;\n            }\n        }\n    }\n    \n    @Override\n    public Object decode(Channel channel, InputStream input) throws IOException {\n        ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType)\n                .deserialize(channel.getUrl(), input);\n        \n        // 反序列化响应类型\n        byte flag = in.readByte();\n        switch (flag) {\n            case DubboCodec.RESPONSE_NULL_VALUE:\n                break;\n            case DubboCodec.RESPONSE_VALUE:\n                // ...\n                break;\n            case DubboCodec.RESPONSE_WITH_EXCEPTION:\n                // ...\n                break;\n                \n            // 返回值为空，且携带了 attachments 集合\n            case DubboCodec.RESPONSE_NULL_VALUE_WITH_ATTACHMENTS:\n                try {\n                    // 反序列化 attachments 集合，并存储起来 \n                    setAttachments((Map<String, String>) in.readObject(Map.class));\n                } catch (ClassNotFoundException e) {\n                    throw new IOException(StringUtils.toString("Read response data failed.", e));\n                }\n                break;\n                \n            // 返回值不为空，且携带了 attachments 集合\n            case DubboCodec.RESPONSE_VALUE_WITH_ATTACHMENTS:\n                try {\n                    // 获取返回值类型\n                    Type[] returnType = RpcUtils.getReturnTypes(invocation);\n                    // 反序列化调用结果，并保存起来\n                    setValue(returnType == null || returnType.length == 0 ? in.readObject() :\n                            (returnType.length == 1 ? in.readObject((Class<?>) returnType[0])\n                                    : in.readObject((Class<?>) returnType[0], returnType[1])));\n                    // 反序列化 attachments 集合，并存储起来\n                    setAttachments((Map<String, String>) in.readObject(Map.class));\n                } catch (ClassNotFoundException e) {\n                    throw new IOException(StringUtils.toString("Read response data failed.", e));\n                }\n                break;\n                \n            // 异常对象不为空，且携带了 attachments 集合\n            case DubboCodec.RESPONSE_WITH_EXCEPTION_WITH_ATTACHMENTS:\n                try {\n                    // 反序列化异常对象\n                    Object obj = in.readObject();\n                    if (obj instanceof Throwable == false)\n                        throw new IOException("Response data error, expect Throwable, but get " + obj);\n                    // 设置异常对象\n                    setException((Throwable) obj);\n                    // 反序列化 attachments 集合，并存储起来\n                    setAttachments((Map<String, String>) in.readObject(Map.class));\n                } catch (ClassNotFoundException e) {\n                    throw new IOException(StringUtils.toString("Read response data failed.", e));\n                }\n                break;\n            default:\n                throw new IOException("Unknown result flag, expect \'0\' \'1\' \'2\', get " + flag);\n        }\n        if (in instanceof Cleanable) {\n            ((Cleanable) in).cleanup();\n        }\n        return this;\n    }\n}\n')])])]),t("p",[e._v("本篇文章所分析的源码版本为 2.6.4，该版本下的 Response 支持 attachments 集合，所以上面仅对部分 case 分支进行了注释。其他 case 分支的逻辑比被注释分支的逻辑更为简单，这里就忽略了。我们所使用的测试服务接口 DemoService 包含了一个具有返回值的方法，所以正常调用下，线程会进入 RESPONSE_VALUE_WITH_ATTACHMENTS 分支中。然后线程会从 invocation 变量（大家探索一下 invocation 变量的由来）中获取返回值类型，接着对调用结果进行反序列化，并将序列化后的结果存储起来。最后对 attachments 集合进行反序列化，并存到指定字段中。到此，关于响应数据的解码过程就分析完了。接下来，我们再来探索一下响应对象 Response 的去向。")]),e._v(" "),t("h4",{attrs:{id:"_2-5-2-向用户线程传递调用结果"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-2-向用户线程传递调用结果"}},[e._v("#")]),e._v(" 2.5.2 向用户线程传递调用结果")]),e._v(" "),t("p",[e._v("响应数据解码完成后，Dubbo 会将响应对象派发到线程池上。要注意的是，线程池中的线程并非用户的调用线程，所以要想办法将响应对象从线程池线程传递到用户线程上。我们在 2.1 节分析过用户线程在发送完请求后的动作，即调用 DefaultFuture 的 get 方法等待响应对象的到来。当响应对象到来后，用户线程会被唤醒，并通过"),t("strong",[e._v("调用编号")]),e._v("获取属于自己的响应对象。下面我们就来看一下整个过程对应的代码。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public class HeaderExchangeHandler implements ChannelHandlerDelegate {\n    \n    @Override\n    public void received(Channel channel, Object message) throws RemotingException {\n        channel.setAttribute(KEY_READ_TIMESTAMP, System.currentTimeMillis());\n        ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);\n        try {\n            if (message instanceof Request) {\n                // 处理请求，前面已分析过，省略\n            } else if (message instanceof Response) {\n                // 处理响应\n                handleResponse(channel, (Response) message);\n            } else if (message instanceof String) {\n                // telnet 相关，忽略\n            } else {\n                handler.received(exchangeChannel, message);\n            }\n        } finally {\n            HeaderExchangeChannel.removeChannelIfDisconnected(channel);\n        }\n    }\n\n    static void handleResponse(Channel channel, Response response) throws RemotingException {\n        if (response != null && !response.isHeartbeat()) {\n            // 继续向下调用\n            DefaultFuture.received(channel, response);\n        }\n    }\n}\n\npublic class DefaultFuture implements ResponseFuture {  \n    \n    private final Lock lock = new ReentrantLock();\n    private final Condition done = lock.newCondition();\n    private volatile Response response;\n    \n\tpublic static void received(Channel channel, Response response) {\n        try {\n            // 根据调用编号从 FUTURES 集合中查找指定的 DefaultFuture 对象\n            DefaultFuture future = FUTURES.remove(response.getId());\n            if (future != null) {\n                // 继续向下调用\n                future.doReceived(response);\n            } else {\n                logger.warn("The timeout response finally returned at ...");\n            }\n        } finally {\n            CHANNELS.remove(response.getId());\n        }\n    }\n\n\tprivate void doReceived(Response res) {\n        lock.lock();\n        try {\n            // 保存响应对象\n            response = res;\n            if (done != null) {\n                // 唤醒用户线程\n                done.signal();\n            }\n        } finally {\n            lock.unlock();\n        }\n        if (callback != null) {\n            invokeCallback(callback);\n        }\n    }\n}\n')])])]),t("p",[e._v("以上逻辑是将响应对象保存到相应的 DefaultFuture 实例中，然后再唤醒用户线程，随后用户线程即可从 DefaultFuture 实例中获取到相应结果。")]),e._v(" "),t("p",[e._v("本篇文章在多个地方都强调过调用编号很重要，但一直没有解释原因，这里简单说明一下。一般情况下，服务消费方会并发调用多个服务，每个用户线程发送请求后，会调用不同 DefaultFuture 对象的 get 方法进行等待。 一段时间后，服务消费方的线程池会收到多个响应对象。这个时候要考虑一个问题，如何将每个响应对象传递给相应的 DefaultFuture 对象，且不出错。答案是通过调用编号。DefaultFuture 被创建时，会要求传入一个 Request 对象。此时 DefaultFuture 可从 Request 对象中获取调用编号，并将 <调用编号, DefaultFuture 对象> 映射关系存入到静态 Map 中，即 FUTURES。线程池中的线程在收到 Response 对象后，会根据 Response 对象中的调用编号到 FUTURES 集合中取出相应的 DefaultFuture 对象，然后再将 Response 对象设置到 DefaultFuture 对象中。最后再唤醒用户线程，这样用户线程即可从 DefaultFuture 对象中获取调用结果了。整个过程大致如下图：")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15469260625440.jpg",alt:"img"}})])])}),[],!1,null,null,null);n.default=r.exports}}]);