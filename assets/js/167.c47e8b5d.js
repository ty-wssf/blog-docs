(window.webpackJsonp=window.webpackJsonp||[]).push([[167],{581:function(a,s,t){"use strict";t.r(s);var e=t(30),r=Object(e.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"java类加载器-classloader-的原理及应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java类加载器-classloader-的原理及应用"}},[a._v("#")]),a._v(" Java类加载器 — classloader 的原理及应用")]),a._v(" "),t("h2",{attrs:{id:"什么是classloader"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是classloader"}},[a._v("#")]),a._v(" 什么是classloader")]),a._v(" "),t("p",[a._v("classloader顾名思义，即是类加载。虚拟机把描述类的数据从class字节码文件加载到内存，并对数据进行检验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。了解java的类加载机制，可以快速解决运行时的各种加载问题并快速定位其背后的本质原因，也是解决疑难杂症的利器。因此学好类加载原理也至关重要。")]),a._v(" "),t("h2",{attrs:{id:"classloader的加载过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#classloader的加载过程"}},[a._v("#")]),a._v(" classloader的加载过程")]),a._v(" "),t("p",[a._v("类从被加载到虚拟机内存到被卸载，整个完整的生命周期包括：类加载、验证、准备、解析、初始化、使用和卸载七个阶段。其中验证，准备，解析三个部分统称为连接。接下来我们可以详细了解下类加载的各个过程。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/wuyilong/picture-bed/raw/master//img/3279460766e7484dbee19e086739d0f0~tplv-k3u1fbpfcp-watermark.awebp",alt:"img"}})]),a._v(" "),t("h2",{attrs:{id:"classloader双亲委托机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#classloader双亲委托机制"}},[a._v("#")]),a._v(" classloader双亲委托机制")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/wuyilong/picture-bed/raw/master//img/20201217213314510.png",alt:"img"}})]),a._v(" "),t("p",[a._v("从上图中我们就更容易理解了，当一个Hello.class这样的文件要被加载时。不考虑我们自定义类加载器，首先会在AppClassLoader中检查是否加载过，如果有那就无需再加载了。如果没有，那么会拿到父加载器，然后调用父加载器的loadClass方法。父类中同理也会先检查自己是否已经加载过，如果没有再往上。注意这个类似递归的过程，直到到达Bootstrap classLoader之前，都是在检查是否加载过，并不会选择自己去加载。直到BootstrapClassLoader，已经没有父加载器了，这时候开始考虑自己是否能加载了，如果自己无法加载，会下沉到子加载器去加载，一直到最底层，如果没有任何加载器能加载，就会抛出ClassNotFoundException。那么有人就有下面这种疑问了？")]),a._v(" "),t("h2",{attrs:{id:"classloader的应用场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#classloader的应用场景"}},[a._v("#")]),a._v(" classloader的应用场景")]),a._v(" "),t("h3",{attrs:{id:"依赖冲突"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#依赖冲突"}},[a._v("#")]),a._v(" 依赖冲突")]),a._v(" "),t("p",[a._v("做过多人协同开发的大型项目的同学可能深有感触。基于maven的pom进制可以方便的进行依赖管理，但是由于maven依赖的传递性，会导致我们的依赖错综复杂，这样就会导致引入类冲突的问题。最典型的就是NoSuchMethodException异常了。")]),a._v(" "),t("p",[a._v("在阿里平时的项目开发中是否也会遇到类似的问题吗，答案是肯定的。例如阿里内部也很多成熟的中间件，由不同的中间件团队来负责。那么当一个项目引入不同的中间件的时候，该如何避免依赖冲突的问题呢？首先我们用一个非常简单的场景来描述为什么会出现类冲突的问题。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81c652f15ab047889248022db073b53d~tplv-k3u1fbpfcp-watermark.awebp",alt:"img"}})]),a._v(" "),t("p",[a._v("某个业务引用了消息中间件(例如metaq)和微服务中间件(例如dubbo)，这两个中间件也同时引用了fastjson-2.0和fastjson-3.0版本，而业务自己本身也引用了fastjson-1.0版本。这三个版本表现不同之处在于classA类中方法数目不相同，我们根据maven依赖处理的机制，引用路径最短的fastjson-1.0会真正作为应用最终的依赖，其它两个版本的fastjson则会被忽略，那么中间件在调用method2()方法的时候，则会抛出方法找不到异常。或许你会说，将所有依赖fastjson的版本都升级到3.0不是就能解解决问题吗？确实这样能够解决问题，但是在实际操作中不太现实，首先，中间件团队和业务团队之间并不是一个团队，并不能做到高效协同，其次是中间件的稳定性是需要保障的，不可能因为包冲突问题，就升级版本，更何况一个中间件依赖的包可能有上百个，如果纯粹依赖包升级来解决，不仅稳定性难以保障，排包耗费的时间恐怕就让人窒息了。")]),a._v(" "),t("p",[a._v("那如何解决包冲突的问题呢？答案就是pandora(潘多拉)，通过自定义类加载器，为每个中间件自定义一个加载器，这些加载器之间的关系是平行的，彼此没有依赖关系。这样每个中间件的classloader就可以加载各自版本的fastjson。因为一个类的全限定名以及加载该类的加载器两者共同形成了这个类在JVM中的惟一标识，这也是阿里pandora实现依赖隔离的基础。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b891f90c26e41dd8f79ca9f5ac0fab2~tplv-k3u1fbpfcp-watermark.awebp",alt:"img"}})]),a._v(" "),t("p",[a._v("可能到这里，你又会有新的疑惑，根据双亲委托模型，App Classloader分别继承了Custom Classloader.那么业务包中的fastjson的class在加载的时候，会先委托到Custom ClassLoader。这样不就会导致自身依赖的fastjson版本被忽略吗？确实如此，所以潘多拉又是如何做的呢？")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b56537c84555466fba0040bc49fbdb72~tplv-k3u1fbpfcp-watermark.awebp",alt:"img"}})]),a._v(" "),t("p",[a._v("首先每个中间件对应的ModuleClassLoader在加载中间对应的class文件的同时，根据中间件配置的export.index负责将要需要透出的class(主要是提供api接口的相关类)索引到exportedClassHashMap中，然后应用程序的类加载器会持有这个exportedClassHashMap，因此应用程序代码在loadClass的时候，会优先判断exportedClassHashMap是否存在当前类，如果存在，则直接返回，如果不存在，则再使用传统的双亲委托机制来进行类加载。这样中间件MoudleClassloader不仅实现了中间件的加载，也实现了中间件关键服务类的透出。")]),a._v(" "),t("p",[a._v("我们可以大概看下应用程序类加载的过程：")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/414d790116834b1084437806b16f5c9b~tplv-k3u1fbpfcp-watermark.awebp",alt:"img"}})]),a._v(" "),t("h3",{attrs:{id:"热加载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#热加载"}},[a._v("#")]),a._v(" 热加载")]),a._v(" "),t("p",[a._v("在开发项目的时候，我们需要频繁的重启应用进行程序调试，但是java项目的启动少则几十秒，多则几分钟。如此慢的启动速度极大地影响了程序开发的效率，那是否可以快速的进行启动，进而能够快速的进行开发验证呢？答案也是肯定的，通过classloader我们可以完成对变更内容的加载，然后快速的启动。")]),a._v(" "),t("p",[a._v("常用的热加载方案有好几个，接下来我们介绍下spring官方推荐的热加载方案，即spring boot devtools。")]),a._v(" "),t("p",[a._v("首先我们需要思考下，为什么重新启动一个应用会比较慢，那是因为在启动应用的时候，JVM虚拟机需要将所有的应用程序重新装载到整个虚拟机。可想而知，一个复杂的应用程序所包含的jar包可能有上百兆，每次微小的改动都是全量加载，那自然是很慢了。那么我们是否可以做到，当我们修改了某个文件后，在JVM中替换到这个文件相关的部分而不全量的重新加载呢？而spring boot devtools正是基于这个思路进行处理的。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9569e29707f54671883b22630c635822~tplv-k3u1fbpfcp-watermark.awebp",alt:"img"}})]),a._v(" "),t("p",[a._v("如上图所示，通常一个项目的代码由以上四部分组成，即基础类、扩展类、二方包/三方包、以及我们自己编写的业务代码组成。上面的一排是我们通常的类加载结构，其中业务代码和二方包/三方包是由应用加载器加载的。而实际开发和调试的过程中，主要变化的是业务代码，并且业务代码相对二方包/三方包的内容来说会更少一些。因此我们可以将业务代码单独通过一个自定义的加载器Custom Classloader来进行加载，当监控发现业务代码发生改变后，我们重新加载启动，老的业务代码的相关类则由虚拟机的垃圾回收机制来自动回收。其工程流程大概如下。有兴趣的同学可以去看下源码，会更加清楚。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f663e80935241f6820b8d582a1c2530~tplv-k3u1fbpfcp-watermark.awebp",alt:"img"}})]),a._v(" "),t("p",[a._v("RestartClassLoader为自定义的类加载器，其核心是loadClass的加载方式，我们发现其通过修改了双亲委托机制，默认优先从自己加载，如果自己没有加载到，从从parent进行加载。这样保证了业务代码可以优先被RestartClassLoader加载。进而通过重新加载RestartClassLoader即可完成应用代码部分的重新加载。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87c12067585c461a8b2130b9b515579e~tplv-k3u1fbpfcp-watermark.awebp",alt:"img"}})]),a._v(" "),t("h3",{attrs:{id:"热部署"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#热部署"}},[a._v("#")]),a._v(" 热部署")]),a._v(" "),t("p",[a._v("热部署本质其实与热加载并没有太大的区别，通常我们说热加载是指在开发环境中进行的classloader加载，而热部署则更多是指在线上环境使用classloader的加载机制完成业务的部署。所以这二者使用的技术并没有本质的区别。那热部署除了与热加载具有发布更快之外，还有更多的更大的优势就是具有更细的发布粒度。我们可以想像以下的一个业务场景。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1790f599b46470796414e024cb308c4~tplv-k3u1fbpfcp-watermark.awebp",alt:"img"}})]),a._v(" "),t("p",[a._v("假设某个营销投放平台涉及到4个业务方的开发，需要对会场业务进行投放。而这四个业务方的代码全部都在一个应用里面。因此某个业务方有代码变更则需要对整个应用进行发布，同时其它业务方也需要跟着回归。因此每个微小的发动，则需要走整个应用的全量发布。这种方式带来的稳定性风险估且不说，整个发布迭代的效率也可想而知了。这在整个互联网里，时间和效率就是金钱的理念下，显然是无法接受的。")]),a._v(" "),t("p",[a._v("那么我们完全可以通过类加载机制，将每个业务方通过一个classloader来加载。基于类的隔离机制，可以保障各个业务方的代码不会相互影响，同时也可以做到各个业务方进行独立的发布。其实在移动客户端，每个应用模块也可以基于类加载，实现插件化发布。本质上也是一个原理。")]),a._v(" "),t("p",[a._v("在阿里内部像阿拉丁投放平台，以及crossbow容器化平台，本质都是使用classloader的热加载技术，实现业务细粒度的开发部署以及多应用的合并部署。")]),a._v(" "),t("h3",{attrs:{id:"加密保护"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#加密保护"}},[a._v("#")]),a._v(" 加密保护")]),a._v(" "),t("p",[a._v("众所周期，基于java开发编译产生的jar包是由.class字节码组成，由于字节码的文件格式是有明确规范的。因此对于字节码进行反编译，就很容易知道其源码实现了。因此大致会存在如下两个方面的诉求。例如在服务端，我们向别人提供三方包实现的时候，不希望别人知道核心代码实现，我们可以考虑对jar包进行加密，在客户端则会比较普遍，那就是我们打包好的apk的安装包，不希望被人家反编译而被人家翻个底朝天，我们也可以对apk进行加密。")]),a._v(" "),t("p",[a._v("jar包加密的本质，还是对字节码文件进行操作。但是JVM虚拟机加载class的规范是统一的，因此我们在最终加载class文件的时候，还是需要满足其class文件的格式规范，否则虚拟机是不能正常加载的。因此我们可以在打包的时候对class进行正向的加密操作，然后，在加载class文件之前通过自定义classloader先进行反向的解密操作，然后再按照标准的class文件标准进行加载，这样就完成了class文件正常的加载。因此这个加密的jar包只有能够实现解密方法的classloader才能正常加载。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3220a40d5ed476fb836940045f6d46e~tplv-k3u1fbpfcp-watermark.awebp",alt:"img"}})]),a._v(" "),t("p",[a._v("我们可以贴一下简单的实现方案：")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/457b31e968a942519e8269826e34d9b1~tplv-k3u1fbpfcp-watermark.awebp",alt:"img"}})]),a._v(" "),t("p",[a._v("这样整个jar包的安全性就有一定程度的提高，至于更高安全的保障则取决于加密算法的安全性了以及如何保障加密算法的密钥不被泄露的问题了。这有种套娃的感觉，所谓安全基本都是相对的。并且这些方法也不是绝对的，例如可以通过对classloader进行插码，对解密后的class文件进行存储；另外大多数JVM本身并不安全，还可以修改JVM，从ClassLoader之外获取解密后的代码并保存到磁盘，从而绕过上述加密所做的一切工作，当然这些操作的成本就比单纯的class反编译就高很多了。所以说安全保障只要做到使对方破解的成本高于收益即是安全，所以一定程度的安全性，足以减少很多低成本的攻击了。")]),a._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[a._v("#")]),a._v(" 总结")]),a._v(" "),t("p",[a._v("本文对classloader的加载过程和加载原理进行了介绍，并结合类加载机制的特征，介绍了其相应的使用场景。由于篇幅限制，并没有对每种场景的具体实现细节进行介绍，而只是阐述了其基本实现思路。或许大家觉得classloader的应用有些复杂，但事实上只要大家对class从哪里加载，搞清楚loadClass的机制，就已经成功了一大半。正所谓万变不离其宗，抓住了本质，其它问题也就迎刃而解了。")]),a._v(" "),t("p",[a._v("作者：阿里巴巴淘系技术\n链接：https://juejin.cn/post/6931972267609948167\n来源：掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。")])])}),[],!1,null,null,null);s.default=r.exports}}]);