(window.webpackJsonp=window.webpackJsonp||[]).push([[137],{551:function(e,n,t){"use strict";t.r(n);var r=t(30),a=Object(r.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"大白话说java并发工具类-semaphore-exchanger"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#大白话说java并发工具类-semaphore-exchanger"}},[e._v("#")]),e._v(" 大白话说java并发工具类-Semaphore，Exchanger")]),e._v(" "),t("h2",{attrs:{id:"_1-控制资源并发访问-semaphore"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-控制资源并发访问-semaphore"}},[e._v("#")]),e._v(" 1. 控制资源并发访问--Semaphore")]),e._v(" "),t("p",[e._v("Semaphore 可以理解为"),t("strong",[e._v("信号量")]),e._v("，用于控制资源能够被并发访问的线程数量，以保证多个线程能够合理的使用特定资源。Semaphore 就相当于一个许可证，线程需要先通过 acquire 方法获取该许可证，该线程才能继续往下执行，否则只能在该方法出阻塞等待。当执行完业务功能后，需要通过"),t("code",[e._v("release()")]),e._v("方法将许可证归还，以便其他线程能够获得许可证继续执行。")]),e._v(" "),t("p",[e._v("Semaphore 可以用于做流量控制，特别是公共资源有限的应用场景，比如数据库连接。假如有多个线程读取数据后，需要将数据保存在数据库中，而可用的最大数据库连接只有 10 个，这时候就需要使用 Semaphore 来控制能够并发访问到数据库连接资源的线程个数最多只有 10 个。在限制资源使用的应用场景下，Semaphore 是特别合适的。")]),e._v(" "),t("p",[e._v("下面来看下 Semaphore 的主要方法：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//获取许可，如果无法获取到，则阻塞等待直至能够获取为止\nvoid acquire() throws InterruptedException\n//同acquire方法功能基本一样，只不过该方法可以一次获取多个许可\nvoid acquire(int permits) throws InterruptedException\n//释放许可\nvoid release()\n//释放指定个数的许可\nvoid release(int permits)\n//尝试获取许可，如果能够获取成功则立即返回true，否则，则返回false\nboolean tryAcquire()\n//与tryAcquire方法一致，只不过这里可以指定获取多个许可\nboolean tryAcquire(int permits)\n//尝试获取许可，如果能够立即获取到或者在指定时间内能够获取到，则返回true，否则返回false\nboolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException\n//与上一个方法一致，只不过这里能够获取多个许可\n")])])]),t("p",[e._v("boolean    tryAcquire(int permits, long timeout, TimeUnit unit)")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//返回当前可用的许可证个数\nint availablePermits()\n//返回正在等待获取许可证的线程数\nint getQueueLength()\n//是否有线程正在等待获取许可证\nboolean hasQueuedThreads()\n//获取所有正在等待许可的线程集合\nCollection<Thread> getQueuedThreads()\n")])])]),t("p",[e._v("另外，在 Semaphore 的构造方法中还支持指定是够具有公平性，默认的是非公平性，这样也是为了保证吞吐量。")]),e._v(" "),t("blockquote",[t("p",[e._v("一个例子")])]),e._v(" "),t("p",[e._v("下面用一个简单的例子来说明 Semaphore 的具体使用。我们来模拟这样一样场景。有一天，班主任需要班上 10 个同学到讲台上来填写一个表格，但是老师只准备了 5 支笔，因此，只能保证同时只有 5 个同学能够拿到笔并填写表格，没有获取到笔的同学只能够等前面的同学用完之后，才能拿到笔去填写表格。该示例代码如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public class SemaphoreDemo {\n    //表示老师只有10支笔\n    private static Semaphore semaphore = new Semaphore(5);\n\n    public static void main(String[] args) {\n        //表示50个学生\n        ExecutorService service = Executors.newFixedThreadPool(10);\n        for (int i = 0; i < 10; i++) {\n            service.execute(() -> {\n                try {\n                    System.out.println(Thread.currentThread().getName() + "  同学准备获取笔......");\n                    semaphore.acquire();\n                    System.out.println(Thread.currentThread().getName() + "  同学获取到笔");\n                    System.out.println(Thread.currentThread().getName() + "  填写表格ing.....");\n                    TimeUnit.SECONDS.sleep(3);\n                    semaphore.release();\n                    System.out.println(Thread.currentThread().getName() + "  填写完表格，归还了笔！！！！！！");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            });\n        }\n        service.shutdown();\n    }\n}\n输出结果： \npool-1-thread-1  同学准备获取笔...... \npool-1-thread-1  同学获取到笔 \npool-1-thread-1  填写表格ing..... \npool-1-thread-2  同学准备获取笔...... \npool-1-thread-2  同学获取到笔 \npool-1-thread-2  填写表格ing..... \npool-1-thread-3  同学准备获取笔...... \npool-1-thread-4  同学准备获取笔...... \npool-1-thread-3  同学获取到笔 \npool-1-thread-4  同学获取到笔 \npool-1-thread-4  填写表格ing..... \npool-1-thread-3  填写表格ing..... \npool-1-thread-5  同学准备获取笔...... \npool-1-thread-5  同学获取到笔 \npool-1-thread-5  填写表格ing..... \npool-1-thread-6  同学准备获取笔...... \npool-1-thread-7  同学准备获取笔...... \npool-1-thread-8  同学准备获取笔...... \npool-1-thread-9  同学准备获取笔...... \npool-1-thread-10  同学准备获取笔...... \npool-1-thread-4  填写完表格，归还了笔！！！！！！ \npool-1-thread-9  同学获取到笔 \npool-1-thread-9  填写表格ing..... \npool-1-thread-5  填写完表格，归还了笔！！！！！！ \npool-1-thread-7  同学获取到笔 \npool-1-thread-7  填写表格ing..... \npool-1-thread-8  同学获取到笔 \npool-1-thread-8  填写表格ing..... \npool-1-thread-1  填写完表格，归还了笔！！！！！！ \npool-1-thread-6  同学获取到笔 \npool-1-thread-6  填写表格ing..... \npool-1-thread-3  填写完表格，归还了笔！！！！！！ \npool-1-thread-2  填写完表格，归还了笔！！！！！！ \npool-1-thread-10  同学获取到笔 \npool-1-thread-10  填写表格ing..... \npool-1-thread-7  填写完表格，归还了笔！！！！！！ \npool-1-thread-9  填写完表格，归还了笔！！！！！！ \npool-1-thread-8  填写完表格，归还了笔！！！！！！ \npool-1-thread-6  填写完表格，归还了笔！！！！！！ \npool-1-thread-10  填写完表格，归还了笔！！！！！！ \n')])])]),t("p",[e._v("根据输出结果进行分析，Semaphore 允许的最大许可数为 5，也就是允许的最大并发执行的线程个数为 5，可以看出，前 5 个线程（前 5 个学生）先获取到笔，然后填写表格，而 6-10 这 5 个线程，由于获取不到许可，只能阻塞等待。当线程"),t("code",[e._v("pool-1-thread-4")]),e._v("释放了许可之后，"),t("code",[e._v("pool-1-thread-9")]),e._v("就可以获取到许可，继续往下执行。对其他线程的执行过程，也是同样的道理。从这个例子就可以看出，"),t("strong",[e._v("Semaphore 用来做特殊资源的并发访问控制是相当合适的，如果有业务场景需要进行流量控制，可以优先考虑 Semaphore。")])]),e._v(" "),t("h2",{attrs:{id:"_2-线程间交换数据的工具-exchanger"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-线程间交换数据的工具-exchanger"}},[e._v("#")]),e._v(" 2.线程间交换数\t据的工具--Exchanger")]),e._v(" "),t("p",[e._v("Exchanger 是一个用于线程间协作的工具类，用于两个线程间能够交换。它提供了一个交换的同步点，在这个同步点两个线程能够交换数据。具体交换数据是通过 exchange 方法来实现的，如果一个线程先执行 exchange 方法，那么它会同步等待另一个线程也执行 exchange 方法，这个时候两个线程就都达到了同步点，两个线程就可以交换数据。")]),e._v(" "),t("p",[e._v("Exchanger 除了一个无参的构造方法外，主要方法也很简单：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//当一个线程执行该方法的时候，会等待另一个线程也执行该方法，因此两个线程就都达到了同步点\n//将数据交换给另一个线程，同时返回获取的数据\nV exchange(V x) throws InterruptedException\n//同上一个方法功能基本一样，只不过这个方法同步等待的时候，增加了超时时间\nV exchange(V x, long timeout, TimeUnit unit)\nthrows InterruptedException, TimeoutException\n")])])]),t("blockquote",[t("p",[e._v("一个例子")])]),e._v(" "),t("p",[e._v("Exchanger 理解起来很容易，这里用一个简单的例子来看下它的具体使用。我们来模拟这样一个情景，在青春洋溢的中学时代，下课期间，男生经常会给走廊里为自己喜欢的女孩子送情书，相信大家都做过这样的事情吧 ：)。男孩会先到女孩教室门口，然后等女孩出来，教室那里就是一个同步点，然后彼此交换信物，也就是彼此交换了数据。现在，就来模拟这个情景。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public class ExchangerDemo {\n    private static Exchanger<String> exchanger = new Exchanger();\n\n    public static void main(String[] args) {\n        //代表男生和女生\n        ExecutorService service = Executors.newFixedThreadPool(2);\n        service.execute(() -> {\n            try {\n                //男生对女生说的话\n                String girl = exchanger.exchange("我其实暗恋你很久了......");\n                System.out.println("女孩儿说：" + girl);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n        service.execute(() -> {\n            try {\n                System.out.println("女生慢慢的从教室你走出来......");\n                TimeUnit.SECONDS.sleep(3);\n                //男生对女生说的话\n                String boy = exchanger.exchange("我也很喜欢你......");\n                System.out.println("男孩儿说：" + boy);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n    }\n}\n输出结果： \n女生慢慢的从教室你走出来...... \n男孩儿说：我其实暗恋你很久了...... \n女孩儿说：我也很喜欢你...... \n')])])]),t("p",[e._v("这个例子很简单，也很能说明 Exchanger 的基本使用。当两个线程都到达调用 exchange 方法的同步点的时候，两个线程就能交换彼此的数据。")]),e._v(" "),t("p",[e._v("来源于 https://juejin.cn/post/6844903602461360142")])])}),[],!1,null,null,null);n.default=a.exports}}]);