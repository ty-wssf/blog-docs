(window.webpackJsonp=window.webpackJsonp||[]).push([[89],{517:function(e,t,n){"use strict";n.r(t);var i=n(30),o=Object(i.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"spring-mvc-原理探秘-容器的创建过程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spring-mvc-原理探秘-容器的创建过程"}},[e._v("#")]),e._v(" Spring MVC 原理探秘 - 容器的创建过程")]),e._v(" "),n("h2",{attrs:{id:"_1-简介"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-简介"}},[e._v("#")]),e._v(" 1.简介")]),e._v(" "),n("p",[e._v("在上一篇"),n("a",{attrs:{href:"http://www.coolblog.xyz/2018/06/29/Spring-MVC-%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A7%98-%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E7%9A%84%E6%97%85%E8%A1%8C%E8%BF%87%E7%A8%8B/",target:"_blank",rel:"noopener noreferrer"}},[e._v("文章"),n("OutboundLink")],1),e._v("中，我向大家介绍了 Spring MVC 是如何处理 HTTP 请求的。Spring MVC 可对外提供服务时，说明其已经处于了就绪状态。再次之前，Spring MVC 需要进行一系列的初始化操作。正所谓兵马未动，粮草先行。这些操作包括创建容器，加载 DispatcherServlet 中用到的各种组件等。本篇文章就来和大家讨论一下这些初始化操作中的容器创建操作，容器的创建是其他一些初始化过程的基础。那其他的就不多说了，我们直入主题吧。")]),e._v(" "),n("h2",{attrs:{id:"_2-容器的创建过程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-容器的创建过程"}},[e._v("#")]),e._v(" 2.容器的创建过程")]),e._v(" "),n("p",[e._v("一般情况下，我们会在一个 Web 应用中配置两个容器。一个容器用于加载 Web 层的类，比如我们的接口 Controller、HandlerMapping、ViewResolver 等。在本文中，我们把这个容器叫做 web 容器。另一个容器用于加载业务逻辑相关的类，比如 service、dao 层的一些类。在本文中，我们把这个容器叫做业务容器。在容器初始化的过程中，业务容器会先于 web 容器进行初始化。web 容器初始化时，会将业务容器作为父容器。这样做的原因是，web 容器中的一些 bean 会依赖于业务容器中的 bean。比如我们的 controller 层接口通常会依赖 service 层的业务逻辑类。下面举个例子进行说明：")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15301816604204.jpg",alt:"img"}})]),e._v(" "),n("p",[e._v("如上，我们将 dao 层的类配置在 application-dao.xml 文件中，将 service 层的类配置在 application-service.xml 文件中。然后我们将这两个配置文件通过标签导入到 application.xml 文件中。此时，我们可以让业务容器去加载 application.xml 配置文件即可。另一方面，我们将 Web 相关的配置放在 application-web.xml 文件中，并将该文件交给 Web 容器去加载。")]),e._v(" "),n("p",[e._v("这里我们把配置文件进行分层，结构上看起来清晰了很多，也便于维护。这个其实和代码分层是一个道理，如果我们把所有的代码都放在同一个包下，那看起来会多难受啊。同理，我们用业务容器和 Web 容器去加载不同的类也是一种分层的体现吧。当然，如果应用比较简单，仅用 Web 容器去加载所有的类也不是不可以。")]),e._v(" "),n("h3",{attrs:{id:"_2-1-业务容器的创建过程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-业务容器的创建过程"}},[e._v("#")]),e._v(" 2.1 业务容器的创建过程")]),e._v(" "),n("p",[e._v("前面说了一些背景知识作为铺垫，那下面我们开始分析容器的创建过程吧。按照创建顺序，我们先来分析业务容器的创建过程。业务容器的创建入口是 ContextLoaderListener 的 contextInitialized 方法。顾名思义，ContextLoaderListener 是用来监听 ServletContext 加载事件的。当 ServletContext 被加载后，监听器的 contextInitialized 方法就会被 Servlet 容器调用。ContextLoaderListener Spring 框架提供的，它的配置方法如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<web-app>\n    <listener>\n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n    </listener>\n    \n    <context-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>classpath:application.xml</param-value>\n    </context-param>\n    \n    \x3c!-- 省略其他配置 --\x3e\n</web-app>\n")])])]),n("p",[e._v("如上，ContextLoaderListener 可通过 ServletContext 获取到 contextConfigLocation 配置。这样，业务容器就可以加载 application.xml 配置文件了。那下面我们来分析一下 ContextLoaderListener 的源码吧。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('public class ContextLoaderListener extends ContextLoader implements ServletContextListener {\n\n    // 省略部分代码\n\n    @Override\n    public void contextInitialized(ServletContextEvent event) {\n        // 初始化 WebApplicationContext\n        initWebApplicationContext(event.getServletContext());\n    }\n}\n\npublic WebApplicationContext initWebApplicationContext(ServletContext servletContext) {\n    /*\n     * 如果 ServletContext 中 ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE 属性值\n     * 不为空时，表明有其他监听器设置了这个属性。Spring 认为不能替换掉别的监听器设置\n     * 的属性值，所以这里抛出异常。\n     */\n    if (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != null) {\n        throw new IllegalStateException(\n                "Cannot initialize context because there is already a root application context present - " +\n                "check whether you have multiple ContextLoader* definitions in your web.xml!");\n    }\n\n    Log logger = LogFactory.getLog(ContextLoader.class);\n    servletContext.log("Initializing Spring root WebApplicationContext");\n    if (logger.isInfoEnabled()) {...}\n    long startTime = System.currentTimeMillis();\n\n    try {\n        if (this.context == null) {\n            // 创建 WebApplicationContext\n            this.context = createWebApplicationContext(servletContext);\n        }\n        if (this.context instanceof ConfigurableWebApplicationContext) {\n            ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) this.context;\n            if (!cwac.isActive()) {\n                if (cwac.getParent() == null) {\n                    /*\n                     * 加载父 ApplicationContext，一般情况下，业务容器不会有父容器，\n                     * 除非进行配置\n                     */ \n                    ApplicationContext parent = loadParentContext(servletContext);\n                    cwac.setParent(parent);\n                }\n                // 配置并刷新 WebApplicationContext\n                configureAndRefreshWebApplicationContext(cwac, servletContext);\n            }\n        }\n\n        // 设置 ApplicationContext 到 servletContext 中\n        servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);\n\n        ClassLoader ccl = Thread.currentThread().getContextClassLoader();\n        if (ccl == ContextLoader.class.getClassLoader()) {\n            currentContext = this.context;\n        }\n        else if (ccl != null) {\n            currentContextPerThread.put(ccl, this.context);\n        }\n\n        if (logger.isDebugEnabled()) {...}\n        if (logger.isInfoEnabled()) {...}\n\n        return this.context;\n    }\n    catch (RuntimeException ex) {\n        logger.error("Context initialization failed", ex);\n        servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);\n        throw ex;\n    }\n    catch (Error err) {\n        logger.error("Context initialization failed", err);\n        servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, err);\n        throw err;\n    }\n}\n')])])]),n("p",[e._v("如上，我们看一下上面的创建过程。首先 Spring 会检测 ServletContext 中 ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE 属性有没有被设置，若被设置过，则抛出异常。若未设置，则调用 createWebApplicationContext 方法创建容器。创建好后，再调用 configureAndRefreshWebApplicationContext 方法配置并刷新容器。最后，调用 setAttribute 方法将容器设置到 ServletContext 中。经过以上几步，整个创建流程就结束了。流程并不复杂，可简单总结为"),n("code",[e._v("创建容器 → 配置并刷新容器 → 设置容器到 ServletContext 中")]),e._v("。这三步流程中，最后一步就不进行分析，接下来分析一下第一步和第二步流程对应的源码。如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('protected WebApplicationContext createWebApplicationContext(ServletContext sc) {\n    // 判断创建什么类型的容器，默认类型为 XmlWebApplicationContext\n    Class<?> contextClass = determineContextClass(sc);\n    if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) {\n        throw new ApplicationContextException("Custom context class [" + contextClass.getName() +\n                "] is not of type [" + ConfigurableWebApplicationContext.class.getName() + "]");\n    }\n    // 通过反射创建容器\n    return (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);\n}\n\nprotected Class<?> determineContextClass(ServletContext servletContext) {\n    /*\n     * 读取用户自定义配置，比如：\n     * <context-param>\n     *     <param-name>contextClass</param-name>\n     *     <param-value>XXXConfigWebApplicationContext</param-value>\n     * </context-param>\n     */\n    String contextClassName = servletContext.getInitParameter(CONTEXT_CLASS_PARAM);\n    if (contextClassName != null) {\n        try {\n            return ClassUtils.forName(contextClassName, ClassUtils.getDefaultClassLoader());\n        }\n        catch (ClassNotFoundException ex) {\n            throw new ApplicationContextException(\n                    "Failed to load custom context class [" + contextClassName + "]", ex);\n        }\n    }\n    else {\n        /*\n         * 若无自定义配置，则获取默认的容器类型，默认类型为 XmlWebApplicationContext。\n         * defaultStrategies 读取的配置文件为 ContextLoader.properties，\n         * 该配置文件内容如下：\n         * org.springframework.web.context.WebApplicationContext =\n         *     org.springframework.web.context.support.XmlWebApplicationContext\n         */\n        contextClassName = defaultStrategies.getProperty(WebApplicationContext.class.getName());\n        try {\n            return ClassUtils.forName(contextClassName, ContextLoader.class.getClassLoader());\n        }\n        catch (ClassNotFoundException ex) {\n            throw new ApplicationContextException(\n                    "Failed to load default context class [" + contextClassName + "]", ex);\n        }\n    }\n}\n')])])]),n("p",[e._v("简单说一下 createWebApplicationContext 方法的流程，该方法首先会调用 determineContextClass 判断创建什么类型的容器，默认为 XmlWebApplicationContext。然后调用 instantiateClass 方法通过反射的方式创建容器实例。instantiateClass 方法就不跟进去分析了，大家可以自己去看看，比较简单。")]),e._v(" "),n("p",[e._v("继续往下分析，接下来分析一下 configureAndRefreshWebApplicationContext 方法的源码。如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc) {\n    if (ObjectUtils.identityToString(wac).equals(wac.getId())) {\n        // 从 ServletContext 中获取用户配置的 contextId 属性\n        String idParam = sc.getInitParameter(CONTEXT_ID_PARAM);\n        if (idParam != null) {\n            // 设置容器 id\n            wac.setId(idParam);\n        }\n        else {\n            // 用户未配置 contextId，则设置一个默认的容器 id\n            wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +\n                    ObjectUtils.getDisplayString(sc.getContextPath()));\n        }\n    }\n\n    wac.setServletContext(sc);\n    // 获取 contextConfigLocation 配置\n    String configLocationParam = sc.getInitParameter(CONFIG_LOCATION_PARAM);\n    if (configLocationParam != null) {\n        wac.setConfigLocation(configLocationParam);\n    }\n    \n    ConfigurableEnvironment env = wac.getEnvironment();\n    if (env instanceof ConfigurableWebEnvironment) {\n        ((ConfigurableWebEnvironment) env).initPropertySources(sc, null);\n    }\n\n    customizeContext(sc, wac);\n\n    // 刷新容器\n    wac.refresh();\n}\n")])])]),n("p",[e._v("上面的源码不是很长，逻辑不是很复杂。下面简单总结 configureAndRefreshWebApplicationContext 方法主要做了事情，如下：")]),e._v(" "),n("ol",[n("li",[e._v("设置容器 id")]),e._v(" "),n("li",[e._v("获取 contextConfigLocation 配置，并设置到容器中")]),e._v(" "),n("li",[e._v("刷新容器")])]),e._v(" "),n("p",[e._v("到此，关于业务容器的创建过程就分析完了，下面我们继续分析 Web 容器的创建过程。")]),e._v(" "),n("h3",{attrs:{id:"_2-2-web-容器的创建过程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-web-容器的创建过程"}},[e._v("#")]),e._v(" 2.2 Web 容器的创建过程")]),e._v(" "),n("p",[e._v("前面说了业务容器的创建过程，业务容器是通过 ContextLoaderListener。那 Web 容器是通过什么创建的呢？答案是通过 DispatcherServlet。我在上一篇文章介绍 HttpServletBean 抽象类时，说过该类覆写了父类 HttpServlet 中的 init 方法。这个方法就是创建 Web 容器的入口，那下面我们就从这个方法入手。如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// -☆- org.springframework.web.servlet.HttpServletBean\npublic final void init() throws ServletException {\n    if (logger.isDebugEnabled()) {...}\n\n    // 获取 ServletConfig 中的配置信息\n    PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties);\n    if (!pvs.isEmpty()) {\n        try {\n            /*\n             * 为当前对象（比如 DispatcherServlet 对象）创建一个 BeanWrapper，\n             * 方便读/写对象属性。\n             */ \n            BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this);\n            ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext());\n            bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment()));\n            initBeanWrapper(bw);\n            // 设置配置信息到目标对象中\n            bw.setPropertyValues(pvs, true);\n        }\n        catch (BeansException ex) {\n            if (logger.isErrorEnabled()) {...}\n            throw ex;\n        }\n    }\n\n    // 进行后续的初始化\n    initServletBean();\n\n    if (logger.isDebugEnabled()) {...}\n}\n\nprotected void initServletBean() throws ServletException {\n}\n")])])]),n("p",[e._v("上面的源码主要做的事情是将 ServletConfig 中的配置信息设置到 HttpServletBean 的子类对象中（比如 DispatcherServlet），我们并未从上面的源码中发现创建容器的痕迹。不过如果大家注意看源码的话，会发现 initServletBean 这个方法稍显奇怪，是个空方法。这个方法的访问级别为 protected，子类可进行覆盖。HttpServletBean 子类 FrameworkServlet 覆写了这个方法，下面我们到 FrameworkServlet 中探索一番。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// -☆- org.springframework.web.servlet.FrameworkServlet\nprotected final void initServletBean() throws ServletException {\n    getServletContext().log("Initializing Spring FrameworkServlet \'" + getServletName() + "\'");\n    if (this.logger.isInfoEnabled()) {...}\n    long startTime = System.currentTimeMillis();\n\n    try {\n        // 初始化容器\n        this.webApplicationContext = initWebApplicationContext();\n        initFrameworkServlet();\n    }\n    catch (ServletException ex) {\n        this.logger.error("Context initialization failed", ex);\n        throw ex;\n    }\n    catch (RuntimeException ex) {\n        this.logger.error("Context initialization failed", ex);\n        throw ex;\n    }\n\n    if (this.logger.isInfoEnabled()) {...}\n}\n\nprotected WebApplicationContext initWebApplicationContext() {\n    // 从 ServletContext 中获取容器，也就是 ContextLoaderListener 创建的容器\n    WebApplicationContext rootContext =\n            WebApplicationContextUtils.getWebApplicationContext(getServletContext());\n    WebApplicationContext wac = null;\n\n    /*\n     * 若下面的条件成立，则需要从外部设置 webApplicationContext。有两个途径可以设置 \n     * webApplicationContext，以 DispatcherServlet 为例：\n     *    1. 通过 DispatcherServlet 有参构造方法传入 WebApplicationContext 对象\n     *    2. 将 DispatcherServlet 配置到其他容器中，由其他容器通过 \n     *       setApplicationContext 方法进行设置\n     *       \n     * 途径1 可参考 AbstractDispatcherServletInitializer 中的 \n     * registerDispatcherServlet 方法源码。一般情况下，代码执行到此处，\n     * this.webApplicationContext 为 null，大家可自行调试进行验证。\n     */\n    if (this.webApplicationContext != null) {\n        wac = this.webApplicationContext;\n        if (wac instanceof ConfigurableWebApplicationContext) {\n            ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;\n            if (!cwac.isActive()) {\n                if (cwac.getParent() == null) {\n                    // 设置 rootContext 为父容器\n                    cwac.setParent(rootContext);\n                }\n                // 配置并刷新容器\n                configureAndRefreshWebApplicationContext(cwac);\n            }\n        }\n    }\n    if (wac == null) {\n        // 尝试从 ServletContext 中获取容器\n        wac = findWebApplicationContext();\n    }\n    if (wac == null) {\n        // 创建容器，并将 rootContext 作为父容器\n        wac = createWebApplicationContext(rootContext);\n    }\n\n    if (!this.refreshEventReceived) {\n        onRefresh(wac);\n    }\n\n    if (this.publishContext) {\n        String attrName = getServletContextAttributeName();\n        // 将创建好的容器设置到 ServletContext 中\n        getServletContext().setAttribute(attrName, wac);\n        if (this.logger.isDebugEnabled()) {...}\n    }\n\n    return wac;\n}\n\nprotected WebApplicationContext createWebApplicationContext(ApplicationContext parent) {\n    // 获取容器类型，默认为 XmlWebApplicationContext.class\n    Class<?> contextClass = getContextClass();\n    if (this.logger.isDebugEnabled()) {...}\n    if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) {\n        throw new ApplicationContextException(\n                "Fatal initialization error in servlet with name \'" + getServletName() +\n                "\': custom WebApplicationContext class [" + contextClass.getName() +\n                "] is not of type ConfigurableWebApplicationContext");\n    }\n\n    // 通过反射实例化容器\n    ConfigurableWebApplicationContext wac =\n            (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);\n\n    wac.setEnvironment(getEnvironment());\n    wac.setParent(parent);\n    wac.setConfigLocation(getContextConfigLocation());\n\n    // 配置并刷新容器\n    configureAndRefreshWebApplicationContext(wac);\n\n    return wac;\n}\n\nprotected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac) {\n    if (ObjectUtils.identityToString(wac).equals(wac.getId())) {\n        // 设置容器 id\n        if (this.contextId != null) {\n            wac.setId(this.contextId);\n        }\n        else {\n            // 生成默认 id\n            wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +\n                    ObjectUtils.getDisplayString(getServletContext().getContextPath()) + \'/\' + getServletName());\n        }\n    }\n\n    wac.setServletContext(getServletContext());\n    wac.setServletConfig(getServletConfig());\n    wac.setNamespace(getNamespace());\n    wac.addApplicationListener(new SourceFilteringListener(wac, new ContextRefreshListener()));\n\n    ConfigurableEnvironment env = wac.getEnvironment();\n    if (env instanceof ConfigurableWebEnvironment) {\n        ((ConfigurableWebEnvironment) env).initPropertySources(getServletContext(), getServletConfig());\n    }\n\n    // 后置处理，子类可以覆盖进行一些自定义操作。在 Spring MVC 未使用到，是个空方法。\n    postProcessWebApplicationContext(wac);\n    applyInitializers(wac);\n    // 刷新容器\n    wac.refresh();\n}\n')])])]),n("p",[e._v("以上就是创建 Web 容器的源码，下面总结一下该容器创建的过程。如下：")]),e._v(" "),n("ol",[n("li",[e._v("从 ServletContext 中获取 ContextLoaderListener 创建的容器")]),e._v(" "),n("li",[e._v("若 this.webApplicationContext != null 条件成立，仅设置父容器和刷新容器即可")]),e._v(" "),n("li",[e._v("尝试从 ServletContext 中获取容器，若容器不为空，则无需执行步骤4")]),e._v(" "),n("li",[e._v("创建容器，并将 rootContext 作为父容器")]),e._v(" "),n("li",[e._v("设置容器到 ServletContext 中")])]),e._v(" "),n("p",[e._v("到这里，关于 Web 容器的创建过程就讲完了。总的来说，Web 容器的创建过程和业务容器的创建过程大致相同，但是差异也是有的，不能忽略。")])])}),[],!1,null,null,null);t.default=o.exports}}]);