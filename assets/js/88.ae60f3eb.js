(window.webpackJsonp=window.webpackJsonp||[]).push([[88],{517:function(e,t,r){"use strict";r.r(t);var n=r(30),a=Object(n.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"spring-aop-源码分析-创建代理对象"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#spring-aop-源码分析-创建代理对象"}},[e._v("#")]),e._v(" Spring AOP 源码分析 - 创建代理对象")]),e._v(" "),r("h2",{attrs:{id:"_1-简介"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-简介"}},[e._v("#")]),e._v(" 1.简介")]),e._v(" "),r("p",[e._v("在上一篇"),r("a",{attrs:{href:"http://www.coolblog.xyz/2018/06/20/Spring-AOP-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%AD%9B%E9%80%89%E5%90%88%E9%80%82%E7%9A%84%E9%80%9A%E7%9F%A5%E5%99%A8/",target:"_blank",rel:"noopener noreferrer"}},[e._v("文章"),r("OutboundLink")],1),e._v("中，我分析了 Spring 是如何为目标 bean 筛选合适的通知器的。现在通知器选好了，接下来就要通过代理的方式将通知器（Advisor）所持有的通知（Advice）织入到 bean 的某些方法前后。与筛选合适的通知器相比，创建代理对象的过程则要简单不少，本文所分析的源码不过100行，相对比较简单。在接下里的章节中，我将会首先向大家介绍一些背景知识，然后再去分析源码。那下面，我们先来了解一下背景知识。")]),e._v(" "),r("h2",{attrs:{id:"_2-背景知识"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-背景知识"}},[e._v("#")]),e._v(" 2.背景知识")]),e._v(" "),r("h3",{attrs:{id:"_2-1-proxy-target-class"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-proxy-target-class"}},[e._v("#")]),e._v(" 2.1 proxy-target-class")]),e._v(" "),r("p",[e._v("在 Spring AOP 配置中，proxy-target-class 属性可影响 Spring 生成的代理对象的类型。以 XML 配置为例，可进行如下配置：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('<aop:aspectj-autoproxy proxy-target-class="true"/>\n\n<aop:config proxy-target-class="true">\n    <aop:aspect id="xxx" ref="xxxx">\n        \x3c!-- 省略 --\x3e\n    </aop:aspect>\n</aop:config>\n')])])]),r("p",[e._v("如上，默认情况下 proxy-target-class 属性为 false。当目标 bean 实现了接口时，Spring 会基于 JDK 动态代理为目标 bean 创建代理对象。若未实现任何接口，Spring 则会通过 CGLIB 创建代理。而当 proxy-target-class 属性设为 true 时，则会强制 Spring 通过 CGLIB 的方式创建代理对象，即使目标 bean 实现了接口。")]),e._v(" "),r("p",[e._v("关于 proxy-target-class 属性的用途这里就说完了，下面我们来看看两种不同创建动态代理的方式。")]),e._v(" "),r("h3",{attrs:{id:"_2-2-动态代理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-动态代理"}},[e._v("#")]),e._v(" 2.2 动态代理")]),e._v(" "),r("h4",{attrs:{id:"_2-2-1-基于-jdk-的动态代理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-1-基于-jdk-的动态代理"}},[e._v("#")]),e._v(" 2.2.1 基于 JDK 的动态代理")]),e._v(" "),r("p",[e._v("基于 JDK 的动态代理主要是通过 JDK 提供的代理创建类 Proxy 为目标对象创建代理，下面我们来看一下 Proxy 中创建代理的方法声明。如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("public static Object newProxyInstance(ClassLoader loader,\n                                          Class<?>[] interfaces,\n                                          InvocationHandler h)\n")])])]),r("p",[e._v("简单说一下上面的参数列表：")]),e._v(" "),r("ul",[r("li",[e._v("loader - 类加载器")]),e._v(" "),r("li",[e._v("interfaces - 目标类所实现的接口列表")]),e._v(" "),r("li",[e._v("h - 用于封装代理逻辑")])]),e._v(" "),r("p",[e._v("JDK 动态代理对目标类是有一定要求的，即要求目标类必须实现了接口，JDK 动态代理只能为实现了接口的目标类生成代理对象。至于 InvocationHandler，是一个接口类型，定义了一个 invoke 方法。使用者需要实现该方法，并在其中封装代理逻辑。")]),e._v(" "),r("p",[e._v("关于 JDK 动态代理的介绍，就先说到这。下面我来演示一下 JDK 动态代理的使用方式，如下：")]),e._v(" "),r("p",[e._v("目标类定义：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('public interface UserService {\n\n    void save(User user);\n\n    void update(User user);\n}\n\npublic class UserServiceImpl implements UserService {\n\n    @Override\n    public void save(User user) {\n        System.out.println("save user info");\n    }\n\n    @Override\n    public void update(User user) {\n        System.out.println("update user info");\n    }\n}\n')])])]),r("p",[e._v("代理创建者定义：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('public interface ProxyCreator {\n\n    Object getProxy();\n}\n\npublic class JdkProxyCreator implements ProxyCreator, InvocationHandler {\n\n    private Object target;\n\n    public JdkProxyCreator(Object target) {\n        assert target != null;\n        Class<?>[] interfaces = target.getClass().getInterfaces();\n        if (interfaces.length == 0) {\n            throw new IllegalArgumentException("target class don`t implement any interface");\n        }\n        this.target = target;\n    }\n\n    @Override\n    public Object getProxy() {\n        Class<?> clazz = target.getClass();\n        // 生成代理对象\n        return Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), this);\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\n        System.out.println(System.currentTimeMillis() + " - " + method.getName() + " method start");\n        // 调用目标方法\n        Object retVal = method.invoke(target, args);\n        System.out.println(System.currentTimeMillis() + " - " + method.getName() + " method over");\n\n        return retVal;\n    }\n}\n')])])]),r("p",[e._v("如上，invoke 方法中的代理逻辑主要用于记录目标方法的调用时间，和结束时间。下面写点测试代码简单验证一下，如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('public class JdkProxyCreatorTest {\n\n    @Test\n    public void getProxy() throws Exception {\n        ProxyCreator proxyCreator = new JdkProxyCreator(new UserServiceImpl());\n        UserService userService = (UserService) proxyCreator.getProxy();\n        \n        System.out.println("proxy type = " + userService.getClass());\n        System.out.println();\n        userService.save(null);\n        System.out.println();\n        userService.update(null);\n    }\n}\n')])])]),r("p",[e._v("测试结果如下：")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15294833087427.jpg",alt:"img"}})]),e._v(" "),r("p",[e._v("如上，从测试结果中。我们可以看出，我们的代理逻辑正常执行了。另外，注意一下 userService 指向对象的类型，并非是 xyz.coolblog.proxy.UserServiceImpl，而是 com.sun.proxy.$Proxy4。")]),e._v(" "),r("p",[e._v("关于 JDK 动态代理，这里先说这么多。下一节，我来演示一下 CGLIB 动态代理，继续往下看吧。")]),e._v(" "),r("h4",{attrs:{id:"_2-2-2-基于-cglib-的动态代理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-2-基于-cglib-的动态代理"}},[e._v("#")]),e._v(" 2.2.2 基于 CGLIB 的动态代理")]),e._v(" "),r("p",[e._v("当我们要为未实现接口的类生成代理时，就无法使用 JDK 动态代理了。那么此类的目标对象生成代理时应该怎么办呢？当然是使用 CGLIB 了。在 CGLIB 中，代理逻辑是封装在 MethodInterceptor 实现类中的，代理对象则是通过 Enhancer 类的 create 方法进行创建。下面我来演示一下 CGLIB 创建代理对象的过程，如下：")]),e._v(" "),r("p",[e._v("本节的演示环节，打算调侃（无贬低之意）一下"),r("code",[e._v("59式坦克")]),e._v("，这是我们国家大量装备过的一款坦克。59式坦克有很多种改款，一般把改款统称为"),r("code",[e._v("59改")]),e._v("，59改这个梗也正是源于此。下面我们先来一览"),r("code",[e._v("59式坦克")]),e._v("的风采：")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15295147963356.jpg",alt:"img"}}),e._v("\n图片来源："),r("a",{attrs:{href:"http://t.cn/RBsOpyi",target:"_blank",rel:"noopener noreferrer"}},[e._v("百度图片搜索"),r("OutboundLink")],1)]),e._v(" "),r("p",[e._v("下面我们的工作就是为咱们的 59 创建一个代理，即 59改。好了，开始我们的魔改吧。")]),e._v(" "),r("p",[e._v("目标类，59式坦克：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('public class Tank59 {\n\n    void run() {\n        System.out.println("极速前行中....");\n    }\n\n    void shoot() {\n        System.out.println("轰...轰...轰...轰...");\n    }\n}\n')])])]),r("p",[e._v("CGLIB 代理创建者")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("public class CglibProxyCreator implements ProxyCreator {\n\n    private Object target;\n\n    private MethodInterceptor methodInterceptor;\n\n    public CglibProxyCreator(Object target, MethodInterceptor methodInterceptor) {\n        assert (target != null && methodInterceptor != null);\n        this.target = target;\n        this.methodInterceptor = methodInterceptor;\n    }\n\n    @Override\n    public Object getProxy() {\n        Enhancer enhancer = new Enhancer();\n        // 设置代理类的父类\n        enhancer.setSuperclass(target.getClass());\n        // 设置代理逻辑\n        enhancer.setCallback(methodInterceptor);\n        // 创建代理对象\n        return enhancer.create();\n    }\n}\n")])])]),r("p",[e._v("方法拦截器 - 坦克再制造：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('public class TankRemanufacture implements MethodInterceptor {\n\n    @Override\n    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n        if (method.getName().equals("run")) {\n            System.out.println("正在重造59坦克...");\n            System.out.println("重造成功，已获取 ✨59改 之 超音速飞行版✨");\n            System.out.print("已起飞，正在突破音障。");\n\n            methodProxy.invokeSuper(o, objects);\n\n            System.out.println("已击落黑鸟 SR-71，正在返航...");\n            return null;\n        }\n\n        return methodProxy.invokeSuper(o, objects);\n    }\n}\n')])])]),r("p",[e._v("好了，下面开始演示，测试代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('public class CglibProxyCreatorTest {\n\n    @Test\n    public void getProxy() throws Exception {\n        ProxyCreator proxyCreator = new CglibProxyCreator(new Tank59(), new TankRemanufacture());\n        Tank59 tank59 = (Tank59) proxyCreator.getProxy();\n        \n        System.out.println("proxy class = " + tank59.getClass() + "\\n");\n        tank59.run();\n        System.out.println();\n        System.out.print("射击测试：");\n        tank59.shoot();\n    }\n}\n')])])]),r("p",[e._v("测试结果如下：")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://blog-pictures.oss-cn-shanghai.aliyuncs.com/152948556087881.jpg",alt:"img"}})]),e._v(" "),r("p",[e._v("如上，“极速前行中…” 和 “轰…轰…轰…轰…” 这两行字符串是目标对象中的方法打印出来的，其他的则是由代理逻辑打印的。由此可知，我们的代理逻辑生效了。")]),e._v(" "),r("p",[e._v("好了，最后我们来看一下，经过魔改后的 59，也就是"),r("code",[e._v("超音速59改")]),e._v("的效果图：")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://blog-pictures.oss-cn-shanghai.aliyuncs.com/123412931423.jpg",alt:"img"}}),e._v("\n图片来源：未知")]),e._v(" "),r("p",[e._v("本节用59式坦克举例，仅是调侃，并无恶意。作为年轻的一代，我们应感谢那些为国防事业做出贡献的科技人员们。没有他们贡献，我们怕是不会有像今天这样安全的环境了（尽管不完美）。")]),e._v(" "),r("p",[e._v("到此，背景知识就介绍完了。下一章，我将开始分析源码。源码不是很长，主逻辑比较容易懂，所以一起往下看吧。")]),e._v(" "),r("h2",{attrs:{id:"_3-源码分析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-源码分析"}},[e._v("#")]),e._v(" 3.源码分析")]),e._v(" "),r("p",[e._v("为目标 bean 创建代理对象前，需要先创建 AopProxy 对象，然后再调用该对象的 getProxy 方法创建实际的代理类。我们先来看看 AopProxy 这个接口的定义，如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("public interface AopProxy {\n\n    /** 创建代理对象 */\n    Object getProxy();\n    \n    Object getProxy(ClassLoader classLoader);\n}\n")])])]),r("p",[e._v("在 Spring 中，有两个类实现了 AopProxy，如下：")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15295015982446.jpg",alt:"img"}})]),e._v(" "),r("p",[e._v("Spring 在为目标 bean 创建代理的过程中，要根据 bean 是否实现接口，以及一些其他配置来决定使用 AopProxy 何种实现类为目标 bean 创建代理对象。下面我们就来看一下代理创建的过程，如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('protected Object createProxy(\n        Class<?> beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource) {\n\n    if (this.beanFactory instanceof ConfigurableListableBeanFactory) {\n        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass);\n    }\n\n    ProxyFactory proxyFactory = new ProxyFactory();\n    proxyFactory.copyFrom(this);\n\n    /*\n     * 默认配置下，或用户显式配置 proxy-target-class = "false" 时，\n     * 这里的 proxyFactory.isProxyTargetClass() 也为 false\n     */\n    if (!proxyFactory.isProxyTargetClass()) {\n        if (shouldProxyTargetClass(beanClass, beanName)) {\n            proxyFactory.setProxyTargetClass(true);\n        }\n        else {\n            /*\n             * 检测 beanClass 是否实现了接口，若未实现，则将 \n             * proxyFactory 的成员变量 proxyTargetClass 设为 true\n             */ \n            evaluateProxyInterfaces(beanClass, proxyFactory);\n        }\n    }\n\n    // specificInterceptors 中若包含有 Advice，此处将 Advice 转为 Advisor\n    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);\n    proxyFactory.addAdvisors(advisors);\n    proxyFactory.setTargetSource(targetSource);\n    customizeProxyFactory(proxyFactory);\n\n    proxyFactory.setFrozen(this.freezeProxy);\n    if (advisorsPreFiltered()) {\n        proxyFactory.setPreFiltered(true);\n    }\n\n    // 创建代理\n    return proxyFactory.getProxy(getProxyClassLoader());\n}\n\npublic Object getProxy(ClassLoader classLoader) {\n    // 先创建 AopProxy 实现类对象，然后再调用 getProxy 为目标 bean 创建代理对象\n    return createAopProxy().getProxy(classLoader);\n}\n')])])]),r("p",[e._v("getProxy 这里有两个方法调用，一个是调用 createAopProxy 创建 AopProxy 实现类对象，然后再调用 AopProxy 实现类对象中的 getProxy 创建代理对象。这里我们先来看一下创建 AopProxy 实现类对象的过程，如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('protected final synchronized AopProxy createAopProxy() {\n    if (!this.active) {\n        activate();\n    }\n    return getAopProxyFactory().createAopProxy(this);\n}\n\npublic class DefaultAopProxyFactory implements AopProxyFactory, Serializable {\n\n    @Override\n    public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {\n        /*\n         * 下面的三个条件简单分析一下：\n         *\n         *   条件1：config.isOptimize() - 是否需要优化，这个属性没怎么用过，\n         *         细节我不是很清楚\n         *   条件2：config.isProxyTargetClass() - 检测 proxyTargetClass 的值，\n         *         前面的代码会设置这个值\n         *   条件3：hasNoUserSuppliedProxyInterfaces(config) \n         *         - 目标 bean 是否实现了接口\n         */\n        if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {\n            Class<?> targetClass = config.getTargetClass();\n            if (targetClass == null) {\n                throw new AopConfigException("TargetSource cannot determine target class: " +\n                        "Either an interface or a target is required for proxy creation.");\n            }\n            if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {\n                return new JdkDynamicAopProxy(config);\n            }\n            // 创建 CGLIB 代理，ObjenesisCglibAopProxy 继承自 CglibAopProxy\n            return new ObjenesisCglibAopProxy(config);\n        }\n        else {\n            // 创建 JDK 动态代理\n            return new JdkDynamicAopProxy(config);\n        }\n    }\n}\n')])])]),r("p",[e._v("如上，DefaultAopProxyFactory 根据一些条件决定生成什么类型的 AopProxy 实现类对象。生成好 AopProxy 实现类对象后，下面就要为目标 bean 创建代理对象了。这里以 JdkDynamicAopProxy 为例，我们来看一下，该类的 getProxy 方法的逻辑是怎样的。如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('public Object getProxy() {\n    return getProxy(ClassUtils.getDefaultClassLoader());\n}\n\npublic Object getProxy(ClassLoader classLoader) {\n    if (logger.isDebugEnabled()) {\n        logger.debug("Creating JDK dynamic proxy: target source is " + this.advised.getTargetSource());\n    }\n    Class<?>[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true);\n    findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);\n    \n    // 调用 newProxyInstance 创建代理对象\n    return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);\n}\n')])])]),r("p",[e._v("如上，请把目光移至最后一行有效代码上，会发现 JdkDynamicAopProxy 最终调用 Proxy.newProxyInstance 方法创建代理对象。到此，创建代理对象的整个过程也就分析完了，不知大家看懂了没。好了，关于创建代理的源码分析，就先说到这里吧。")])])}),[],!1,null,null,null);t.default=a.exports}}]);