(window.webpackJsonp=window.webpackJsonp||[]).push([[131],{546:function(e,n,t){"use strict";t.r(n);var a=t(30),i=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"并发容器之arrayblockingqueue和linkedblockingqueue实现原理详解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#并发容器之arrayblockingqueue和linkedblockingqueue实现原理详解"}},[e._v("#")]),e._v(" 并发容器之ArrayBlockingQueue和LinkedBlockingQueue实现原理详解")]),e._v(" "),t("h2",{attrs:{id:"_1-arrayblockingqueue-简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-arrayblockingqueue-简介"}},[e._v("#")]),e._v(" 1. ArrayBlockingQueue 简介")]),e._v(" "),t("p",[e._v("在多线程编程过程中，为了业务解耦和架构设计，经常会使用并发容器用于存储多线程间的共享数据，这样不仅可以保证线程安全，还可以简化各个线程操作。例如在“生产者-消费者”问题中，会使用阻塞队列（BlockingQueue）作为数据容器，关于 BlockingQueue 可以"),t("a",{attrs:{href:"https://juejin.im/post/6844903602444582920",target:"_blank",rel:"noopener noreferrer"}},[e._v("看这篇文章"),t("OutboundLink")],1),e._v("。为了加深对阻塞队列的理解，唯一的方式是对其实验原理进行理解，这篇文章就主要来看看 ArrayBlockingQueue 和 LinkedBlockingQueue 的实现原理。")]),e._v(" "),t("h2",{attrs:{id:"_2-arrayblockingqueue-实现原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-arrayblockingqueue-实现原理"}},[e._v("#")]),e._v(" 2. ArrayBlockingQueue 实现原理")]),e._v(" "),t("p",[e._v("阻塞队列最核心的功能是，能够可阻塞式的插入和删除队列元素。当前队列为空时，会阻塞消费数据的线程，直至队列非空时，通知被阻塞的线程；当队列满时，会阻塞插入数据的线程，直至队列未满时，通知插入数据的线程（生产者线程）。那么，多线程中消息通知机制最常用的是 lock 的 condition 机制，关于 condition 可以"),t("a",{attrs:{href:"https://juejin.im/post/6844903602419400718",target:"_blank",rel:"noopener noreferrer"}},[e._v("看这篇文章的详细介绍"),t("OutboundLink")],1),e._v("。那么 ArrayBlockingQueue 的实现是不是也会采用 Condition 的通知机制呢？下面来看看。")]),e._v(" "),t("h4",{attrs:{id:"_2-1-arrayblockingqueue-的主要属性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-arrayblockingqueue-的主要属性"}},[e._v("#")]),e._v(" 2.1 ArrayBlockingQueue 的主要属性")]),e._v(" "),t("p",[e._v("ArrayBlockingQueue 的主要属性如下:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("/** The queued items */\nfinal Object[] items;\n/** items index for next take, poll, peek or remove */\nint takeIndex;\n/** items index for next put, offer, or add */\nint putIndex;\n/** Number of elements in the queue */\nint count;\n/*\n\nConcurrency control uses the classic two-condition algorithm\nfound in any textbook.\n*/\n\n/** Main lock guarding all access */\nfinal ReentrantLock lock;\n/** Condition for waiting takes */\nprivate final Condition notEmpty;\n复制代码/** Condition for waiting puts */\nprivate final Condition notFull;\n")])])]),t("p",[e._v("从源码中可以看出 ArrayBlockingQueue 内部是采用数组进行数据存储的（"),t("code",[e._v("属性items")]),e._v("），为了保证线程安全，采用的是"),t("code",[e._v("ReentrantLock lock")]),e._v("，为了保证可阻塞式的插入删除数据利用的是 Condition，当获取数据的消费者线程被阻塞时会将该线程放置到 notEmpty 等待队列中，当插入数据的生产者线程被阻塞时，会将该线程放置到 notFull 等待队列中。而 notEmpty 和 notFull 等中要属性在构造方法中进行创建：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public ArrayBlockingQueue(int capacity, boolean fair) {\n    if (capacity <= 0)\n        throw new IllegalArgumentException();\n    this.items = new Object[capacity];\n    lock = new ReentrantLock(fair);\n    notEmpty = lock.newCondition();\n    notFull =  lock.newCondition();\n}\n复制代码\n")])])]),t("p",[e._v("接下来，主要看看可阻塞式的 put 和 take 方法是怎样实现的。")]),e._v(" "),t("h4",{attrs:{id:"_2-2-put-方法详解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-put-方法详解"}},[e._v("#")]),e._v(" 2.2 put 方法详解")]),e._v(" "),t("p",[t("code",[e._v("put(E e)")]),e._v("方法源码如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public void put(E e) throws InterruptedException {\n    checkNotNull(e);\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n\t\t//如果当前队列已满，将线程移入到notFull等待队列中\n        while (count == items.length)\n            notFull.await();\n\t\t//满足插入数据的要求，直接进行入队操作\n        enqueue(e);\n    } finally {\n        lock.unlock();\n    }\n}\n复制代码\n")])])]),t("p",[e._v("该方法的逻辑很简单，当队列已满时（"),t("code",[e._v("count == items.length")]),e._v("）将线程移入到 notFull 等待队列中，如果当前满足插入数据的条件，就可以直接调用"),t("code",[e._v("enqueue(e)")]),e._v("插入数据元素。enqueue 方法源码为：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("private void enqueue(E x) {\n    // assert lock.getHoldCount() == 1;\n    // assert items[putIndex] == null;\n    final Object[] items = this.items;\n\t//插入数据\n    items[putIndex] = x;\n    if (++putIndex == items.length)\n        putIndex = 0;\n    count++;\n\t//通知消费者线程，当前队列中有数据可供消费\n    notEmpty.signal();\n}\n复制代码\n")])])]),t("p",[e._v("enqueue 方法的逻辑同样也很简单，先完成插入数据，即往数组中添加数据（"),t("code",[e._v("items[putIndex] = x")]),e._v("），然后通知被阻塞的消费者线程，当前队列中有数据可供消费（"),t("code",[e._v("notEmpty.signal()")]),e._v("）。")]),e._v(" "),t("h4",{attrs:{id:"_2-3-take-方法详解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-take-方法详解"}},[e._v("#")]),e._v(" 2.3 take 方法详解")]),e._v(" "),t("p",[e._v("take 方法源码如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public E take() throws InterruptedException {\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n\t\t//如果队列为空，没有数据，将消费者线程移入等待队列中\n        while (count == 0)\n            notEmpty.await();\n\t\t//获取数据\n        return dequeue();\n    } finally {\n        lock.unlock();\n    }\n}\n复制代码\n")])])]),t("p",[e._v("take 方法也主要做了两步：1. 如果当前队列为空的话，则将获取数据的消费者线程移入到等待队列中；2. 若队列不为空则获取数据，即完成出队操作"),t("code",[e._v("dequeue")]),e._v("。dequeue 方法源码为：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('private E dequeue() {\n    // assert lock.getHoldCount() == 1;\n    // assert items[takeIndex] != null;\n    final Object[] items = this.items;\n    @SuppressWarnings("unchecked")\n\t//获取数据\n    E x = (E) items[takeIndex];\n    items[takeIndex] = null;\n    if (++takeIndex == items.length)\n        takeIndex = 0;\n    count--;\n    if (itrs != null)\n        itrs.elementDequeued();\n    //通知被阻塞的生产者线程\n\tnotFull.signal();\n    return x;\n}\n复制代码\n')])])]),t("p",[e._v("dequeue 方法也主要做了两件事情：1. 获取队列中的数据，即获取数组中的数据元素（"),t("code",[e._v("(E) items[takeIndex]")]),e._v("）；2. 通知 notFull 等待队列中的线程，使其由等待队列移入到同步队列中，使其能够有机会获得 lock，并执行完成功退出。")]),e._v(" "),t("p",[e._v("从以上分析，可以看出 put 和 take 方法主要是通过 condition 的通知机制来完成可阻塞式的插入数据和获取数据。在理解 ArrayBlockingQueue 后再去理解 LinkedBlockingQueue 就很容易了。")]),e._v(" "),t("h2",{attrs:{id:"_3-linkedblockingqueue-实现原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-linkedblockingqueue-实现原理"}},[e._v("#")]),e._v(" 3. LinkedBlockingQueue 实现原理")]),e._v(" "),t("p",[e._v("LinkedBlockingQueue 是用链表实现的有界阻塞队列，当构造对象时为指定队列大小时，队列默认大小为"),t("code",[e._v("Integer.MAX_VALUE")]),e._v("。从它的构造方法可以看出：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public LinkedBlockingQueue() {\n    this(Integer.MAX_VALUE);\n}\n复制代码\n")])])]),t("h4",{attrs:{id:"_3-1-linkedblockingqueue-的主要属性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-linkedblockingqueue-的主要属性"}},[e._v("#")]),e._v(" 3.1 LinkedBlockingQueue 的主要属性")]),e._v(" "),t("p",[e._v("LinkedBlockingQueue 的主要属性有：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("/** Current number of elements */\nprivate final AtomicInteger count = new AtomicInteger();\n/**\n\nHead of linked list.\nInvariant: head.item == null\n*/\ntransient Node<E> head;\n\n/**\n\nTail of linked list.\nInvariant: last.next == null\n*/\nprivate transient Node<E> last;\n\n/** Lock held by take, poll, etc */\nprivate final ReentrantLock takeLock = new ReentrantLock();\n/** Wait queue for waiting takes */\nprivate final Condition notEmpty = takeLock.newCondition();\n/** Lock held by put, offer, etc */\nprivate final ReentrantLock putLock = new ReentrantLock();\n复制代码/** Wait queue for waiting puts */\nprivate final Condition notFull = putLock.newCondition();\n")])])]),t("p",[e._v("可以看出与 ArrayBlockingQueue 主要的区别是，LinkedBlockingQueue 在插入数据和删除数据时分别是由两个不同的 lock（"),t("code",[e._v("takeLock")]),e._v("和"),t("code",[e._v("putLock")]),e._v("）来控制线程安全的，因此，也由这两个 lock 生成了两个对应的 condition（"),t("code",[e._v("notEmpty")]),e._v("和"),t("code",[e._v("notFull")]),e._v("）来实现可阻塞的插入和删除数据。并且，采用了链表的数据结构来实现队列，Node 结点的定义为：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("static class Node<E> {    E item; /** * One of: * - the real successor Node * - this Node, meaning the successor is head.next * - null, meaning there is no successor (this is the last node) */ Node<E> next; Node(E x) { item = x; } 复制代码 复制代码\n} \n")])])]),t("p",[e._v("接下来，我们也同样来看看 put 方法和 take 方法的实现。")]),e._v(" "),t("h4",{attrs:{id:"_3-2-put-方法详解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-put-方法详解"}},[e._v("#")]),e._v(" 3.2 put 方法详解")]),e._v(" "),t("p",[e._v("put 方法源码为:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public void put(E e) throws InterruptedException {\n    if (e == null) throw new NullPointerException();\n    // Note: convention in all put/take/etc is to preset local var\n    // holding count negative to indicate failure unless set.\n    int c = -1;\n    Node<E> node = new Node<E>(e);\n    final ReentrantLock putLock = this.putLock;\n    final AtomicInteger count = this.count;\n    putLock.lockInterruptibly();\n    try {\n        /*\n         * Note that count is used in wait guard even though it is\n         * not protected by lock. This works because count can\n         * only decrease at this point (all other puts are shut\n         * out by lock), and we (or some other waiting put) are\n         * signalled if it ever changes from capacity. Similarly\n         * for all other uses of count in other wait guards.\n         */\n\t\t//如果队列已满，则阻塞当前线程，将其移入等待队列\n        while (count.get() == capacity) {\n            notFull.await();\n        }\n\t\t//入队操作，插入数据\n        enqueue(node);\n        c = count.getAndIncrement();\n\t\t//若队列满足插入数据的条件，则通知被阻塞的生产者线程\n        if (c + 1 < capacity)\n            notFull.signal();\n    } finally {\n        putLock.unlock();\n    }\n    if (c == 0)\n        signalNotEmpty();\n}\n复制代码\n")])])]),t("p",[e._v("put 方法的逻辑也同样很容易理解，可见注释。基本上和 ArrayBlockingQueue 的 put 方法一样。take 方法的源码如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public E take() throws InterruptedException {\n    E x;\n    int c = -1;\n    final AtomicInteger count = this.count;\n    final ReentrantLock takeLock = this.takeLock;\n    takeLock.lockInterruptibly();\n    try {\n\t\t//当前队列为空，则阻塞当前线程，将其移入到等待队列中，直至满足条件\n        while (count.get() == 0) {\n            notEmpty.await();\n        }\n\t\t//移除队头元素，获取数据\n        x = dequeue();\n        c = count.getAndDecrement();\n        //如果当前满足移除元素的条件，则通知被阻塞的消费者线程\n\t\tif (c > 1)\n            notEmpty.signal();\n    } finally {\n        takeLock.unlock();\n    }\n    if (c == capacity)\n        signalNotFull();\n    return x;\n}\n复制代码\n")])])]),t("p",[e._v("take 方法的主要逻辑请见于注释，也很容易理解。")]),e._v(" "),t("h2",{attrs:{id:"_4-arrayblockingqueue-与-linkedblockingqueue-的比较"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-arrayblockingqueue-与-linkedblockingqueue-的比较"}},[e._v("#")]),e._v(" 4. ArrayBlockingQueue 与 LinkedBlockingQueue 的比较")]),e._v(" "),t("p",[t("strong",[e._v("相同点")]),e._v("：ArrayBlockingQueue 和 LinkedBlockingQueue 都是通过 condition 通知机制来实现可阻塞式插入和删除元素，并满足线程安全的特性；")]),e._v(" "),t("p",[t("strong",[e._v("不同点")]),e._v("：1. ArrayBlockingQueue 底层是采用的数组进行实现，而 LinkedBlockingQueue 则是采用链表数据结构；")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("ArrayBlockingQueue 插入和删除数据，只采用了一个 lock，而 LinkedBlockingQueue 则是在插入和删除分别采用了"),t("code",[e._v("putLock")]),e._v("和"),t("code",[e._v("takeLock")]),e._v("，这样可以降低线程由于线程无法获取到 lock 而进入 WAITING 状态的可能性，从而提高了线程并发执行的效率。")]),e._v(" "),t("p",[e._v("来源于 https://juejin.cn/post/6844903602448760845")])])])])}),[],!1,null,null,null);n.default=i.exports}}]);