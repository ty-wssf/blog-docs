(window.webpackJsonp=window.webpackJsonp||[]).push([[91],{520:function(e,t,n){"use strict";n.r(t);var o=n(30),r=Object(o.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"spring-aop-源码分析-拦截器链的执行过程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spring-aop-源码分析-拦截器链的执行过程"}},[e._v("#")]),e._v(" Spring AOP 源码分析 - 拦截器链的执行过程")]),e._v(" "),n("h2",{attrs:{id:"_1-简介"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-简介"}},[e._v("#")]),e._v(" 1.简介")]),e._v(" "),n("p",[e._v("本篇文章是 AOP 源码分析系列文章的最后一篇文章，在前面的两篇文章中，我分别介绍了 Spring AOP 是如何为目标 bean 筛选合适的通知器，以及如何创建代理对象的过程。现在我们的得到了 bean 的代理对象，且通知也以合适的方式插在了目标方法的前后。接下来要做的事情，就是执行通知逻辑了。通知可能在目标方法前执行，也可能在目标方法后执行。具体的执行时机，取决于用户的配置。当目标方法被多个通知匹配到时，Spring 通过引入拦截器链来保证每个通知的正常执行。在本文中，我们将会通过源码了解到 Spring 是如何支持 expose-proxy 属性的，以及通知与拦截器之间的关系，拦截器链的执行过程等。和上一篇"),n("a",{attrs:{href:"http://www.coolblog.xyz/2018/06/20/Spring-AOP-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1/",target:"_blank",rel:"noopener noreferrer"}},[e._v("文章"),n("OutboundLink")],1),e._v("一样，在进行源码分析前，我们先来了解一些背景知识。好了，下面进入正题吧。")]),e._v(" "),n("h2",{attrs:{id:"_2-背景知识"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-背景知识"}},[e._v("#")]),e._v(" 2.背景知识")]),e._v(" "),n("p",[e._v("关于 expose-proxy，我们先来说说它有什么用，然后再来说说怎么用。Spring 引入 expose-proxy 特性是为了解决"),n("strong",[e._v("目标方法调用同对象中其他方法时，其他方法的切面逻辑无法执行的问题")]),e._v("。这个解释可能不好理解，不直观。那下面我来演示一下它的用法，大家就知道是怎么回事了。我们先来看看 expose-proxy 是怎样配置的，如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<bean id="hello" class="xyz.coolblog.aop.Hello"/>\n<bean id="aopCode" class="xyz.coolblog.aop.AopCode"/>\n\n<aop:aspectj-autoproxy expose-proxy="true" />\n\n<aop:config expose-proxy="true">\n    <aop:aspect id="myaspect" ref="aopCode">\n        <aop:pointcut id="helloPointcut" expression="execution(* xyz.coolblog.aop.*.hello*(..))" />\n        <aop:before method="before" pointcut-ref="helloPointcut" />\n    </aop:aspect>\n</aop:config>\n')])])]),n("p",[e._v("如上，expose-proxy 可配置在 "),n("code",[e._v("<aop:config/>")]),e._v(" 和 "),n("code",[e._v("<aop:aspectj-autoproxy />")]),e._v(" 标签上。在使用 expose-proxy 时，需要对内部调用进行改造，比如：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('public class Hello implements IHello {\n\n    @Override\n    public void hello() {\n        System.out.println("hello");\n        this.hello("world");\n    }\n\n    @Override\n    public void hello(String hello) {\n        System.out.println("hello " +  hello);\n    }\n}\n')])])]),n("p",[n("code",[e._v("hello()")]),e._v("方法调用了同类中的另一个方法"),n("code",[e._v("hello(String)")]),e._v("，此时"),n("code",[e._v("hello(String)")]),e._v("上的切面逻辑就无法执行了。这里，我们要对"),n("code",[e._v("hello()")]),e._v("方法进行改造，强制它调用代理对象中的"),n("code",[e._v("hello(String)")]),e._v("。改造结果如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('public class Hello implements IHello {\n\n    @Override\n    public void hello() {\n        System.out.println("hello");\n        ((IHello) AopContext.currentProxy()).hello("world");\n    }\n\n    @Override\n    public void hello(String hello) {\n        System.out.println("hello " +  hello);\n    }\n}\n')])])]),n("p",[e._v("如上，"),n("code",[e._v("AopContext.currentProxy()")]),e._v("用于获取当前的代理对象。当 expose-proxy 被配置为 true 时，该代理对象会被放入 ThreadLocal 中。关于 expose-proxy，这里先说这么多，后面分析源码时会再次提及。")]),e._v(" "),n("h2",{attrs:{id:"_3-源码分析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-源码分析"}},[e._v("#")]),e._v(" 3.源码分析")]),e._v(" "),n("p",[e._v("本章所分析的源码来自 JdkDynamicAopProxy，至于 CglibAopProxy 中的源码，大家若有兴趣可以自己去看一下。")]),e._v(" "),n("h3",{attrs:{id:"_3-1-jdk-动态代理逻辑分析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-jdk-动态代理逻辑分析"}},[e._v("#")]),e._v(" 3.1 JDK 动态代理逻辑分析")]),e._v(" "),n("p",[e._v("本节，我来分析一下 JDK 动态代理逻辑。对于 JDK 动态代理，代理逻辑封装在 InvocationHandler 接口实现类的 invoke 方法中。JdkDynamicAopProxy 实现了 InvocationHandler 接口，下面我们就来分析一下 JdkDynamicAopProxy 的 invoke 方法。如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n    MethodInvocation invocation;\n    Object oldProxy = null;\n    boolean setProxyContext = false;\n\n    TargetSource targetSource = this.advised.targetSource;\n    Class<?> targetClass = null;\n    Object target = null;\n\n    try {\n        // 省略部分代码\n        Object retVal;\n\n        // 如果 expose-proxy 属性为 true，则暴露代理对象\n        if (this.advised.exposeProxy) {\n            // 向 AopContext 中设置代理对象\n            oldProxy = AopContext.setCurrentProxy(proxy);\n            setProxyContext = true;\n        }\n\n        // 获取适合当前方法的拦截器\n        List<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);\n\n        // 如果拦截器链为空，则直接执行目标方法\n        if (chain.isEmpty()) {\n            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);\n            // 通过反射执行目标方法\n            retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);\n        }\n        else {\n            // 创建一个方法调用器，并将拦截器链传入其中\n            invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);\n            // 执行拦截器链\n            retVal = invocation.proceed();\n        }\n\n        // 获取方法返回值类型\n        Class<?> returnType = method.getReturnType();\n        if (retVal != null && retVal == target &&\n                returnType != Object.class && returnType.isInstance(proxy) &&\n                !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {\n            // 如果方法返回值为 this，即 return this; 则将代理对象 proxy 赋值给 retVal \n            retVal = proxy;\n        }\n        // 如果返回值类型为基础类型，比如 int，long 等，当返回值为 null，抛出异常\n        else if (retVal == null && returnType != Void.TYPE && returnType.isPrimitive()) {\n            throw new AopInvocationException(\n                    "Null return value from advice does not match primitive return type for: " + method);\n        }\n        return retVal;\n    }\n    finally {\n        if (target != null && !targetSource.isStatic()) {\n            targetSource.releaseTarget(target);\n        }\n        if (setProxyContext) {\n            AopContext.setCurrentProxy(oldProxy);\n        }\n    }\n}\n')])])]),n("p",[e._v("如上，上面的代码我做了比较详细的注释。下面我们来总结一下 invoke 方法的执行流程，如下：")]),e._v(" "),n("ol",[n("li",[e._v("检测 expose-proxy 是否为 true，若为 true，则暴露代理对象")]),e._v(" "),n("li",[e._v("获取适合当前方法的拦截器")]),e._v(" "),n("li",[e._v("如果拦截器链为空，则直接通过反射执行目标方法")]),e._v(" "),n("li",[e._v("若拦截器链不为空，则创建方法调用 ReflectiveMethodInvocation 对象")]),e._v(" "),n("li",[e._v("调用 ReflectiveMethodInvocation 对象的 proceed() 方法启动拦截器链")]),e._v(" "),n("li",[e._v("处理返回值，并返回该值")])]),e._v(" "),n("p",[e._v("在以上6步中，我们重点关注第2步和第5步中的逻辑。第2步用于获取拦截器链，第5步则是启动拦截器链。下面先来分析获取拦截器链的过程。")]),e._v(" "),n("h3",{attrs:{id:"_3-2-获取所有的拦截器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-获取所有的拦截器"}},[e._v("#")]),e._v(" 3.2 获取所有的拦截器")]),e._v(" "),n("p",[e._v("所谓的拦截器，顾名思义，是指用于对目标方法的调用进行拦截的一种工具。拦截器的源码比较简单，所以我们直接看源码好了。下面以前置通知拦截器为例，如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('public class MethodBeforeAdviceInterceptor implements MethodInterceptor, Serializable {\n    \n    /** 前置通知 */\n    private MethodBeforeAdvice advice;\n\n    public MethodBeforeAdviceInterceptor(MethodBeforeAdvice advice) {\n        Assert.notNull(advice, "Advice must not be null");\n        this.advice = advice;\n    }\n\n    @Override\n    public Object invoke(MethodInvocation mi) throws Throwable {\n        // 执行前置通知逻辑\n        this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis());\n        // 通过 MethodInvocation 调用下一个拦截器，若所有拦截器均执行完，则调用目标方法\n        return mi.proceed();\n    }\n}\n')])])]),n("p",[e._v("如上，前置通知的逻辑在目标方法执行前被执行。这里先简单向大家介绍一下拦截器是什么，关于拦截器更多的描述将放在下一节中。本节我们先来看看如何如何获取拦截器，如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public List<Object> getInterceptorsAndDynamicInterceptionAdvice(Method method, Class<?> targetClass) {\n    MethodCacheKey cacheKey = new MethodCacheKey(method);\n    // 从缓存中获取\n    List<Object> cached = this.methodCache.get(cacheKey);\n    // 缓存未命中，则进行下一步处理\n    if (cached == null) {\n        // 获取所有的拦截器\n        cached = this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(\n                this, method, targetClass);\n        // 存入缓存\n        this.methodCache.put(cacheKey, cached);\n    }\n    return cached;\n}\n\npublic List<Object> getInterceptorsAndDynamicInterceptionAdvice(\n        Advised config, Method method, Class<?> targetClass) {\n\n    List<Object> interceptorList = new ArrayList<Object>(config.getAdvisors().length);\n    Class<?> actualClass = (targetClass != null ? targetClass : method.getDeclaringClass());\n    boolean hasIntroductions = hasMatchingIntroductions(config, actualClass);\n    // registry 为 DefaultAdvisorAdapterRegistry 类型\n    AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();\n\n    // 遍历通知器列表\n    for (Advisor advisor : config.getAdvisors()) {\n        if (advisor instanceof PointcutAdvisor) {\n            PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;\n            /*\n             * 调用 ClassFilter 对 bean 类型进行匹配，无法匹配则说明当前通知器\n             * 不适合应用在当前 bean 上\n             */\n            if (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) {\n                // 将 advisor 中的 advice 转成相应的拦截器\n                MethodInterceptor[] interceptors = registry.getInterceptors(advisor);\n                MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();\n                // 通过方法匹配器对目标方法进行匹配\n                if (MethodMatchers.matches(mm, method, actualClass, hasIntroductions)) {\n                    // 若 isRuntime 返回 true，则表明 MethodMatcher 要在运行时做一些检测\n                    if (mm.isRuntime()) {\n                        for (MethodInterceptor interceptor : interceptors) {\n                            interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm));\n                        }\n                    }\n                    else {\n                        interceptorList.addAll(Arrays.asList(interceptors));\n                    }\n                }\n            }\n        }\n        else if (advisor instanceof IntroductionAdvisor) {\n            IntroductionAdvisor ia = (IntroductionAdvisor) advisor;\n            // IntroductionAdvisor 类型的通知器，仅需进行类级别的匹配即可\n            if (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) {\n                Interceptor[] interceptors = registry.getInterceptors(advisor);\n                interceptorList.addAll(Arrays.asList(interceptors));\n            }\n        }\n        else {\n            Interceptor[] interceptors = registry.getInterceptors(advisor);\n            interceptorList.addAll(Arrays.asList(interceptors));\n        }\n    }\n\n    return interceptorList;\n}\n\npublic MethodInterceptor[] getInterceptors(Advisor advisor) throws UnknownAdviceTypeException {\n    List<MethodInterceptor> interceptors = new ArrayList<MethodInterceptor>(3);\n    Advice advice = advisor.getAdvice();\n    /*\n     * 若 advice 是 MethodInterceptor 类型的，直接添加到 interceptors 中即可。\n     * 比如 AspectJAfterAdvice 就实现了 MethodInterceptor 接口\n     */\n    if (advice instanceof MethodInterceptor) {\n        interceptors.add((MethodInterceptor) advice);\n    }\n\n    /*\n     * 对于 AspectJMethodBeforeAdvice 等类型的通知，由于没有实现 MethodInterceptor \n     * 接口，所以这里需要通过适配器进行转换\n     */ \n    for (AdvisorAdapter adapter : this.adapters) {\n        if (adapter.supportsAdvice(advice)) {\n            interceptors.add(adapter.getInterceptor(advisor));\n        }\n    }\n    if (interceptors.isEmpty()) {\n        throw new UnknownAdviceTypeException(advisor.getAdvice());\n    }\n    return interceptors.toArray(new MethodInterceptor[interceptors.size()]);\n}\n")])])]),n("p",[e._v("以上就是获取拦截器的过程，代码有点长，不过好在逻辑不是很复杂。这里简单总结一下以上源码的执行过程，如下：")]),e._v(" "),n("ol",[n("li",[e._v("从缓存中获取当前方法的拦截器链")]),e._v(" "),n("li",[e._v("若缓存未命中，则调用 getInterceptorsAndDynamicInterceptionAdvice 获取拦截器链")]),e._v(" "),n("li",[e._v("遍历通知器列表")]),e._v(" "),n("li",[e._v("对于 PointcutAdvisor 类型的通知器，这里要调用通知器所持有的切点（Pointcut）对类和方法进行匹配，匹配成功说明应向当前方法织入通知逻辑")]),e._v(" "),n("li",[e._v("调用 getInterceptors 方法对非 MethodInterceptor 类型的通知进行转换")]),e._v(" "),n("li",[e._v("返回拦截器数组，并在随后存入缓存中")])]),e._v(" "),n("p",[e._v("这里需要说明一下，部分通知器是没有实现 MethodInterceptor 接口的，比如 AspectJMethodBeforeAdvice。我们可以看一下前置通知适配器是如何将前置通知转为拦截器的，如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("class MethodBeforeAdviceAdapter implements AdvisorAdapter, Serializable {\n\n    @Override\n    public boolean supportsAdvice(Advice advice) {\n        return (advice instanceof MethodBeforeAdvice);\n    }\n\n    @Override\n    public MethodInterceptor getInterceptor(Advisor advisor) {\n        MethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice();\n        // 创建 MethodBeforeAdviceInterceptor 拦截器\n        return new MethodBeforeAdviceInterceptor(advice);\n    }\n}\n")])])]),n("p",[e._v("如上，适配器的逻辑比较简单，这里就不多说了。")]),e._v(" "),n("p",[e._v("现在我们已经获得了拦截器链，那接下来要做的事情就是启动拦截器了。所以接下来，我们一起去看看 Sring 是如何让拦截器链运行起来的。")]),e._v(" "),n("h3",{attrs:{id:"_3-3-启动拦截器链"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-启动拦截器链"}},[e._v("#")]),e._v(" 3.3 启动拦截器链")]),e._v(" "),n("h4",{attrs:{id:"_3-3-1-执行拦截器链"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-1-执行拦截器链"}},[e._v("#")]),e._v(" 3.3.1 执行拦截器链")]),e._v(" "),n("p",[e._v("本节的开始，我们先来说说 ReflectiveMethodInvocation。ReflectiveMethodInvocation 贯穿于拦截器链执行的始终，可以说是核心。该类的 proceed 方法用于启动启动拦截器链，下面我们去看看这个方法的逻辑。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public class ReflectiveMethodInvocation implements ProxyMethodInvocation {\n\n    private int currentInterceptorIndex = -1;\n\n    public Object proceed() throws Throwable {\n        // 拦截器链中的最后一个拦截器执行完后，即可执行目标方法\n        if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {\n            // 执行目标方法\n            return invokeJoinpoint();\n        }\n\n        Object interceptorOrInterceptionAdvice =\n                this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);\n        if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) {\n            InterceptorAndDynamicMethodMatcher dm =\n                    (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;\n            /*\n             * 调用具有三个参数（3-args）的 matches 方法动态匹配目标方法，\n             * 两个参数（2-args）的 matches 方法用于静态匹配\n             */\n            if (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) {\n                // 调用拦截器逻辑\n                return dm.interceptor.invoke(this);\n            }\n            else {\n                // 如果匹配失败，则忽略当前的拦截器\n                return proceed();\n            }\n        }\n        else {\n            // 调用拦截器逻辑，并传递 ReflectiveMethodInvocation 对象\n            return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);\n        }\n    }\n}\n")])])]),n("p",[e._v("如上，proceed 根据 currentInterceptorIndex 来确定当前应执行哪个拦截器，并在调用拦截器的 invoke 方法时，将自己作为参数传给该方法。前面的章节中，我们看过了前置拦截器的源码，这里来看一下后置拦截器源码。如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public class AspectJAfterAdvice extends AbstractAspectJAdvice\n        implements MethodInterceptor, AfterAdvice, Serializable {\n\n    public AspectJAfterAdvice(\n            Method aspectJBeforeAdviceMethod, AspectJExpressionPointcut pointcut, AspectInstanceFactory aif) {\n\n        super(aspectJBeforeAdviceMethod, pointcut, aif);\n    }\n\n\n    @Override\n    public Object invoke(MethodInvocation mi) throws Throwable {\n        try {\n            // 调用 proceed\n            return mi.proceed();\n        }\n        finally {\n            // 调用后置通知逻辑\n            invokeAdviceMethod(getJoinPointMatch(), null, null);\n        }\n    }\n\n    //...\n}\n")])])]),n("p",[e._v("如上，由于后置通知需要在目标方法返回后执行，所以 AspectJAfterAdvice 先调用 mi.proceed() 执行下一个拦截器逻辑，等下一个拦截器返回后，再执行后置通知逻辑。如果大家不太理解的话，先看个图。这里假设目标方法 method 在执行前，需要执行两个前置通知和一个后置通知。下面我们看一下由三个拦截器组成的拦截器链是如何执行的，如下：")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15296571948329.jpg",alt:"img"}}),e._v("\n注：这里用 advice.after() 表示执行后置通知")]),e._v(" "),n("p",[e._v("本节的最后，插播一个拦截器，即 ExposeInvocationInterceptor。为啥要在这里介绍这个拦截器呢，原因是我在"),n("a",{attrs:{href:"http://www.coolblog.xyz/2018/06/20/Spring-AOP-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%AD%9B%E9%80%89%E5%90%88%E9%80%82%E7%9A%84%E9%80%9A%E7%9F%A5%E5%99%A8/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Spring AOP 源码分析 - 筛选合适的通知器"),n("OutboundLink")],1),e._v("一文中，在介绍 extendAdvisors 方法时，有一个点没有详细说明。现在大家已经知道拦截器的概念了，就可以把之前没法详细说明的地方进行补充说明。这里再贴一下 extendAdvisors 方法的源码，如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("protected void extendAdvisors(List<Advisor> candidateAdvisors) {\n    AspectJProxyUtils.makeAdvisorChainAspectJCapableIfNecessary(candidateAdvisors);\n}\n\npublic static boolean makeAdvisorChainAspectJCapableIfNecessary(List<Advisor> advisors) {\n    if (!advisors.isEmpty()) {\n        // 省略部分代码\n\n        if (foundAspectJAdvice && !advisors.contains(ExposeInvocationInterceptor.ADVISOR)) {\n            // 向通知器列表中添加 ExposeInvocationInterceptor.ADVISOR\n            advisors.add(0, ExposeInvocationInterceptor.ADVISOR);\n            return true;\n        }\n    }\n    return false;\n}\n")])])]),n("p",[e._v("如上，extendAdvisors 所调用的方法会向通知器列表首部添加 ExposeInvocationInterceptor.ADVISOR。现在我们再来看看 ExposeInvocationInterceptor 的源码，如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('public class ExposeInvocationInterceptor implements MethodInterceptor, PriorityOrdered, Serializable {\n\n    public static final ExposeInvocationInterceptor INSTANCE = new ExposeInvocationInterceptor();\n\n    // 创建 DefaultPointcutAdvisor 匿名对象\n    public static final Advisor ADVISOR = new DefaultPointcutAdvisor(INSTANCE) {\n        @Override\n        public String toString() {\n            return ExposeInvocationInterceptor.class.getName() +".ADVISOR";\n        }\n    };\n\n    private static final ThreadLocal<MethodInvocation> invocation =\n            new NamedThreadLocal<MethodInvocation>("Current AOP method invocation");\n\n    public static MethodInvocation currentInvocation() throws IllegalStateException {\n        MethodInvocation mi = invocation.get();\n        if (mi == null)\n            throw new IllegalStateException(\n                    "No MethodInvocation found: Check that an AOP invocation is in progress, and that the " +\n                    "ExposeInvocationInterceptor is upfront in the interceptor chain. Specifically, note that " +\n                    "advices with order HIGHEST_PRECEDENCE will execute before ExposeInvocationInterceptor!");\n        return mi;\n    }\n\n    // 私有构造方法\n    private ExposeInvocationInterceptor() {\n    }\n\n    @Override\n    public Object invoke(MethodInvocation mi) throws Throwable {\n        MethodInvocation oldInvocation = invocation.get();\n        // 将 mi 设置到 ThreadLocal 中\n        invocation.set(mi);\n        try {\n            // 调用下一个拦截器\n            return mi.proceed();\n        }\n        finally {\n            invocation.set(oldInvocation);\n        }\n    }\n\n    //...\n}\n')])])]),n("p",[e._v("如上，ExposeInvocationInterceptor.ADVISOR 经过 registry.getInterceptors 方法（前面已分析过）处理后，即可得到 ExposeInvocationInterceptor。ExposeInvocationInterceptor 的作用是用于暴露 MethodInvocation 对象到 ThreadLocal 中，其名字也体现出了这一点。如果其他地方需要当前的 MethodInvocation 对象，直接通过调用 currentInvocation 方法取出。至于哪些地方需要 MethodInvocation，这个大家自己去探索吧。最后，建议大家写点代码调试一下。我在一开始阅读代码时，并没有注意到 ExposeInvocationInterceptor，而是在调试代码的过程中才发现的。比如：")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15296520452255.jpg",alt:"img"}})]),e._v(" "),n("p",[e._v("好了，关于拦截器链的执行过程这里就讲完了。下一节，我们来看一下目标方法的执行过程。大家再忍忍，源码很快分析完了。")]),e._v(" "),n("h4",{attrs:{id:"_3-3-2-执行目标方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-2-执行目标方法"}},[e._v("#")]),e._v(" 3.3.2 执行目标方法")]),e._v(" "),n("p",[e._v("与前面的大部头相比，本节的源码比较短，也很简单。本节我们来看一下目标方法的执行过程，如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("protected Object invokeJoinpoint() throws Throwable {\n    return AopUtils.invokeJoinpointUsingReflection(this.target, this.method, this.arguments);\n}\n\npublic abstract class AopUtils {\n    public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args)\n            throws Throwable {\n\n        try {\n            ReflectionUtils.makeAccessible(method);\n            // 通过反射执行目标方法\n            return method.invoke(target, args);\n        }\n        catch (InvocationTargetException ex) {...}\n        catch (IllegalArgumentException ex) {...}\n        catch (IllegalAccessException ex) {...}\n    }\n}\n")])])]),n("p",[e._v("目标方法时通过反射执行的，比较简单的吧。好了，就不多说了，over。")])])}),[],!1,null,null,null);t.default=r.exports}}]);