(window.webpackJsonp=window.webpackJsonp||[]).push([[103],{532:function(t,a,r){"use strict";r.r(a);var o=r(30),n=Object(o.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"locksupport工具"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#locksupport工具"}},[t._v("#")]),t._v(" LockSupport工具")]),t._v(" "),r("h2",{attrs:{id:"_1-locksupport-简介"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-locksupport-简介"}},[t._v("#")]),t._v(" 1. LockSupport 简介")]),t._v(" "),r("p",[t._v("在之前介绍"),r("a",{attrs:{href:"https://juejin.im/post/6844903601538596877",target:"_blank",rel:"noopener noreferrer"}},[t._v("AQS 的底层实现"),r("OutboundLink")],1),t._v("，已经在介绍 java 中的 Lock 时，比如"),r("a",{attrs:{href:"https://juejin.im/post/6844903601542807559",target:"_blank",rel:"noopener noreferrer"}},[t._v("ReentrantLock"),r("OutboundLink")],1),t._v(","),r("a",{attrs:{href:"https://juejin.im/post/6844903601546985485",target:"_blank",rel:"noopener noreferrer"}},[t._v("ReentReadWriteLocks"),r("OutboundLink")],1),t._v(",已经在介绍线程间等待/通知机制使用的"),r("a",{attrs:{href:"https://juejin.im/post/6844903602419400718",target:"_blank",rel:"noopener noreferrer"}},[t._v("Condition"),r("OutboundLink")],1),t._v("时都会调用 LockSupport.park()方法和 LockSupport.unpark()方法。而这个在同步组件的实现中被频繁使用的 LockSupport 到底是何方神圣，现在就来看看。LockSupport 位于 java.util.concurrent.locks 包下，有兴趣的可以直接去看源码，该类的方法并不是很多。LockSupprot 是线程的阻塞原语，用来阻塞线程和唤醒线程。每个使用 LockSupport 的线程都会与一个许可关联，如果该许可可用，并且可在线程中使用，则调用 park()将会立即返回，否则可能阻塞。如果许可尚不可用，则可以调用 unpark 使其可用。但是注意许可"),r("strong",[t._v("不可重入")]),t._v("，也就是说只能调用一次 park()方法，否则会一直阻塞。")]),t._v(" "),r("h2",{attrs:{id:"_2-locksupport-方法介绍"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-locksupport-方法介绍"}},[t._v("#")]),t._v(" 2. LockSupport 方法介绍")]),t._v(" "),r("p",[t._v("LockSupport 中的方法不多，这里将这些方法做一个总结：")]),t._v(" "),r("blockquote",[r("p",[r("strong",[t._v("阻塞线程")])])]),t._v(" "),r("ol",[r("li",[t._v("void park()：阻塞当前线程，如果调用 unpark 方法或者当前线程被中断，从能从 park()方法中返回")]),t._v(" "),r("li",[t._v("void park(Object blocker)：功能同方法 1，入参增加一个 Object 对象，用来记录导致线程阻塞的阻塞对象，方便进行问题排查；")]),t._v(" "),r("li",[t._v("void parkNanos(long nanos)：阻塞当前线程，最长不超过 nanos 纳秒，增加了超时返回的特性；")]),t._v(" "),r("li",[t._v("void parkNanos(Object blocker, long nanos)：功能同方法 3，入参增加一个 Object 对象，用来记录导致线程阻塞的阻塞对象，方便进行问题排查；")]),t._v(" "),r("li",[t._v("void parkUntil(long deadline)：阻塞当前线程，知道 deadline；")]),t._v(" "),r("li",[t._v("void parkUntil(Object blocker, long deadline)：功能同方法 5，入参增加一个 Object 对象，用来记录导致线程阻塞的阻塞对象，方便进行问题排查；")])]),t._v(" "),r("blockquote",[r("p",[r("strong",[t._v("唤醒线程")])])]),t._v(" "),r("p",[t._v("void unpark(Thread thread):唤醒处于阻塞状态的指定线程")]),t._v(" "),r("p",[t._v("实际上 LockSupport 阻塞和唤醒线程的功能是依赖于 sun.misc.Unsafe，这是一个很底层的类，有兴趣的可以去查阅资料，比如 park()方法的功能实现则是靠 unsafe.park()方法。另外在阻塞线程这一系列方法中还有一个很有意思的现象就是，每个方法都会新增一个带有 Object 的阻塞对象的重载方法。那么增加了一个 Object 对象的入参会有什么不同的地方了？示例代码很简单就不说了，直接看 dump 线程的信息。")]),t._v(" "),r("p",[r("strong",[t._v("调用 park()方法 dump 线程")]),t._v("：")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('"main" #1 prio=5 os_prio=0 tid=0x02cdcc00 nid=0x2b48 waiting on condition [0x00d6f000]\n   java.lang.Thread.State: WAITING (parking)\n        at sun.misc.Unsafe.park(Native Method)\n        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:304)\n        at learn.LockSupportDemo.main(LockSupportDemo.java:7)\n复制代码\n')])])]),r("p",[r("strong",[t._v("调用 park(Object blocker)方法 dump 线程")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('"main" #1 prio=5 os_prio=0 tid=0x0069cc00 nid=0x6c0 waiting on condition [0x00dcf000]\n   java.lang.Thread.State: WAITING (parking)\n        at sun.misc.Unsafe.park(Native Method)\n        - parking to wait for  <0x048c2d18> (a java.lang.String)\n        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)\n        at learn.LockSupportDemo.main(LockSupportDemo.java:7)\n复制代码\n')])])]),r("p",[t._v("通过分别调用这两个方法然后 dump 线程信息可以看出，带 Object 的 park 方法相较于无参的 park 方法会增加 parking to wait for <0x048c2d18> (a java.lang.String）的信息，这种信息就类似于记录“案发现场”，有助于工程人员能够迅速发现问题解决问题。有个有意思的事情是，我们都知道如果使用 synchronzed 阻塞了线程 dump 线程时都会有阻塞对象的描述，在 java 5 推出 LockSupport 时遗漏了这一点，在 java 6 时进行了补充。还有一点需要需要的是："),r("strong",[t._v("synchronzed 致使线程阻塞，线程会进入到 BLOCKED 状态，而调用 LockSupprt 方法阻塞线程会致使线程进入到 WAITING 状态。")])]),t._v(" "),r("h2",{attrs:{id:"_3-一个例子"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-一个例子"}},[t._v("#")]),t._v(" 3. 一个例子")]),t._v(" "),r("p",[t._v("用一个很简单的例子说说这些方法怎么用。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('public class LockSupportDemo {\n    public static void main(String[] args) {\n        Thread thread = new Thread(() -> {\n            LockSupport.park();\n            System.out.println(Thread.currentThread().getName() + "被唤醒");\n        });\n        thread.start();\n        try {\n            Thread.sleep(3000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        LockSupport.unpark(thread);\n    }\n}\n复制代码\n')])])]),r("p",[t._v("thread 线程调用 LockSupport.park()致使 thread 阻塞，当 mian 线程睡眠 3 秒结束后通过 LockSupport.unpark(thread)方法唤醒 thread 线程,thread 线程被唤醒执行后续操作。另外，还有一点值得关注的是，"),r("strong",[t._v("LockSupport.unpark(thread)可以指定线程对象唤醒指定的线程")]),t._v("。")]),t._v(" "),r("p",[t._v("来源于 https://juejin.cn/post/6844903602486525965")])])}),[],!1,null,null,null);a.default=n.exports}}]);