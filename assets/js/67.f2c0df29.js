(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{496:function(e,n,t){"use strict";t.r(n);var a=t(30),s=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"spring-aop-源码分析-筛选合适的通知器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-aop-源码分析-筛选合适的通知器"}},[e._v("#")]),e._v(" Spring AOP 源码分析 - 筛选合适的通知器")]),e._v(" "),t("h2",{attrs:{id:"_1-简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-简介"}},[e._v("#")]),e._v(" 1.简介")]),e._v(" "),t("p",[e._v("从本篇文章开始，我将会对 Spring AOP 部分的源码进行分析。本文是 Spring AOP 源码分析系列文章的第二篇，本文主要分析 Spring AOP 是如何为目标 bean 筛选出合适的通知器（Advisor）。在上一篇"),t("a",{attrs:{href:"http://www.coolblog.xyz/2018/06/17/Spring-AOP-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E5%AF%BC%E8%AF%BB/",target:"_blank",rel:"noopener noreferrer"}},[e._v("AOP 源码分析导读"),t("OutboundLink")],1),e._v("一文中，我简单介绍了 AOP 中的一些术语及其对应的源码，部分术语和源码将会在本篇文章中出现。如果大家不熟悉这些术语和源码，不妨去看看。\n关于 Spring AOP，我个人在日常开发中用过一些，也参照过 "),t("a",{attrs:{href:"https://github.com/code4craft/tiny-spring",target:"_blank",rel:"noopener noreferrer"}},[e._v("tiny-spring"),t("OutboundLink")],1),e._v(" 过写过一个玩具版的 AOP 框架，并写成了"),t("a",{attrs:{href:"https://www.tianxiaobo.com/2018/01/18/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0%E7%9A%84-Spring-IOC-%E5%92%8C-AOP-%E4%B8%8B%E7%AF%87/",target:"_blank",rel:"noopener noreferrer"}},[e._v("文章"),t("OutboundLink")],1),e._v("。正因为前面做了一些准备工作，最近再看 Spring AOP 源码时，觉得也没那么难了。所以如果大家打算看 AOP 源码的话，这里建议大家多做一些准备工作。比如熟悉 AOP 的中的术语，亦或是实现一个简单的 IOC 和 AOP，并将两者整合在一起。经过如此准备，相信大家会对 AOP 会有更多的认识。")]),e._v(" "),t("p",[e._v("好了，其他的就不多说了，下面进入源码分析阶段。")]),e._v(" "),t("h2",{attrs:{id:"_2-源码分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-源码分析"}},[e._v("#")]),e._v(" 2.源码分析")]),e._v(" "),t("h3",{attrs:{id:"_2-1-aop-入口分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-aop-入口分析"}},[e._v("#")]),e._v(" 2.1 AOP 入口分析")]),e._v(" "),t("p",[e._v("在导读一文中，我已经说过 Spring AOP 是在何处向目标 bean 中织入通知（Advice）的。也说过 Spring 是如何将 AOP 和 IOC 模块整合到一起的，即通过拓展点 BeanPostProcessor 接口。Spring AOP 抽象代理创建器实现了 BeanPostProcessor 接口，并在 bean 初始化后置处理过程中向 bean 中织入通知。下面我们就来看看相关源码，如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public abstract class AbstractAutoProxyCreator extends ProxyProcessorSupport\n        implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware {\n    \n    @Override\n    /** bean 初始化后置处理方法 */\n    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n        if (bean != null) {\n            Object cacheKey = getCacheKey(bean.getClass(), beanName);\n            if (!this.earlyProxyReferences.contains(cacheKey)) {\n                // 如果需要，为 bean 生成代理对象\n                return wrapIfNecessary(bean, beanName, cacheKey);\n            }\n        }\n        return bean;\n    }\n    \n    protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {\n        if (beanName != null && this.targetSourcedBeans.contains(beanName)) {\n            return bean;\n        }\n        if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) {\n            return bean;\n        }\n\n        /*\n         * 如果是基础设施类（Pointcut、Advice、Advisor 等接口的实现类），或是应该跳过的类，\n         * 则不应该生成代理，此时直接返回 bean\n         */ \n        if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) {\n            // 将 <cacheKey, FALSE> 键值对放入缓存中，供上面的 if 分支使用\n            this.advisedBeans.put(cacheKey, Boolean.FALSE);\n            return bean;\n        }\n\n        // 为目标 bean 查找合适的通知器\n        Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);\n        /*\n         * 若 specificInterceptors != null，即 specificInterceptors != DO_NOT_PROXY，\n         * 则为 bean 生成代理对象，否则直接返回 bean\n         */ \n        if (specificInterceptors != DO_NOT_PROXY) {\n            this.advisedBeans.put(cacheKey, Boolean.TRUE);\n            // 创建代理\n            Object proxy = createProxy(\n                    bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));\n            this.proxyTypes.put(cacheKey, proxy.getClass());\n            /*\n             * 返回代理对象，此时 IOC 容器输入 bean，得到 proxy。此时，\n             * beanName 对应的 bean 是代理对象，而非原始的 bean\n             */ \n            return proxy;\n        }\n\n        this.advisedBeans.put(cacheKey, Boolean.FALSE);\n        // specificInterceptors = null，直接返回 bean\n        return bean;\n    }\n}\n")])])]),t("p",[e._v("以上就是 Spring AOP 创建代理对象的入口方法分析，过程比较简单，这里简单总结一下：")]),e._v(" "),t("ol",[t("li",[e._v("若 bean 是 AOP 基础设施类型，则直接返回")]),e._v(" "),t("li",[e._v("为 bean 查找合适的通知器")]),e._v(" "),t("li",[e._v("如果通知器数组不为空，则为 bean 生成代理对象，并返回该对象")]),e._v(" "),t("li",[e._v("若数组为空，则返回原始 bean")])]),e._v(" "),t("p",[e._v("上面的流程看起来并不复杂，不过不要被表象所迷糊，以上流程不过是冰山一角。")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15294224650963.jpg",alt:"img"}}),e._v("\n图片来源：无版权图片网站 "),t("a",{attrs:{href:"https://pixabay.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("pixabay.com"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("在本文，以及后续的文章中，我将会对步骤2和步骤3对应的源码进行分析。在本篇文章先来分析步骤2对应的源码。")]),e._v(" "),t("h3",{attrs:{id:"_2-2-筛选合适的通知器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-筛选合适的通知器"}},[e._v("#")]),e._v(" 2.2 筛选合适的通知器")]),e._v(" "),t("p",[e._v("在向目标 bean 中织入通知之前，我们先要为 bean 筛选出合适的通知器（通知器持有通知）。如何筛选呢？方式由很多，比如我们可以通过正则表达式匹配方法名，当然更多的时候用的是 AspectJ 表达式进行匹配。那下面我们就来看一下使用 AspectJ 表达式筛选通知器的过程，如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("protected Object[] getAdvicesAndAdvisorsForBean(Class<?> beanClass, String beanName, TargetSource targetSource) {\n    // 查找合适的通知器\n    List<Advisor> advisors = findEligibleAdvisors(beanClass, beanName);\n    if (advisors.isEmpty()) {\n        return DO_NOT_PROXY;\n    }\n    return advisors.toArray();\n}\n\nprotected List<Advisor> findEligibleAdvisors(Class<?> beanClass, String beanName) {\n    // 查找所有的通知器\n    List<Advisor> candidateAdvisors = findCandidateAdvisors();\n    /*\n     * 筛选可应用在 beanClass 上的 Advisor，通过 ClassFilter 和 MethodMatcher\n     * 对目标类和方法进行匹配\n     */\n    List<Advisor> eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);\n    // 拓展操作\n    extendAdvisors(eligibleAdvisors);\n    if (!eligibleAdvisors.isEmpty()) {\n        eligibleAdvisors = sortAdvisors(eligibleAdvisors);\n    }\n    return eligibleAdvisors;\n}\n")])])]),t("p",[e._v("如上，Spring 先查询出所有的通知器，然后再调用 findAdvisorsThatCanApply 对通知器进行筛选。在下面几节中，我将分别对 findCandidateAdvisors 和 findAdvisorsThatCanApply 两个方法进行分析，继续往下看吧。")]),e._v(" "),t("h4",{attrs:{id:"_2-2-1-查找通知器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-1-查找通知器"}},[e._v("#")]),e._v(" 2.2.1 查找通知器")]),e._v(" "),t("p",[e._v("Spring 提供了两种配置 AOP 的方式，一种是通过 XML 进行配置，另一种是注解。对于两种配置方式，Spring 的处理逻辑是不同的。对于 XML 类型的配置，比如下面的配置：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\x3c!-- 目标 bean --\x3e\n<bean id="hello" class="xyz.coolblog.aop.Hello"/>\n\n<aop:aspectj-autoproxy/>\n    \n\x3c!-- 普通 bean，包含 AOP 切面逻辑 --\x3e\n<bean id="aopCode" class="xyz.coolblog.aop.AopCode"/>\n\x3c!-- 由 @Aspect 注解修饰的切面类 --\x3e\n<bean id="annotationAopCode" class="xyz.coolblog.aop.AnnotationAopCode"/>\n\n<aop:config>\n    <aop:aspect ref="aopCode">\n        <aop:pointcut id="helloPointcut" expression="execution(* xyz.coolblog.aop.*.hello*(..))" />\n        <aop:before method="before" pointcut-ref="helloPointcut"/>\n        <aop:after method="after" pointcut-ref="helloPointcut"/>\n    </aop:aspect>\n</aop:config>\n')])])]),t("p",[e._v("Spring 会将上的配置解析为下面的结果：")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15293223296832.jpg",alt:"img"}})]),e._v(" "),t("p",[e._v("如上图所示，红框中对应的是普通的 bean 定义，比如 "),t("code",[e._v('<bean id="hello" .../>、<bean id="annotationAopCode" .../>、<bean id="appCode" .../>')]),e._v(" 等配置。黄色框中的则是切点的定义，类型为 AspectJExpressionPointcut，对应 "),t("code",[e._v('<aop:pointcut id="helloPointcut" .../>')]),e._v(" 配置。那绿色框中的结果对应的是什么配置呢？目前仅剩下两个配置没说，所以对应 "),t("code",[e._v("<aop:before .../>")]),e._v(" 和 "),t("code",[e._v("<aop:after .../>")]),e._v(" 配置，类型为 AspectJPointcutAdvisor。这里请大家注意，由 @Aspect 注解修饰的 AnnotationAopCode 也是普通类型的 bean，该 bean 会在查找通知器的过程中被解析，并被构建为一个或多个 Advisor。")]),e._v(" "),t("p",[e._v("上面讲解了 Spring AOP 两种配置的处理方式，算是为下面的源码分析做铺垫。现在铺垫完毕，我们就来分析一下源码吧。如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public class AnnotationAwareAspectJAutoProxyCreator extends AspectJAwareAdvisorAutoProxyCreator {\n\n    //...\n\n    @Override\n    protected List<Advisor> findCandidateAdvisors() {\n        // 调用父类方法从容器中查找所有的通知器\n        List<Advisor> advisors = super.findCandidateAdvisors();\n        // 解析 @Aspect 注解，并构建通知器\n        advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors());\n        return advisors;\n    }\n\n    //...\n}\n")])])]),t("p",[e._v("AnnotationAwareAspectJAutoProxyCreator 覆写了父类的方法 findCandidateAdvisors，并增加了一步操作，即解析 @Aspect 注解，并构建成通知器。下面我先来分析一下父类中的 findCandidateAdvisors 方法的逻辑，然后再来分析 buildAspectJAdvisors 方法逻的辑。")]),e._v(" "),t("h5",{attrs:{id:"_2-2-1-1-findcandidateadvisors-方法分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-1-1-findcandidateadvisors-方法分析"}},[e._v("#")]),e._v(" 2.2.1.1 findCandidateAdvisors 方法分析")]),e._v(" "),t("p",[e._v("我们先来看一下 AbstractAdvisorAutoProxyCreator 中 findCandidateAdvisors 方法的定义，如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public abstract class AbstractAdvisorAutoProxyCreator extends AbstractAutoProxyCreator {\n\n    private BeanFactoryAdvisorRetrievalHelper advisorRetrievalHelper;\n    \n    //...\n\n    protected List<Advisor> findCandidateAdvisors() {\n        return this.advisorRetrievalHelper.findAdvisorBeans();\n    }\n\n    //...\n}\n")])])]),t("p",[e._v("从上面的源码中可以看出，AbstractAdvisorAutoProxyCreator 中的 findCandidateAdvisors 是个空壳方法，所有逻辑封装在了一个 BeanFactoryAdvisorRetrievalHelper 的 findAdvisorBeans 方法中。这里大家可以仔细看一下类名 BeanFactoryAdvisorRetrievalHelper 和方法 findAdvisorBeans，两个名字其实已经描述出他们的职责了。BeanFactoryAdvisorRetrievalHelper 可以理解为"),t("code",[e._v("从 bean 容器中获取 Advisor 的帮助类")]),e._v("，findAdvisorBeans 则可理解为"),t("code",[e._v("查找 Advisor 类型的 bean")]),e._v("。所以即使不看 findAdvisorBeans 方法的源码，我们也可从方法名上推断出它要做什么，即从 bean 容器中将 Advisor 类型的 bean 查找出来。下面我来分析一下这个方法的源码，如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public List<Advisor> findAdvisorBeans() {\n    String[] advisorNames = null;\n    synchronized (this) {\n        // cachedAdvisorBeanNames 是 advisor 名称的缓存\n        advisorNames = this.cachedAdvisorBeanNames;\n        /*\n         * 如果 cachedAdvisorBeanNames 为空，这里到容器中查找，\n         * 并设置缓存，后续直接使用缓存即可\n         */ \n        if (advisorNames == null) {\n            // 从容器中查找 Advisor 类型 bean 的名称\n            advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(\n                    this.beanFactory, Advisor.class, true, false);\n            // 设置缓存\n            this.cachedAdvisorBeanNames = advisorNames;\n        }\n    }\n    if (advisorNames.length == 0) {\n        return new LinkedList<Advisor>();\n    }\n\n    List<Advisor> advisors = new LinkedList<Advisor>();\n    // 遍历 advisorNames\n    for (String name : advisorNames) {\n        if (isEligibleBean(name)) {\n            // 忽略正在创建中的 advisor bean\n            if (this.beanFactory.isCurrentlyInCreation(name)) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug("Skipping currently created advisor \'" + name + "\'");\n                }\n            }\n            else {\n                try {\n                    /*\n                     * 调用 getBean 方法从容器中获取名称为 name 的 bean，\n                     * 并将 bean 添加到 advisors 中\n                     */ \n                    advisors.add(this.beanFactory.getBean(name, Advisor.class));\n                }\n                catch (BeanCreationException ex) {\n                    Throwable rootCause = ex.getMostSpecificCause();\n                    if (rootCause instanceof BeanCurrentlyInCreationException) {\n                        BeanCreationException bce = (BeanCreationException) rootCause;\n                        if (this.beanFactory.isCurrentlyInCreation(bce.getBeanName())) {\n                            if (logger.isDebugEnabled()) {\n                                logger.debug("Skipping advisor \'" + name +\n                                        "\' with dependency on currently created bean: " + ex.getMessage());\n                            }\n                            continue;\n                        }\n                    }\n                    throw ex;\n                }\n            }\n        }\n    }\n\n    return advisors;\n}\n')])])]),t("p",[e._v("以上就是从容器中查找 Advisor 类型的 bean 所有的逻辑，代码虽然有点长，但并不复杂。主要做了两件事情：")]),e._v(" "),t("ol",[t("li",[e._v("从容器中查找所有类型为 Advisor 的 bean 对应的名称")]),e._v(" "),t("li",[e._v("遍历 advisorNames，并从容器中获取对应的 bean")])]),e._v(" "),t("p",[e._v("看完上面的分析，我们继续来分析一下 @Aspect 注解的解析过程。")]),e._v(" "),t("h5",{attrs:{id:"_2-2-1-2-buildaspectjadvisors-方法分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-1-2-buildaspectjadvisors-方法分析"}},[e._v("#")]),e._v(" 2.2.1.2 buildAspectJAdvisors 方法分析")]),e._v(" "),t("p",[e._v("与上一节的内容相比，解析 @Aspect 注解的过程还是比较复杂的，需要一些耐心去看。下面我们开始分析 buildAspectJAdvisors 方法的源码，如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public List<Advisor> buildAspectJAdvisors() {\n    List<String> aspectNames = this.aspectBeanNames;\n\n    if (aspectNames == null) {\n        synchronized (this) {\n            aspectNames = this.aspectBeanNames;\n            if (aspectNames == null) {\n                List<Advisor> advisors = new LinkedList<Advisor>();\n                aspectNames = new LinkedList<String>();\n                // 从容器中获取所有 bean 的名称\n                String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(\n                        this.beanFactory, Object.class, true, false);\n                // 遍历 beanNames\n                for (String beanName : beanNames) {\n                    if (!isEligibleBean(beanName)) {\n                        continue;\n                    }\n                    \n                    // 根据 beanName 获取 bean 的类型\n                    Class<?> beanType = this.beanFactory.getType(beanName);\n                    if (beanType == null) {\n                        continue;\n                    }\n\n                    // 检测 beanType 是否包含 Aspect 注解\n                    if (this.advisorFactory.isAspect(beanType)) {\n                        aspectNames.add(beanName);\n                        AspectMetadata amd = new AspectMetadata(beanType, beanName);\n                        if (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) {\n                            MetadataAwareAspectInstanceFactory factory =\n                                    new BeanFactoryAspectInstanceFactory(this.beanFactory, beanName);\n\n                            // 获取通知器\n                            List<Advisor> classAdvisors = this.advisorFactory.getAdvisors(factory);\n                            if (this.beanFactory.isSingleton(beanName)) {\n                                this.advisorsCache.put(beanName, classAdvisors);\n                            }\n                            else {\n                                this.aspectFactoryCache.put(beanName, factory);\n                            }\n                            advisors.addAll(classAdvisors);\n                        }\n                        else {\n                            if (this.beanFactory.isSingleton(beanName)) {\n                                throw new IllegalArgumentException("Bean with name \'" + beanName +\n                                        "\' is a singleton, but aspect instantiation model is not singleton");\n                            }\n                            MetadataAwareAspectInstanceFactory factory =\n                                    new PrototypeAspectInstanceFactory(this.beanFactory, beanName);\n                            this.aspectFactoryCache.put(beanName, factory);\n                            advisors.addAll(this.advisorFactory.getAdvisors(factory));\n                        }\n                    }\n                }\n                this.aspectBeanNames = aspectNames;\n                return advisors;\n            }\n        }\n    }\n\n    if (aspectNames.isEmpty()) {\n        return Collections.emptyList();\n    }\n    List<Advisor> advisors = new LinkedList<Advisor>();\n    for (String aspectName : aspectNames) {\n        List<Advisor> cachedAdvisors = this.advisorsCache.get(aspectName);\n        if (cachedAdvisors != null) {\n            advisors.addAll(cachedAdvisors);\n        }\n        else {\n            MetadataAwareAspectInstanceFactory factory = this.aspectFactoryCache.get(aspectName);\n            advisors.addAll(this.advisorFactory.getAdvisors(factory));\n        }\n    }\n    return advisors;\n}\n')])])]),t("p",[e._v("上面就是 buildAspectJAdvisors 的代码，看起来比较长。代码比较多，我们关注重点的方法调用即可。在进行后续的分析前，这里先对 buildAspectJAdvisors 方法的执行流程做个总结。如下：")]),e._v(" "),t("ol",[t("li",[e._v("获取容器中所有 bean 的名称（beanName）")]),e._v(" "),t("li",[e._v("遍历上一步获取到的 bean 名称数组，并获取当前 beanName 对应的 bean 类型（beanType）")]),e._v(" "),t("li",[e._v("根据 beanType 判断当前 bean 是否是一个的 Aspect 注解类，若不是则不做任何处理")]),e._v(" "),t("li",[e._v("调用 advisorFactory.getAdvisors 获取通知器")])]),e._v(" "),t("p",[e._v("下面我们来重点分析"),t("code",[e._v("advisorFactory.getAdvisors(factory)")]),e._v("这个调用，如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public List<Advisor> getAdvisors(MetadataAwareAspectInstanceFactory aspectInstanceFactory) {\n    // 获取 aspectClass 和 aspectName\n    Class<?> aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();\n    String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName();\n    validate(aspectClass);\n\n    MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory =\n            new LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory);\n\n    List<Advisor> advisors = new LinkedList<Advisor>();\n\n    // getAdvisorMethods 用于返回不包含 @Pointcut 注解的方法\n    for (Method method : getAdvisorMethods(aspectClass)) {\n        // 为每个方法分别调用 getAdvisor 方法\n        Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);\n        if (advisor != null) {\n            advisors.add(advisor);\n        }\n    }\n\n    // If it's a per target aspect, emit the dummy instantiating aspect.\n    if (!advisors.isEmpty() && lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) {\n        Advisor instantiationAdvisor = new SyntheticInstantiationAdvisor(lazySingletonAspectInstanceFactory);\n        advisors.add(0, instantiationAdvisor);\n    }\n\n    // Find introduction fields.\n    for (Field field : aspectClass.getDeclaredFields()) {\n        Advisor advisor = getDeclareParentsAdvisor(field);\n        if (advisor != null) {\n            advisors.add(advisor);\n        }\n    }\n\n    return advisors;\n}\n\npublic Advisor getAdvisor(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,\n        int declarationOrderInAspect, String aspectName) {\n\n    validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());\n\n    // 获取切点实现类\n    AspectJExpressionPointcut expressionPointcut = getPointcut(\n            candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());\n    if (expressionPointcut == null) {\n        return null;\n    }\n\n    // 创建 Advisor 实现类\n    return new InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,\n            this, aspectInstanceFactory, declarationOrderInAspect, aspectName);\n}\n")])])]),t("p",[e._v("如上，getAdvisor 方法包含两个主要步骤，一个是获取 AspectJ 表达式切点，另一个是创建 Advisor 实现类。在第二个步骤中，包含一个隐藏步骤 – 创建 Advice。下面我将按顺序依次分析这两个步骤，先看获取 AspectJ 表达式切点的过程，如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("private AspectJExpressionPointcut getPointcut(Method candidateAdviceMethod, Class<?> candidateAspectClass) {\n    // 获取方法上的 AspectJ 相关注解，包括 @Before，@After 等\n    AspectJAnnotation<?> aspectJAnnotation =\n            AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);\n    if (aspectJAnnotation == null) {\n        return null;\n    }\n\n    // 创建一个 AspectJExpressionPointcut 对象\n    AspectJExpressionPointcut ajexp =\n            new AspectJExpressionPointcut(candidateAspectClass, new String[0], new Class<?>[0]);\n    // 设置切点表达式\n    ajexp.setExpression(aspectJAnnotation.getPointcutExpression());\n    ajexp.setBeanFactory(this.beanFactory);\n    return ajexp;\n}\n\nprotected static AspectJAnnotation<?> findAspectJAnnotationOnMethod(Method method) {\n    // classesToLookFor 中的元素是大家熟悉的\n    Class<?>[] classesToLookFor = new Class<?>[] {\n            Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class};\n    for (Class<?> c : classesToLookFor) {\n        // 查找注解\n        AspectJAnnotation<?> foundAnnotation = findAnnotation(method, (Class<Annotation>) c);\n        if (foundAnnotation != null) {\n            return foundAnnotation;\n        }\n    }\n    return null;\n}\n")])])]),t("p",[e._v("获取切点的过程并不复杂，不过需要注意的是，目前获取到的切点可能还只是个半成品，需要再次处理一下才行。比如下面的代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('@Aspect\npublic class AnnotationAopCode {\n\n    @Pointcut("execution(* xyz.coolblog.aop.*.world*(..))")\n    public void pointcut() {}\n\n    @Before("pointcut()")\n    public void before() {\n        System.out.println("AnnotationAopCode`s before");\n    }\n}\n')])])]),t("p",[e._v("@Before 注解中的表达式是"),t("code",[e._v("pointcut()")]),e._v("，也就是说 ajexp 设置的表达式只是一个中间值，不是最终值，即"),t("code",[e._v("execution(* xyz.coolblog.aop.*.world*(..))")]),e._v("。所以后续还需要将 ajexp 中的表达式进行转换，关于这个转换的过程，我就不说了。有点复杂，我暂时没怎么看懂。")]),e._v(" "),t("p",[e._v("说完切点的获取过程，下面再来看看 Advisor 实现类的创建过程。如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public InstantiationModelAwarePointcutAdvisorImpl(AspectJExpressionPointcut declaredPointcut,\n        Method aspectJAdviceMethod, AspectJAdvisorFactory aspectJAdvisorFactory,\n        MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) {\n\n    this.declaredPointcut = declaredPointcut;\n    this.declaringClass = aspectJAdviceMethod.getDeclaringClass();\n    this.methodName = aspectJAdviceMethod.getName();\n    this.parameterTypes = aspectJAdviceMethod.getParameterTypes();\n    this.aspectJAdviceMethod = aspectJAdviceMethod;\n    this.aspectJAdvisorFactory = aspectJAdvisorFactory;\n    this.aspectInstanceFactory = aspectInstanceFactory;\n    this.declarationOrder = declarationOrder;\n    this.aspectName = aspectName;\n\n    if (aspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) {\n        Pointcut preInstantiationPointcut = Pointcuts.union(\n                aspectInstanceFactory.getAspectMetadata().getPerClausePointcut(), this.declaredPointcut);\n\n        this.pointcut = new PerTargetInstantiationModelPointcut(\n                this.declaredPointcut, preInstantiationPointcut, aspectInstanceFactory);\n        this.lazy = true;\n    }\n    else {\n        this.pointcut = this.declaredPointcut;\n        this.lazy = false;\n\n        // 按照注解解析 Advice\n        this.instantiatedAdvice = instantiateAdvice(this.declaredPointcut);\n    }\n}\n")])])]),t("p",[e._v("上面是 InstantiationModelAwarePointcutAdvisorImpl 的构造方法，不过我们无需太关心这个方法中的一些初始化逻辑。我们把目光移到构造方法的最后一行代码中，即 instantiateAdvice(this.declaredPointcut)，这个方法用于创建通知 Advice。在上一篇文章中我已经说过，通知器 Advisor 是通知 Advice 的持有者，所以在 Advisor 实现类的构造方法中创建通知也是合适的。那下面我们就来看看构建通知的过程是怎样的，如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('private Advice instantiateAdvice(AspectJExpressionPointcut pcut) {\n    return this.aspectJAdvisorFactory.getAdvice(this.aspectJAdviceMethod, pcut,\n            this.aspectInstanceFactory, this.declarationOrder, this.aspectName);\n}\n\npublic Advice getAdvice(Method candidateAdviceMethod, AspectJExpressionPointcut expressionPointcut,\n        MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) {\n\n    Class<?> candidateAspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();\n    validate(candidateAspectClass);\n\n    // 获取 Advice 注解\n    AspectJAnnotation<?> aspectJAnnotation =\n            AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);\n    if (aspectJAnnotation == null) {\n        return null;\n    }\n\n    if (!isAspect(candidateAspectClass)) {\n        throw new AopConfigException("Advice must be declared inside an aspect type: " +\n                "Offending method \'" + candidateAdviceMethod + "\' in class [" +\n                candidateAspectClass.getName() + "]");\n    }\n\n    if (logger.isDebugEnabled()) {\n        logger.debug("Found AspectJ method: " + candidateAdviceMethod);\n    }\n\n    AbstractAspectJAdvice springAdvice;\n\n    // 按照注解类型生成相应的 Advice 实现类\n    switch (aspectJAnnotation.getAnnotationType()) {\n        case AtBefore:    // @Before -> AspectJMethodBeforeAdvice\n            springAdvice = new AspectJMethodBeforeAdvice(\n                    candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);\n            break;\n\n        case AtAfter:    // @After -> AspectJAfterAdvice\n            springAdvice = new AspectJAfterAdvice(\n                    candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);\n            break;\n\n        case AtAfterReturning:    // @AfterReturning -> AspectJAfterAdvice\n            springAdvice = new AspectJAfterReturningAdvice(\n                    candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);\n            AfterReturning afterReturningAnnotation = (AfterReturning) aspectJAnnotation.getAnnotation();\n            if (StringUtils.hasText(afterReturningAnnotation.returning())) {\n                springAdvice.setReturningName(afterReturningAnnotation.returning());\n            }\n            break;\n\n        case AtAfterThrowing:    // @AfterThrowing -> AspectJAfterThrowingAdvice\n            springAdvice = new AspectJAfterThrowingAdvice(\n                    candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);\n            AfterThrowing afterThrowingAnnotation = (AfterThrowing) aspectJAnnotation.getAnnotation();\n            if (StringUtils.hasText(afterThrowingAnnotation.throwing())) {\n                springAdvice.setThrowingName(afterThrowingAnnotation.throwing());\n            }\n            break;\n\n        case AtAround:    // @Around -> AspectJAroundAdvice\n            springAdvice = new AspectJAroundAdvice(\n                    candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);\n            break;\n\n        /*\n         * 什么都不做，直接返回 null。从整个方法的调用栈来看，\n         * 并不会出现注解类型为 AtPointcut 的情况\n         */ \n        case AtPointcut:    \n            if (logger.isDebugEnabled()) {\n                logger.debug("Processing pointcut \'" + candidateAdviceMethod.getName() + "\'");\n            }\n            return null;\n            \n        default:\n            throw new UnsupportedOperationException(\n                    "Unsupported advice type on method: " + candidateAdviceMethod);\n    }\n\n    springAdvice.setAspectName(aspectName);\n    springAdvice.setDeclarationOrder(declarationOrder);\n    /*\n     * 获取方法的参数列表名称，比如方法 int sum(int numX, int numY), \n     * getParameterNames(sum) 得到 argNames = [numX, numY]\n     */\n    String[] argNames = this.parameterNameDiscoverer.getParameterNames(candidateAdviceMethod);\n    if (argNames != null) {\n        // 设置参数名\n        springAdvice.setArgumentNamesFromStringArray(argNames);\n    }\n    springAdvice.calculateArgumentBindings();\n    return springAdvice;\n}\n')])])]),t("p",[e._v("上面的代码逻辑不是很复杂，主要的逻辑就是根据注解类型生成与之对应的通知对象。下面来总结一下获取通知器（getAdvisors）整个过程的逻辑，如下：")]),e._v(" "),t("ol",[t("li",[e._v("从目标 bean 中获取不包含 Pointcut 注解的方法列表")]),e._v(" "),t("li",[e._v("遍历上一步获取的方法列表，并调用 getAdvisor 获取当前方法对应的 Advisor")]),e._v(" "),t("li",[e._v("创建 AspectJExpressionPointcut 对象，并从方法中的注解中获取表达式，最后设置到切点对象中")]),e._v(" "),t("li",[e._v("创建 Advisor 实现类对象 InstantiationModelAwarePointcutAdvisorImpl")]),e._v(" "),t("li",[e._v("调用 instantiateAdvice 方法构建通知")]),e._v(" "),t("li",[e._v("调用 getAdvice 方法，并根据注解类型创建相应的通知")])]),e._v(" "),t("p",[e._v("如上所示，上面的步骤做了一定的简化。总的来说，获取通知器的过程还是比较复杂的，并不是很容易看懂。大家在阅读的过程中，还要写一些测试代码进行调试才行。调试的过程中，一些不关心的调用就别跟进去了，不然会陷入很深的调用栈中，影响对源码主流程的理解。")]),e._v(" "),t("p",[e._v("现在，大家知道了通知是怎么创建的。那我们难道不要去看看这些通知的实现源码吗？显然，我们应该看一下。那接下里，我们一起来分析一下 AspectJMethodBeforeAdvice，也就是 @Before 注解对应的通知实现类。看看它的逻辑是什么样的。")]),e._v(" "),t("h5",{attrs:{id:"_2-2-1-3-aspectjmethodbeforeadvice-分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-1-3-aspectjmethodbeforeadvice-分析"}},[e._v("#")]),e._v(" 2.2.1.3 AspectJMethodBeforeAdvice 分析")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public class AspectJMethodBeforeAdvice extends AbstractAspectJAdvice implements MethodBeforeAdvice {\n\n    public AspectJMethodBeforeAdvice(\n            Method aspectJBeforeAdviceMethod, AspectJExpressionPointcut pointcut, AspectInstanceFactory aif) {\n\n        super(aspectJBeforeAdviceMethod, pointcut, aif);\n    }\n\n\n    @Override\n    public void before(Method method, Object[] args, Object target) throws Throwable {\n        // 调用通知方法\n        invokeAdviceMethod(getJoinPointMatch(), null, null);\n    }\n\n    @Override\n    public boolean isBeforeAdvice() {\n        return true;\n    }\n\n    @Override\n    public boolean isAfterAdvice() {\n        return false;\n    }\n\n}\n\nprotected Object invokeAdviceMethod(JoinPointMatch jpMatch, Object returnValue, Throwable ex) throws Throwable {\n    // 调用通知方法，并向其传递参数\n    return invokeAdviceMethodWithGivenArgs(argBinding(getJoinPoint(), jpMatch, returnValue, ex));\n}\n\nprotected Object invokeAdviceMethodWithGivenArgs(Object[] args) throws Throwable {\n    Object[] actualArgs = args;\n    if (this.aspectJAdviceMethod.getParameterTypes().length == 0) {\n        actualArgs = null;\n    }\n    try {\n        ReflectionUtils.makeAccessible(this.aspectJAdviceMethod);\n        // 通过反射调用通知方法\n        return this.aspectJAdviceMethod.invoke(this.aspectInstanceFactory.getAspectInstance(), actualArgs);\n    }\n    catch (IllegalArgumentException ex) {\n        throw new AopInvocationException("Mismatch on arguments to advice method [" +\n                this.aspectJAdviceMethod + "]; pointcut expression [" +\n                this.pointcut.getPointcutExpression() + "]", ex);\n    }\n    catch (InvocationTargetException ex) {\n        throw ex.getTargetException();\n    }\n}\n')])])]),t("p",[e._v("如上，AspectJMethodBeforeAdvice 的源码比较简单，这里我们仅关注 before 方法。这个方法调用了父类中的 invokeAdviceMethod，然后 invokeAdviceMethod 在调用 invokeAdviceMethodWithGivenArgs，最后在 invokeAdviceMethodWithGivenArgs 通过反射执行通知方法。是不是很简单？")]),e._v(" "),t("p",[e._v("关于 AspectJMethodBeforeAdvice 就简单介绍到这里吧，至于剩下的几种实现，大家可以自己去看看。好了，关于 AspectJMethodBeforeAdvice 的源码分析，就分析到这里了。我们继续往下看吧。")]),e._v(" "),t("h4",{attrs:{id:"_2-2-2-筛选合适的通知器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-2-筛选合适的通知器"}},[e._v("#")]),e._v(" 2.2.2 筛选合适的通知器")]),e._v(" "),t("p",[e._v("查找出所有的通知器，整个流程还没算完，接下来我们还要对这些通知器进行筛选。适合应用在当前 bean 上的通知器留下，不适合的就让它自生自灭吧。那下面我们来分析一下通知器筛选的过程，如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('protected List<Advisor> findAdvisorsThatCanApply(\n        List<Advisor> candidateAdvisors, Class<?> beanClass, String beanName) {\n\n    ProxyCreationContext.setCurrentProxiedBeanName(beanName);\n    try {\n        // 调用重载方法\n        return AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);\n    }\n    finally {\n        ProxyCreationContext.setCurrentProxiedBeanName(null);\n    }\n}\n\npublic static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {\n    if (candidateAdvisors.isEmpty()) {\n        return candidateAdvisors;\n    }\n    List<Advisor> eligibleAdvisors = new LinkedList<Advisor>();\n    for (Advisor candidate : candidateAdvisors) {\n        // 筛选 IntroductionAdvisor 类型的通知器\n        if (candidate instanceof IntroductionAdvisor && canApply(candidate, clazz)) {\n            eligibleAdvisors.add(candidate);\n        }\n    }\n    boolean hasIntroductions = !eligibleAdvisors.isEmpty();\n    for (Advisor candidate : candidateAdvisors) {\n        if (candidate instanceof IntroductionAdvisor) {\n            continue;\n        }\n\n        // 筛选普通类型的通知器\n        if (canApply(candidate, clazz, hasIntroductions)) {\n            eligibleAdvisors.add(candidate);\n        }\n    }\n    return eligibleAdvisors;\n}\n\npublic static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions) {\n    if (advisor instanceof IntroductionAdvisor) {\n        /*\n         * 从通知器中获取类型过滤器 ClassFilter，并调用 matchers 方法进行匹配。\n         * ClassFilter 接口的实现类 AspectJExpressionPointcut 为例，该类的\n         * 匹配工作由 AspectJ 表达式解析器负责，具体匹配细节这个就没法分析了，我\n         * AspectJ 表达式的工作流程不是很熟\n         */\n        return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);\n    }\n    else if (advisor instanceof PointcutAdvisor) {\n        PointcutAdvisor pca = (PointcutAdvisor) advisor;\n        // 对于普通类型的通知器，这里继续调用重载方法进行筛选\n        return canApply(pca.getPointcut(), targetClass, hasIntroductions);\n    }\n    else {\n        return true;\n    }\n}\n\npublic static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {\n    Assert.notNull(pc, "Pointcut must not be null");\n    // 使用 ClassFilter 匹配 class\n    if (!pc.getClassFilter().matches(targetClass)) {\n        return false;\n    }\n\n    MethodMatcher methodMatcher = pc.getMethodMatcher();\n    if (methodMatcher == MethodMatcher.TRUE) {\n        return true;\n    }\n\n    IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null;\n    if (methodMatcher instanceof IntroductionAwareMethodMatcher) {\n        introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;\n    }\n\n    /*\n     * 查找当前类及其父类（以及父类的父类等等）所实现的接口，由于接口中的方法是 public，\n     * 所以当前类可以继承其父类，和父类的父类中所有的接口方法\n     */ \n    Set<Class<?>> classes = new LinkedHashSet<Class<?>>(ClassUtils.getAllInterfacesForClassAsSet(targetClass));\n    classes.add(targetClass);\n    for (Class<?> clazz : classes) {\n        // 获取当前类的方法列表，包括从父类中继承的方法\n        Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);\n        for (Method method : methods) {\n            // 使用 methodMatcher 匹配方法，匹配成功即可立即返回\n            if ((introductionAwareMethodMatcher != null &&\n                    introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||\n                    methodMatcher.matches(method, targetClass)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n')])])]),t("p",[e._v("以上是通知器筛选的过程，筛选的工作主要由 ClassFilter 和 MethodMatcher 完成。关于 ClassFilter 和 MethodMatcher 我在"),t("a",{attrs:{href:"http://www.coolblog.xyz/2018/06/17/Spring-AOP-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E5%AF%BC%E8%AF%BB/",target:"_blank",rel:"noopener noreferrer"}},[e._v("导读"),t("OutboundLink")],1),e._v("一文中已经说过了，这里再说一遍吧。在 AOP 中，切点 Pointcut 是用来匹配连接点的，以 AspectJExpressionPointcut 类型的切点为例。该类型切点实现了ClassFilter 和 MethodMatcher 接口，匹配的工作则是由 AspectJ 表达式解析器复杂。除了使用 AspectJ 表达式进行匹配，Spring 还提供了基于正则表达式的切点类，以及更简单的根据方法名进行匹配的切点类。大家有兴趣的话，可以自己去了解一下，这里就不多说了。")]),e._v(" "),t("p",[e._v("在完成通知器的查找和筛选过程后，还需要进行最后一步处理 – 对通知器列表进行拓展。怎么拓展呢？我们一起到下一节中一探究竟吧。")]),e._v(" "),t("h4",{attrs:{id:"_2-2-3-拓展筛选出通知器列表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-3-拓展筛选出通知器列表"}},[e._v("#")]),e._v(" 2.2.3 拓展筛选出通知器列表")]),e._v(" "),t("p",[e._v("拓展方法 extendAdvisors 做的事情并不多，逻辑也比较简单。我们一起来看一下，如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("protected void extendAdvisors(List<Advisor> candidateAdvisors) {\n    AspectJProxyUtils.makeAdvisorChainAspectJCapableIfNecessary(candidateAdvisors);\n}\n\npublic static boolean makeAdvisorChainAspectJCapableIfNecessary(List<Advisor> advisors) {\n    // 如果通知器列表是一个空列表，则啥都不做\n    if (!advisors.isEmpty()) {\n        boolean foundAspectJAdvice = false;\n        /*\n         * 下面的 for 循环用于检测 advisors 列表中是否存在 \n         * AspectJ 类型的 Advisor 或 Advice\n         */\n        for (Advisor advisor : advisors) {\n            if (isAspectJAdvice(advisor)) {\n                foundAspectJAdvice = true;\n            }\n        }\n\n        /*\n         * 向 advisors 列表的首部添加 DefaultPointcutAdvisor，\n         * 至于为什么这样做，我会在后续的文章中进行说明\n         */\n        if (foundAspectJAdvice && !advisors.contains(ExposeInvocationInterceptor.ADVISOR)) {\n            advisors.add(0, ExposeInvocationInterceptor.ADVISOR);\n            return true;\n        }\n    }\n    return false;\n}\n\nprivate static boolean isAspectJAdvice(Advisor advisor) {\n    return (advisor instanceof InstantiationModelAwarePointcutAdvisor ||\n            advisor.getAdvice() instanceof AbstractAspectJAdvice ||\n            (advisor instanceof PointcutAdvisor &&\n                     ((PointcutAdvisor) advisor).getPointcut() instanceof AspectJExpressionPointcut));\n}\n")])])]),t("p",[e._v("如上，上面的代码比较少，也不复杂。由源码可以看出 extendAdvisors 是一个空壳方法，除了调用makeAdvisorChainAspectJCapableIfNecessary，该方法没有其他更多的逻辑了。至于 makeAdvisorChainAspectJCapableIfNecessary 这个方法，该方法主要的目的是向通知器列表首部添加 DefaultPointcutAdvisor 类型的通知器，也就是 ExposeInvocationInterceptor.ADVISOR。至于添加此种类型通知器的意图，我会在后面文章里说明，这里不便展开。关于 extendAdvisors 这个方法，这里就先说到这了。")])])}),[],!1,null,null,null);n.default=s.exports}}]);